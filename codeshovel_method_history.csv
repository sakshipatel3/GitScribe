Method Name,Method Block,Commit Count,Change Types,Commit ID,Commit Author,Commit Message
selectEnvironments,public List<StartEnvironment> selectEnvironments() throws IOException {
        System.out.println("Selecting Environments");

        System.out.println("selectEnvironments - ORACLE_DIR: " + ORACLE_DIR);
        System.out.println("selectEnvironments - REPO_DIR: " + REPO_DIR);
        System.out.println("selectEnvironments - ENV_NAMES ([] runs all oracles): " + GlobalEnv.ENV_NAMES);
        System.out.println("selectEnvironments - SKIP_NAMES ([] does not skip): " + GlobalEnv.SKIP_NAMES);

        ClassLoader classLoader = MainDynamicOracleTest.class.getClassLoader();

        if (REPO_DIR == null) {
            System.err.println("REPO_DIR environment variable must be specified");
            System.exit(1);
        }

        File directory = null;
        try {
            directory = new File(classLoader.getResource(ORACLE_DIR).getFile());
        } catch (Exception e) {
            System.err.println("MainDynamicOracle - ORACLE_DIR is not present: " + ORACLE_DIR);
            System.exit(1);
        }

        ArrayList<StartEnvironment> selectedEnvironments = new ArrayList<>();
        int skipCount = 0;

        List<File> files = Arrays.asList(directory.listFiles());
        Collections.sort(files);

        for (File file : files) {
            String envName = file.getName().replace(".json"  "");

            boolean shouldSkip = false;
            // skip anything explicitly excluded
            if (GlobalEnv.SKIP_NAMES.size() > 0) {
                // only consider skips if there are some
                for (String excludedEnv : GlobalEnv.SKIP_NAMES) {
                    if (envName.startsWith(excludedEnv.trim())) {
                        System.out.println("Skipping env due to SKIP_NAMES env var: " + envName + "; skipEnv: " + excludedEnv);
                        shouldSkip = true;
                    }
                }
            } else {
                // no skips  keep going
            }

            boolean shouldInclude = false;
            if (shouldSkip == false) {
                // if includes specified  only consider those
                if (GlobalEnv.ENV_NAMES.size() > 0) {
                    for (String includedEnv : GlobalEnv.ENV_NAMES) {
                        if (envName.startsWith(includedEnv.trim())) {
                            shouldInclude = true;
                        }
                    }
                } else {
                    System.out.println("Including all envs due to ENV_NAME being empty");
                    shouldInclude = true;
                }
            }

            if (shouldInclude == false) {
                // System.out.println("Skipping env due to ENV_NAME not containing: " + envName);
                skipCount++;
            } else if (shouldSkip == true) {
                // System.out.println("Skipping env due to SKIP_NAMES containing: " + envName);
                skipCount++;
            } else {
                System.out.println("Including environment: " + envName);
                String json = FileUtils.readFileToString(file  "utf-8");
                StartEnvironment startEnv = GSON.fromJson(json  StartEnvironment.class);
                startEnv.setEnvName(envName);

                selectedEnvironments.add(startEnv);
            }
        }

        System.out.println("Environments Selected; # included: " +
                selectedEnvironments.size() + "; # skipped: " + skipCount);

        return selectedEnvironments;
    },1,,64469af902c84e426716d82b0e5bc07fdf0f7df6,Reid Holmes,see #47 better reporting oracle results 
createDynamicTests,@TestFactory
    @Execution(ExecutionMode.CONCURRENT) // NOTE: tests might only run concurrently using `mvn test`
    @DisplayName("Dynamic test oracles from JSON files")
    public Collection<DynamicTest> createDynamicTests() throws Exception {

        List<StartEnvironment> selectedEnvironments = this.selectEnvironments();

        List<DynamicTest> dynamicTests = new ArrayList<>();
        for (StartEnvironment env : selectedEnvironments) {
            System.out.println("TestFactory - Creating suite for: " + env.getEnvName());
            dynamicTests.add(createDynamicTest(env));
            System.out.println("TestFactory - Suite created for: " + env.getEnvName());
        }

        // Sort the tests so we work through them consistently
        // Specifically  need an alph order  not lexicographic
        // (e.g.  Java sorts Z before a)
        Collections.sort(dynamicTests  (DynamicTest t1  DynamicTest t2) ->
                t1.getDisplayName().toLowerCase(Locale.ROOT).
                        compareTo(t2.getDisplayName().toLowerCase(Locale.ROOT)));

        return dynamicTests;
    },1,,64469af902c84e426716d82b0e5bc07fdf0f7df6,Reid Holmes,see #47 better reporting oracle results 
createDynamicTest,private DynamicTest createDynamicTest(StartEnvironment startEnv) throws IOException {
        DynamicTest test = null;
        System.out.println("Running dynamic test for config: " + startEnv.getEnvName());

        try {
            test = doCreateDynamicTest(startEnv);
        } catch (Exception e) {
            log.error("Could run Shovel execution for Env: {{}}. Skipping."  startEnv.getEnvName()  e);
        }

        return test;
    },1,,64469af902c84e426716d82b0e5bc07fdf0f7df6,Reid Holmes,see #47 better reporting oracle results 
doCreateDynamicTest,private DynamicTest doCreateDynamicTest(StartEnvironment startEnv) {
        String message = startEnv.getEnvName();
        System.out.println("Creating test: " + message);

        return DynamicTest.dynamicTest(
                message 
                () -> {
                    Yresult yresult = null;
                    try {
                        StringBuilder actualResultBuilder = new StringBuilder();
                        StringBuilder expectedResultBuilder = new StringBuilder();
                        yresult = runEnvironment(startEnv  actualResultBuilder  expectedResultBuilder);

                        System.out.println("Performing test comparison: " + message);
                        System.out.println("Expected: \n" + expectedResultBuilder.toString());
                        System.out.println("Actual: \n" + actualResultBuilder.toString());
                        boolean results = compareResults(startEnv.getExpectedResult()  yresult); // prints useful data
                        assertEquals(expectedResultBuilder.toString()  actualResultBuilder.toString()  "stringified result should be the same");
                        assertTrue(results  "results should be the same");

                        System.out.println("Test comparison complete: " + message);
                        System.out.println("Test execution complete: " + message);
                    } catch (Exception e) {
                        log.error("Could run Shovel execution for Env: {{}}. Skipping."  startEnv.getEnvName()  e);
                        // clear large objects
                        startEnv.setRepositoryService(null);
                        yresult = null;
                        throw e;
                    }
                    // clear large objects
                    startEnv.setRepositoryService(null);
                    yresult = null;
                }
        );
    },1,Body Change,64469af902c84e426716d82b0e5bc07fdf0f7df6,Reid Holmes,see #47 better reporting oracle results 
performComparison,public boolean performComparison(StartEnvironment startEnv) throws Exception {
        Yresult yresult = null;
        try {
            String message = startEnv.getEnvName();

            StringBuilder actualResultBuilder = new StringBuilder();
            StringBuilder expectedResultBuilder = new StringBuilder();
            yresult = runEnvironment(startEnv  actualResultBuilder  expectedResultBuilder);

            System.out.println("Performing test comparison: " + message);
            if (expectedResultBuilder.toString().equals(actualResultBuilder.toString())) {
                // good
            } else {
                System.err.println(message + " test failed; stringified result should be the same");
                return false;
            }

            if (compareResults(startEnv.getExpectedResult()  yresult)) {
                // good
            } else {
                System.err.println(message + " test failed; results should be the same");
                return false;
            }

            System.out.println("Test succeeded: " + message);
        } catch (Exception e) {
            log.error("Could run Shovel execution for Env: {{}}. Skipping."  startEnv.getEnvName()  e);
            // clear large objects
            startEnv.setRepositoryService(null);
            yresult = null;
            throw e;
        }
        // clear large objects
        startEnv.setRepositoryService(null);
        yresult = null;
        return true;
    },1,,64469af902c84e426716d82b0e5bc07fdf0f7df6,Reid Holmes,see #47 better reporting oracle results 
runEnvironment,public Yresult runEnvironment(StartEnvironment startEnv  StringBuilder actualResultBuilder  StringBuilder expectedResultBuilder) throws IOException  Exception {
        String message = startEnv.getEnvName();

        System.out.println("Executing test: " + message);
        System.err.println("Execution thread: " + Thread.currentThread().getName()); // for tracking concurrent test execution
        String repositoryName = startEnv.getRepositoryName();
        String repositoryPath = REPO_DIR + "/" + repositoryName + "/.git";

        try {
            // this isn't needed here  but is just a sanity check to make sure the repositoryPath actually exists
            File f = new File(repositoryPath);
            if (!f.exists()) {
                throw new FileNotFoundException(repositoryPath);
            }
        } catch (Exception e) {
            System.err.println("MainDynamicOracle - Oracle repository is not present: " + repositoryPath);
            System.exit(1);
        }

        String filePath = startEnv.getFilePath();

        Repository repository = Utl.createRepository(repositoryPath);
        Git git = new Git(repository);
        RepositoryService repositoryService = new CachingRepositoryService(git  repository  repositoryName  repositoryPath);
        Commit startCommit = repositoryService.findCommitByName(startEnv.getStartCommitName());

        startEnv.setRepositoryService(repositoryService);
        startEnv.setRepositoryPath(repositoryPath);
        startEnv.setStartCommit(startCommit);
        startEnv.setFileName(Utl.getFileName(filePath));

        // compute changes
        Yresult yresult = ShovelExecution.runSingle(startEnv  startEnv.getFilePath()  true);

        for (String commitName : yresult.keySet()) {
            actualResultBuilder.append("\n").append(commitName).append(":").append(yresult.get(commitName).getTypeAsString());
        }

        Map<String  String> expectedResult = startEnv.getExpectedResult();
        for (String commitName : expectedResult.keySet()) {
            expectedResultBuilder.append("\n").append(commitName).append(":").append(expectedResult.get(commitName));
        }

        return yresult;
    },1,,64469af902c84e426716d82b0e5bc07fdf0f7df6,Reid Holmes,see #47 better reporting oracle results 
compareResults,private static boolean compareResults(Map<String  String> expectedResult  Yresult actualResult) {

        if (expectedResult.size() != actualResult.size()) {
            System.out.println(String.format("\nNumber of expected results: %s  actual: %s" 
                    expectedResult.size()  actualResult.size()));

            Set<String> expectedKeys = expectedResult.keySet();
            Set<String> actualKeys = new HashSet<>();
            for (String commitName : actualResult.keySet()) {
                actualKeys.add(commitName);
            }
            Set<String> onlyInExpected = new HashSet<>(expectedKeys);
            onlyInExpected.removeAll(actualKeys);
            Set<String> onlyInActual = new HashSet<>(actualKeys);
            onlyInActual.removeAll(expectedKeys);
            if (onlyInExpected.size() > 0) {
                System.out.println("\nOnly in expected (missing in actual): " + onlyInExpected.size() + "\n" + StringUtils.join(onlyInExpected  "\n"));
            }
            if (onlyInActual.size() > 0) {
                System.out.println("\nOnly in actual (not in expected): " + onlyInActual.size() + "\n" + StringUtils.join(onlyInActual  "\n"));
            }

            return false;
        } else {
            System.out.println("\nNumber of expected results: " + expectedResult.size() + " (all found)");
        }

        for (String commitName : actualResult.keySet()) {
            Ychange ychange = actualResult.get(commitName);
            String expectedChangeType = expectedResult.get(commitName);
            if (expectedChangeType == null) {
                System.out.println(String.format("Expected result does not contain commit with name %s"  commitName));
                return false;
            }
            String actualChangeType = ychange.getTypeAsString();
            if (!expectedChangeType.equals(actualChangeType)) {
                System.out.println(String.format("Type of change was not expected for commit %s. Expected: %s  actual: %s" 
                        commitName  expectedChangeType  actualChangeType));
                return false;
            }
        }
        return true;
    },1,Body Change,64469af902c84e426716d82b0e5bc07fdf0f7df6,Reid Holmes,see #47 better reporting oracle results 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,Body Change,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,b6217fda49d3b759cb5ff3e37847e6521288c668,Nick Bradley,Specify execution parameters as environment variables to avoid having to change source code on each execution 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,dfb250b1596f92acf1ff0c127da1a41e12cbbb89,Nick Bradley,Merge changes 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
main,public static void main(String[] args) throws Exception {
		execMining();
	},11,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
ThresholdRunner,public ThresholdRunner() {
        System.out.println("ThresholdRunner::init");
    },7,,598e5d4be87b04e181b2e37e09bd4d8e57a686c5,Reid Holmes,see #47 update oracle with Shaiful's version and add missing rows to elasticsearch method. 
ThresholdRunner,public ThresholdRunner() {
        System.out.println("ThresholdRunner::init");
    },7,,cbce007f93b6b15d6e7791d869bbaa4849c9e328,Reid Holmes,see #47 improve messages in thresholdrunner 
ThresholdRunner,public ThresholdRunner() {
        System.out.println("ThresholdRunner::init");
    },7,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
ThresholdRunner,public ThresholdRunner() {
        System.out.println("ThresholdRunner::init");
    },7,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
ThresholdRunner,public ThresholdRunner() {
        System.out.println("ThresholdRunner::init");
    },7,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
ThresholdRunner,public ThresholdRunner() {
        System.out.println("ThresholdRunner::init");
    },7,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
ThresholdRunner,public ThresholdRunner() {
        System.out.println("ThresholdRunner::init");
    },7,,38c2f74caad6982c1cd23cca9fd6b01f65d5a1a5,reid holmes,see #47 setup parallelization for mvn test running (cuts execution time by 2/3) 
print,/**
     * Trying different permutations generates a lot of log messages.
     * Cache the key messages from ThresholdRunner so they can be
     * played back at the end of the execution.
     *
     * @param msg
     */
    public void print(String msg) {
        System.out.println("ThresholdRunner::" + msg);
        messages.add(msg);
    },7,Signature Change | Body Change,598e5d4be87b04e181b2e37e09bd4d8e57a686c5,Reid Holmes,see #47 update oracle with Shaiful's version and add missing rows to elasticsearch method. 
print,/**
     * Trying different permutations generates a lot of log messages.
     * Cache the key messages from ThresholdRunner so they can be
     * played back at the end of the execution.
     *
     * @param msg
     */
    public void print(String msg) {
        System.out.println("ThresholdRunner::" + msg);
        messages.add(msg);
    },7,Minor Modification,cbce007f93b6b15d6e7791d869bbaa4849c9e328,Reid Holmes,see #47 improve messages in thresholdrunner 
print,/**
     * Trying different permutations generates a lot of log messages.
     * Cache the key messages from ThresholdRunner so they can be
     * played back at the end of the execution.
     *
     * @param msg
     */
    public void print(String msg) {
        System.out.println("ThresholdRunner::" + msg);
        messages.add(msg);
    },7,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
print,/**
     * Trying different permutations generates a lot of log messages.
     * Cache the key messages from ThresholdRunner so they can be
     * played back at the end of the execution.
     *
     * @param msg
     */
    public void print(String msg) {
        System.out.println("ThresholdRunner::" + msg);
        messages.add(msg);
    },7,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
print,/**
     * Trying different permutations generates a lot of log messages.
     * Cache the key messages from ThresholdRunner so they can be
     * played back at the end of the execution.
     *
     * @param msg
     */
    public void print(String msg) {
        System.out.println("ThresholdRunner::" + msg);
        messages.add(msg);
    },7,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
print,/**
     * Trying different permutations generates a lot of log messages.
     * Cache the key messages from ThresholdRunner so they can be
     * played back at the end of the execution.
     *
     * @param msg
     */
    public void print(String msg) {
        System.out.println("ThresholdRunner::" + msg);
        messages.add(msg);
    },7,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
print,/**
     * Trying different permutations generates a lot of log messages.
     * Cache the key messages from ThresholdRunner so they can be
     * played back at the end of the execution.
     *
     * @param msg
     */
    public void print(String msg) {
        System.out.println("ThresholdRunner::" + msg);
        messages.add(msg);
    },7,,38c2f74caad6982c1cd23cca9fd6b01f65d5a1a5,reid holmes,see #47 setup parallelization for mvn test running (cuts execution time by 2/3) 
doIt,public void doIt() throws Exception {
        print("START: " + new Date());
        print("doIt() - start");

        String result = "";
        int count = 0;

        // 1
        Thresholds.resetAll();
        evaluateConfig(count++);
        print("doIt() - CONFIG RESULT BASELINE  NO CHANGES");

////        // 2
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
////
////        // 3
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);//
//
////        // 4
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
//
//
//        //        // 5
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);

        print("doIt() - ThresholdRunner::doIt() - done");

        System.out.println("\n\n\n\n****");
        System.out.println("**** Threshold Results");
        System.out.println("****");
        for (String msg : this.messages) {
            System.out.println(msg);
        }
        System.out.println("****");
        System.out.println("**** / Threshold Results");
        System.out.println("****");
        print("END: " + new Date());
    },7,Body Change,598e5d4be87b04e181b2e37e09bd4d8e57a686c5,Reid Holmes,see #47 update oracle with Shaiful's version and add missing rows to elasticsearch method. 
doIt,public void doIt() throws Exception {
        print("START: " + new Date());
        print("doIt() - start");

        String result = "";
        int count = 0;

        // 1
        Thresholds.resetAll();
        evaluateConfig(count++);
        print("doIt() - CONFIG RESULT BASELINE  NO CHANGES");

////        // 2
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
////
////        // 3
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);//
//
////        // 4
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
//
//
//        //        // 5
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);

        print("doIt() - ThresholdRunner::doIt() - done");

        System.out.println("\n\n\n\n****");
        System.out.println("**** Threshold Results");
        System.out.println("****");
        for (String msg : this.messages) {
            System.out.println(msg);
        }
        System.out.println("****");
        System.out.println("**** / Threshold Results");
        System.out.println("****");
        print("END: " + new Date());
    },7,Body Change,cbce007f93b6b15d6e7791d869bbaa4849c9e328,Reid Holmes,see #47 improve messages in thresholdrunner 
doIt,public void doIt() throws Exception {
        print("START: " + new Date());
        print("doIt() - start");

        String result = "";
        int count = 0;

        // 1
        Thresholds.resetAll();
        evaluateConfig(count++);
        print("doIt() - CONFIG RESULT BASELINE  NO CHANGES");

////        // 2
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
////
////        // 3
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);//
//
////        // 4
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
//
//
//        //        // 5
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);

        print("doIt() - ThresholdRunner::doIt() - done");

        System.out.println("\n\n\n\n****");
        System.out.println("**** Threshold Results");
        System.out.println("****");
        for (String msg : this.messages) {
            System.out.println(msg);
        }
        System.out.println("****");
        System.out.println("**** / Threshold Results");
        System.out.println("****");
        print("END: " + new Date());
    },7,Body Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
doIt,public void doIt() throws Exception {
        print("START: " + new Date());
        print("doIt() - start");

        String result = "";
        int count = 0;

        // 1
        Thresholds.resetAll();
        evaluateConfig(count++);
        print("doIt() - CONFIG RESULT BASELINE  NO CHANGES");

////        // 2
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
////
////        // 3
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);//
//
////        // 4
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
//
//
//        //        // 5
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);

        print("doIt() - ThresholdRunner::doIt() - done");

        System.out.println("\n\n\n\n****");
        System.out.println("**** Threshold Results");
        System.out.println("****");
        for (String msg : this.messages) {
            System.out.println(msg);
        }
        System.out.println("****");
        System.out.println("**** / Threshold Results");
        System.out.println("****");
        print("END: " + new Date());
    },7,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
doIt,public void doIt() throws Exception {
        print("START: " + new Date());
        print("doIt() - start");

        String result = "";
        int count = 0;

        // 1
        Thresholds.resetAll();
        evaluateConfig(count++);
        print("doIt() - CONFIG RESULT BASELINE  NO CHANGES");

////        // 2
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
////
////        // 3
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);//
//
////        // 4
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
//
//
//        //        // 5
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);

        print("doIt() - ThresholdRunner::doIt() - done");

        System.out.println("\n\n\n\n****");
        System.out.println("**** Threshold Results");
        System.out.println("****");
        for (String msg : this.messages) {
            System.out.println(msg);
        }
        System.out.println("****");
        System.out.println("**** / Threshold Results");
        System.out.println("****");
        print("END: " + new Date());
    },7,Body Change,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
doIt,public void doIt() throws Exception {
        print("START: " + new Date());
        print("doIt() - start");

        String result = "";
        int count = 0;

        // 1
        Thresholds.resetAll();
        evaluateConfig(count++);
        print("doIt() - CONFIG RESULT BASELINE  NO CHANGES");

////        // 2
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
////
////        // 3
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);//
//
////        // 4
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
//
//
//        //        // 5
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);

        print("doIt() - ThresholdRunner::doIt() - done");

        System.out.println("\n\n\n\n****");
        System.out.println("**** Threshold Results");
        System.out.println("****");
        for (String msg : this.messages) {
            System.out.println(msg);
        }
        System.out.println("****");
        System.out.println("**** / Threshold Results");
        System.out.println("****");
        print("END: " + new Date());
    },7,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
doIt,public void doIt() throws Exception {
        print("START: " + new Date());
        print("doIt() - start");

        String result = "";
        int count = 0;

        // 1
        Thresholds.resetAll();
        evaluateConfig(count++);
        print("doIt() - CONFIG RESULT BASELINE  NO CHANGES");

////        // 2
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
////
////        // 3
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.80f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);//
//
////        // 4
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.95f);
//        evaluateConfig(count++);
//
//
//        //        // 5
////        // can we use something else?
//        Thresholds.resetAll();
//        Thresholds.MOST_SIM_FUNCTION.setValue(0.85f);
//        Thresholds.MOST_SIM_FUNCTION_MAX.setValue(0.90f);
//        evaluateConfig(count++);

        print("doIt() - ThresholdRunner::doIt() - done");

        System.out.println("\n\n\n\n****");
        System.out.println("**** Threshold Results");
        System.out.println("****");
        for (String msg : this.messages) {
            System.out.println(msg);
        }
        System.out.println("****");
        System.out.println("**** / Threshold Results");
        System.out.println("****");
        print("END: " + new Date());
    },7,,38c2f74caad6982c1cd23cca9fd6b01f65d5a1a5,reid holmes,see #47 setup parallelization for mvn test running (cuts execution time by 2/3) 
evaluateConfig,private void evaluateConfig(int count) throws Exception {
        String result = run();
        count++;
        print("evalConfig() - CONFIG RESULT" + count + " complete; config: ");
        print(Thresholds.toDiffJSON());
        print("evalConfig() - CONFIG RESULT " + count + ": " + result);
    },7,Signature Change | Body Change,598e5d4be87b04e181b2e37e09bd4d8e57a686c5,Reid Holmes,see #47 update oracle with Shaiful's version and add missing rows to elasticsearch method. 
evaluateConfig,private void evaluateConfig(int count) throws Exception {
        String result = run();
        count++;
        print("evalConfig() - CONFIG RESULT" + count + " complete; config: ");
        print(Thresholds.toDiffJSON());
        print("evalConfig() - CONFIG RESULT " + count + ": " + result);
    },7,Body Change,cbce007f93b6b15d6e7791d869bbaa4849c9e328,Reid Holmes,see #47 improve messages in thresholdrunner 
evaluateConfig,private void evaluateConfig(int count) throws Exception {
        String result = run();
        count++;
        print("evalConfig() - CONFIG RESULT" + count + " complete; config: ");
        print(Thresholds.toDiffJSON());
        print("evalConfig() - CONFIG RESULT " + count + ": " + result);
    },7,Body Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
evaluateConfig,private void evaluateConfig(int count) throws Exception {
        String result = run();
        count++;
        print("evalConfig() - CONFIG RESULT" + count + " complete; config: ");
        print(Thresholds.toDiffJSON());
        print("evalConfig() - CONFIG RESULT " + count + ": " + result);
    },7,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
evaluateConfig,private void evaluateConfig(int count) throws Exception {
        String result = run();
        count++;
        print("evalConfig() - CONFIG RESULT" + count + " complete; config: ");
        print(Thresholds.toDiffJSON());
        print("evalConfig() - CONFIG RESULT " + count + ": " + result);
    },7,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
evaluateConfig,private void evaluateConfig(int count) throws Exception {
        String result = run();
        count++;
        print("evalConfig() - CONFIG RESULT" + count + " complete; config: ");
        print(Thresholds.toDiffJSON());
        print("evalConfig() - CONFIG RESULT " + count + ": " + result);
    },7,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
evaluateConfig,private void evaluateConfig(int count) throws Exception {
        String result = run();
        count++;
        print("evalConfig() - CONFIG RESULT" + count + " complete; config: ");
        print(Thresholds.toDiffJSON());
        print("evalConfig() - CONFIG RESULT " + count + ": " + result);
    },7,,38c2f74caad6982c1cd23cca9fd6b01f65d5a1a5,reid holmes,see #47 setup parallelization for mvn test running (cuts execution time by 2/3) 
run,public String run() throws Exception {
        System.out.println("run() - ThresholdRunner::run() - start");

        MainDynamicOracleTest runner = new MainDynamicOracleTest();
        List<StartEnvironment> envs = runner.selectEnvironments();

        int successCount = 0;
        int failCount = 0;
        for (StartEnvironment env : envs) {
            boolean success = runner.performComparison(env);
            if (success) {
                System.out.println("Succeeded: " + env.getEnvName());
                successCount++;
            } else {
                System.err.println("Failed: " + env.getEnvName());
                failCount++;
            }
        }
        String msg = "# success: " + successCount + "; # fail: " + failCount;
        System.out.println("ThresholdRunner::run() - done; " + msg);
        return msg;
    },7,Body Change,598e5d4be87b04e181b2e37e09bd4d8e57a686c5,Reid Holmes,see #47 update oracle with Shaiful's version and add missing rows to elasticsearch method. 
run,public String run() throws Exception {
        System.out.println("run() - ThresholdRunner::run() - start");

        MainDynamicOracleTest runner = new MainDynamicOracleTest();
        List<StartEnvironment> envs = runner.selectEnvironments();

        int successCount = 0;
        int failCount = 0;
        for (StartEnvironment env : envs) {
            boolean success = runner.performComparison(env);
            if (success) {
                System.out.println("Succeeded: " + env.getEnvName());
                successCount++;
            } else {
                System.err.println("Failed: " + env.getEnvName());
                failCount++;
            }
        }
        String msg = "# success: " + successCount + "; # fail: " + failCount;
        System.out.println("ThresholdRunner::run() - done; " + msg);
        return msg;
    },7,Body Change,cbce007f93b6b15d6e7791d869bbaa4849c9e328,Reid Holmes,see #47 improve messages in thresholdrunner 
run,public String run() throws Exception {
        System.out.println("run() - ThresholdRunner::run() - start");

        MainDynamicOracleTest runner = new MainDynamicOracleTest();
        List<StartEnvironment> envs = runner.selectEnvironments();

        int successCount = 0;
        int failCount = 0;
        for (StartEnvironment env : envs) {
            boolean success = runner.performComparison(env);
            if (success) {
                System.out.println("Succeeded: " + env.getEnvName());
                successCount++;
            } else {
                System.err.println("Failed: " + env.getEnvName());
                failCount++;
            }
        }
        String msg = "# success: " + successCount + "; # fail: " + failCount;
        System.out.println("ThresholdRunner::run() - done; " + msg);
        return msg;
    },7,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
run,public String run() throws Exception {
        System.out.println("run() - ThresholdRunner::run() - start");

        MainDynamicOracleTest runner = new MainDynamicOracleTest();
        List<StartEnvironment> envs = runner.selectEnvironments();

        int successCount = 0;
        int failCount = 0;
        for (StartEnvironment env : envs) {
            boolean success = runner.performComparison(env);
            if (success) {
                System.out.println("Succeeded: " + env.getEnvName());
                successCount++;
            } else {
                System.err.println("Failed: " + env.getEnvName());
                failCount++;
            }
        }
        String msg = "# success: " + successCount + "; # fail: " + failCount;
        System.out.println("ThresholdRunner::run() - done; " + msg);
        return msg;
    },7,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
run,public String run() throws Exception {
        System.out.println("run() - ThresholdRunner::run() - start");

        MainDynamicOracleTest runner = new MainDynamicOracleTest();
        List<StartEnvironment> envs = runner.selectEnvironments();

        int successCount = 0;
        int failCount = 0;
        for (StartEnvironment env : envs) {
            boolean success = runner.performComparison(env);
            if (success) {
                System.out.println("Succeeded: " + env.getEnvName());
                successCount++;
            } else {
                System.err.println("Failed: " + env.getEnvName());
                failCount++;
            }
        }
        String msg = "# success: " + successCount + "; # fail: " + failCount;
        System.out.println("ThresholdRunner::run() - done; " + msg);
        return msg;
    },7,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
run,public String run() throws Exception {
        System.out.println("run() - ThresholdRunner::run() - start");

        MainDynamicOracleTest runner = new MainDynamicOracleTest();
        List<StartEnvironment> envs = runner.selectEnvironments();

        int successCount = 0;
        int failCount = 0;
        for (StartEnvironment env : envs) {
            boolean success = runner.performComparison(env);
            if (success) {
                System.out.println("Succeeded: " + env.getEnvName());
                successCount++;
            } else {
                System.err.println("Failed: " + env.getEnvName());
                failCount++;
            }
        }
        String msg = "# success: " + successCount + "; # fail: " + failCount;
        System.out.println("ThresholdRunner::run() - done; " + msg);
        return msg;
    },7,Body Change,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
run,public String run() throws Exception {
        System.out.println("run() - ThresholdRunner::run() - start");

        MainDynamicOracleTest runner = new MainDynamicOracleTest();
        List<StartEnvironment> envs = runner.selectEnvironments();

        int successCount = 0;
        int failCount = 0;
        for (StartEnvironment env : envs) {
            boolean success = runner.performComparison(env);
            if (success) {
                System.out.println("Succeeded: " + env.getEnvName());
                successCount++;
            } else {
                System.err.println("Failed: " + env.getEnvName());
                failCount++;
            }
        }
        String msg = "# success: " + successCount + "; # fail: " + failCount;
        System.out.println("ThresholdRunner::run() - done; " + msg);
        return msg;
    },7,Body Change,38c2f74caad6982c1cd23cca9fd6b01f65d5a1a5,reid holmes,see #47 setup parallelization for mvn test running (cuts execution time by 2/3) 
main,public static void main(String[] args) {
        ThresholdRunner tr = new ThresholdRunner();
        try {
            tr.doIt();
        } catch (Exception e) {
            System.err.println("ThresholdRunner - ERROR: " + e.getMessage());
        }

    },7,,598e5d4be87b04e181b2e37e09bd4d8e57a686c5,Reid Holmes,see #47 update oracle with Shaiful's version and add missing rows to elasticsearch method. 
main,public static void main(String[] args) {
        ThresholdRunner tr = new ThresholdRunner();
        try {
            tr.doIt();
        } catch (Exception e) {
            System.err.println("ThresholdRunner - ERROR: " + e.getMessage());
        }

    },7,Body Change,cbce007f93b6b15d6e7791d869bbaa4849c9e328,Reid Holmes,see #47 improve messages in thresholdrunner 
main,public static void main(String[] args) {
        ThresholdRunner tr = new ThresholdRunner();
        try {
            tr.doIt();
        } catch (Exception e) {
            System.err.println("ThresholdRunner - ERROR: " + e.getMessage());
        }

    },7,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
main,public static void main(String[] args) {
        ThresholdRunner tr = new ThresholdRunner();
        try {
            tr.doIt();
        } catch (Exception e) {
            System.err.println("ThresholdRunner - ERROR: " + e.getMessage());
        }

    },7,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
main,public static void main(String[] args) {
        ThresholdRunner tr = new ThresholdRunner();
        try {
            tr.doIt();
        } catch (Exception e) {
            System.err.println("ThresholdRunner - ERROR: " + e.getMessage());
        }

    },7,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
main,public static void main(String[] args) {
        ThresholdRunner tr = new ThresholdRunner();
        try {
            tr.doIt();
        } catch (Exception e) {
            System.err.println("ThresholdRunner - ERROR: " + e.getMessage());
        }

    },7,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
main,public static void main(String[] args) {
        ThresholdRunner tr = new ThresholdRunner();
        try {
            tr.doIt();
        } catch (Exception e) {
            System.err.println("ThresholdRunner - ERROR: " + e.getMessage());
        }

    },7,,38c2f74caad6982c1cd23cca9fd6b01f65d5a1a5,reid holmes,see #47 setup parallelization for mvn test running (cuts execution time by 2/3) 
main,public static void main(String[] args) throws Exception {
		log("START. Reading repos in " + REPO_DIR);
		List<String> repoNames = getSubdirectories(REPO_DIR);
		Map<String  Map<String  Long>> commitDates = new HashMap<>();
		for (String repoName : repoNames) {
			log("Repo: " + repoName);
			try {
				Map<String  Long> repoCommitDates = new HashMap<>();
				String repoPath = REPO_DIR + "/" + repoName;
				String gitPath = repoPath + "/.git";
				Repository repository = Utl.createRepository(gitPath);
				Git git = new Git(repository);
				LogCommand logCommand = git.log();
				Iterable<RevCommit> commitsIter = logCommand.call();
				List<RevCommit> commits = Lists.newArrayList(commitsIter);
				for (RevCommit commit : commits) {
					Date commitDate = new Date((long) 1000 * commit.getCommitTime());
					repoCommitDates.put(commit.getName()  commitDate.getTime());
				}
				commitDates.put(repoName  repoCommitDates);
			} catch (Exception e) {
				e.printStackTrace();
			}

		}

		String json = new Gson().toJson(commitDates);
		FileUtils.writeStringToFile(new File(OUTPUT_FILE)  json  "utf-8");
		log("DONE. File written to " + OUTPUT_FILE);
	},1,Body Change,1bc957bfacade3475cad435809528dbf1aff5e7a,Felix Grund,improved stats scripts 
getSubdirectories,private static List<String> getSubdirectories(String repoDir) {
		File file = new File(repoDir);
		List<String> directories = Arrays.asList(file.list(new FilenameFilter() {
			@Override
			public boolean accept(File current  String name) {
				return new File(current  name).isDirectory();
			}
		}));
		return directories;
	},1,,1bc957bfacade3475cad435809528dbf1aff5e7a,Felix Grund,improved stats scripts 
accept,@Override
			public boolean accept(File current  String name) {
				return new File(current  name).isDirectory();
			},1,,1bc957bfacade3475cad435809528dbf1aff5e7a,Felix Grund,improved stats scripts 
log,private static void log(Object object) {
		System.out.println(object);
	},1,,1bc957bfacade3475cad435809528dbf1aff5e7a,Felix Grund,improved stats scripts 
main,public static void main(String[] args) throws Exception {
		execMining();
	},3,Body Change,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
main,public static void main(String[] args) throws Exception {
		execMining();
	},3,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
main,public static void main(String[] args) throws Exception {
		execMining();
	},3,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
execMining,static void execMining() throws Exception {
		String repositoryPath = CODESTORY_REPO_DIR + "/" + REPO + "/.git";
		Repository repository = Utl.createRepository(repositoryPath);
		Git git = new Git(repository);

		RepositoryService repositoryService = new CachingRepositoryService(git  repository  REPO  repositoryPath);

		Commit startCommit = repositoryService.findCommitByName(START_COMMIT);

		StartEnvironment env = new StartEnvironment(repositoryService);
		env.setFilePath(TARGET_FILE_PATH);
		env.setFileName(Utl.getFileName(TARGET_FILE_PATH));
		env.setStartCommitName(START_COMMIT);
		env.setStartCommit(startCommit);

		if (TARGET_METHOD != null) {
			env.setFunctionName(TARGET_METHOD);
			if (TARGET_METHOD_STARTLINE != 0) {
				env.setFunctionStartLine(TARGET_METHOD_STARTLINE);
			}
		}

		ShovelExecution.runMining(env  TARGET_FILE_EXTENSION);
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
execMining,static void execMining() throws Exception {
		String repositoryPath = CODESTORY_REPO_DIR + "/" + REPO + "/.git";
		Repository repository = Utl.createRepository(repositoryPath);
		Git git = new Git(repository);

		RepositoryService repositoryService = new CachingRepositoryService(git  repository  REPO  repositoryPath);

		Commit startCommit = repositoryService.findCommitByName(START_COMMIT);

		StartEnvironment env = new StartEnvironment(repositoryService);
		env.setFilePath(TARGET_FILE_PATH);
		env.setFileName(Utl.getFileName(TARGET_FILE_PATH));
		env.setStartCommitName(START_COMMIT);
		env.setStartCommit(startCommit);

		if (TARGET_METHOD != null) {
			env.setFunctionName(TARGET_METHOD);
			if (TARGET_METHOD_STARTLINE != 0) {
				env.setFunctionStartLine(TARGET_METHOD_STARTLINE);
			}
		}

		ShovelExecution.runMining(env  TARGET_FILE_EXTENSION);
	},4,Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
execMining,static void execMining() throws Exception {
		String repositoryPath = CODESTORY_REPO_DIR + "/" + REPO + "/.git";
		Repository repository = Utl.createRepository(repositoryPath);
		Git git = new Git(repository);

		RepositoryService repositoryService = new CachingRepositoryService(git  repository  REPO  repositoryPath);

		Commit startCommit = repositoryService.findCommitByName(START_COMMIT);

		StartEnvironment env = new StartEnvironment(repositoryService);
		env.setFilePath(TARGET_FILE_PATH);
		env.setFileName(Utl.getFileName(TARGET_FILE_PATH));
		env.setStartCommitName(START_COMMIT);
		env.setStartCommit(startCommit);

		if (TARGET_METHOD != null) {
			env.setFunctionName(TARGET_METHOD);
			if (TARGET_METHOD_STARTLINE != 0) {
				env.setFunctionStartLine(TARGET_METHOD_STARTLINE);
			}
		}

		ShovelExecution.runMining(env  TARGET_FILE_EXTENSION);
	},4,Body Change,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
execMining,static void execMining() throws Exception {
		String repositoryPath = CODESTORY_REPO_DIR + "/" + REPO + "/.git";
		Repository repository = Utl.createRepository(repositoryPath);
		Git git = new Git(repository);

		RepositoryService repositoryService = new CachingRepositoryService(git  repository  REPO  repositoryPath);

		Commit startCommit = repositoryService.findCommitByName(START_COMMIT);

		StartEnvironment env = new StartEnvironment(repositoryService);
		env.setFilePath(TARGET_FILE_PATH);
		env.setFileName(Utl.getFileName(TARGET_FILE_PATH));
		env.setStartCommitName(START_COMMIT);
		env.setStartCommit(startCommit);

		if (TARGET_METHOD != null) {
			env.setFunctionName(TARGET_METHOD);
			if (TARGET_METHOD_STARTLINE != 0) {
				env.setFunctionStartLine(TARGET_METHOD_STARTLINE);
			}
		}

		ShovelExecution.runMining(env  TARGET_FILE_EXTENSION);
	},4,Body Change,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
FunctionSimilarity,public FunctionSimilarity(boolean crossFile) {
        this.crossFile = crossFile;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
FunctionSimilarity,public FunctionSimilarity(boolean crossFile) {
        this.crossFile = crossFile;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
FunctionSimilarity,public FunctionSimilarity(boolean crossFile) {
        this.crossFile = crossFile;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
FunctionSimilarity,public FunctionSimilarity(boolean crossFile) {
        this.crossFile = crossFile;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
FunctionSimilarity,public FunctionSimilarity(boolean crossFile) {
        this.crossFile = crossFile;
    },5,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
computeOverallSimilarity,public void computeOverallSimilarity() {
        // TODO: Enhance simlarity (especially name similarity) by
        //  considering parameter similarity and return type similarity

        if (crossFile == true) {
            // Only consider body and name similarity
            this.overallSimilarity = (
                    bodySimilarity + nameSimilarity
            ) / 2; // make it a score 0..1
        } else {
            // Consider body  name  scope  and line similarity
            float max = Thresholds.NAME_SIM_MULT.val() +
                    Thresholds.SCOPE_SIM_MULT.val() +
                    Thresholds.BODY_SIM_MULT.val() +
                    Thresholds.LINE_SIM_MULT.val();

            this.overallSimilarity = (
                    nameSimilarity * Thresholds.NAME_SIM_MULT.val() +
                            scopeSimilarity * Thresholds.SCOPE_SIM_MULT.val() +
                            bodySimilarity * Thresholds.BODY_SIM_MULT.val() +
                            lineNumberSimilarity * Thresholds.LINE_SIM_MULT.val()
            ) / max; // make it a score 0..1
        }
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
computeOverallSimilarity,public void computeOverallSimilarity() {
        // TODO: Enhance simlarity (especially name similarity) by
        //  considering parameter similarity and return type similarity

        if (crossFile == true) {
            // Only consider body and name similarity
            this.overallSimilarity = (
                    bodySimilarity + nameSimilarity
            ) / 2; // make it a score 0..1
        } else {
            // Consider body  name  scope  and line similarity
            float max = Thresholds.NAME_SIM_MULT.val() +
                    Thresholds.SCOPE_SIM_MULT.val() +
                    Thresholds.BODY_SIM_MULT.val() +
                    Thresholds.LINE_SIM_MULT.val();

            this.overallSimilarity = (
                    nameSimilarity * Thresholds.NAME_SIM_MULT.val() +
                            scopeSimilarity * Thresholds.SCOPE_SIM_MULT.val() +
                            bodySimilarity * Thresholds.BODY_SIM_MULT.val() +
                            lineNumberSimilarity * Thresholds.LINE_SIM_MULT.val()
            ) / max; // make it a score 0..1
        }
    },5,Minor Modification,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
computeOverallSimilarity,public void computeOverallSimilarity() {
        // TODO: Enhance simlarity (especially name similarity) by
        //  considering parameter similarity and return type similarity

        if (crossFile == true) {
            // Only consider body and name similarity
            this.overallSimilarity = (
                    bodySimilarity + nameSimilarity
            ) / 2; // make it a score 0..1
        } else {
            // Consider body  name  scope  and line similarity
            float max = Thresholds.NAME_SIM_MULT.val() +
                    Thresholds.SCOPE_SIM_MULT.val() +
                    Thresholds.BODY_SIM_MULT.val() +
                    Thresholds.LINE_SIM_MULT.val();

            this.overallSimilarity = (
                    nameSimilarity * Thresholds.NAME_SIM_MULT.val() +
                            scopeSimilarity * Thresholds.SCOPE_SIM_MULT.val() +
                            bodySimilarity * Thresholds.BODY_SIM_MULT.val() +
                            lineNumberSimilarity * Thresholds.LINE_SIM_MULT.val()
            ) / max; // make it a score 0..1
        }
    },5,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
computeOverallSimilarity,public void computeOverallSimilarity() {
        // TODO: Enhance simlarity (especially name similarity) by
        //  considering parameter similarity and return type similarity

        if (crossFile == true) {
            // Only consider body and name similarity
            this.overallSimilarity = (
                    bodySimilarity + nameSimilarity
            ) / 2; // make it a score 0..1
        } else {
            // Consider body  name  scope  and line similarity
            float max = Thresholds.NAME_SIM_MULT.val() +
                    Thresholds.SCOPE_SIM_MULT.val() +
                    Thresholds.BODY_SIM_MULT.val() +
                    Thresholds.LINE_SIM_MULT.val();

            this.overallSimilarity = (
                    nameSimilarity * Thresholds.NAME_SIM_MULT.val() +
                            scopeSimilarity * Thresholds.SCOPE_SIM_MULT.val() +
                            bodySimilarity * Thresholds.BODY_SIM_MULT.val() +
                            lineNumberSimilarity * Thresholds.LINE_SIM_MULT.val()
            ) / max; // make it a score 0..1
        }
    },5,Minor Modification,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
computeOverallSimilarity,public void computeOverallSimilarity() {
        // TODO: Enhance simlarity (especially name similarity) by
        //  considering parameter similarity and return type similarity

        if (crossFile == true) {
            // Only consider body and name similarity
            this.overallSimilarity = (
                    bodySimilarity + nameSimilarity
            ) / 2; // make it a score 0..1
        } else {
            // Consider body  name  scope  and line similarity
            float max = Thresholds.NAME_SIM_MULT.val() +
                    Thresholds.SCOPE_SIM_MULT.val() +
                    Thresholds.BODY_SIM_MULT.val() +
                    Thresholds.LINE_SIM_MULT.val();

            this.overallSimilarity = (
                    nameSimilarity * Thresholds.NAME_SIM_MULT.val() +
                            scopeSimilarity * Thresholds.SCOPE_SIM_MULT.val() +
                            bodySimilarity * Thresholds.BODY_SIM_MULT.val() +
                            lineNumberSimilarity * Thresholds.LINE_SIM_MULT.val()
            ) / max; // make it a score 0..1
        }
    },5,Body Change,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getScopeSimilarity,public double getScopeSimilarity() {
        return scopeSimilarity;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getScopeSimilarity,public double getScopeSimilarity() {
        return scopeSimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getScopeSimilarity,public double getScopeSimilarity() {
        return scopeSimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getScopeSimilarity,public double getScopeSimilarity() {
        return scopeSimilarity;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getScopeSimilarity,public double getScopeSimilarity() {
        return scopeSimilarity;
    },5,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
setScopeSimilarity,public void setScopeSimilarity(double scopeSimilarity) {
        this.scopeSimilarity = scopeSimilarity;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setScopeSimilarity,public void setScopeSimilarity(double scopeSimilarity) {
        this.scopeSimilarity = scopeSimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
setScopeSimilarity,public void setScopeSimilarity(double scopeSimilarity) {
        this.scopeSimilarity = scopeSimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
setScopeSimilarity,public void setScopeSimilarity(double scopeSimilarity) {
        this.scopeSimilarity = scopeSimilarity;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
setScopeSimilarity,public void setScopeSimilarity(double scopeSimilarity) {
        this.scopeSimilarity = scopeSimilarity;
    },5,Body Change,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getBodySimilarity,public double getBodySimilarity() {
        return bodySimilarity;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getBodySimilarity,public double getBodySimilarity() {
        return bodySimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getBodySimilarity,public double getBodySimilarity() {
        return bodySimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getBodySimilarity,public double getBodySimilarity() {
        return bodySimilarity;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getBodySimilarity,public double getBodySimilarity() {
        return bodySimilarity;
    },5,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getLineNumberSimilarity,public double getLineNumberSimilarity() {
        return lineNumberSimilarity;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getLineNumberSimilarity,public double getLineNumberSimilarity() {
        return lineNumberSimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getLineNumberSimilarity,public double getLineNumberSimilarity() {
        return lineNumberSimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getLineNumberSimilarity,public double getLineNumberSimilarity() {
        return lineNumberSimilarity;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getLineNumberSimilarity,public double getLineNumberSimilarity() {
        return lineNumberSimilarity;
    },5,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
setBodySimilarity,public void setBodySimilarity(double bodySimilarity) {
        this.bodySimilarity = bodySimilarity;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setBodySimilarity,public void setBodySimilarity(double bodySimilarity) {
        this.bodySimilarity = bodySimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
setBodySimilarity,public void setBodySimilarity(double bodySimilarity) {
        this.bodySimilarity = bodySimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
setBodySimilarity,public void setBodySimilarity(double bodySimilarity) {
        this.bodySimilarity = bodySimilarity;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
setBodySimilarity,public void setBodySimilarity(double bodySimilarity) {
        this.bodySimilarity = bodySimilarity;
    },5,Body Change,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
setNameSimilarity,public void setNameSimilarity(double nameSimilarity) {
        this.nameSimilarity = nameSimilarity;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setNameSimilarity,public void setNameSimilarity(double nameSimilarity) {
        this.nameSimilarity = nameSimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
setNameSimilarity,public void setNameSimilarity(double nameSimilarity) {
        this.nameSimilarity = nameSimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
setNameSimilarity,public void setNameSimilarity(double nameSimilarity) {
        this.nameSimilarity = nameSimilarity;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
setNameSimilarity,public void setNameSimilarity(double nameSimilarity) {
        this.nameSimilarity = nameSimilarity;
    },5,Body Change,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getNameSimilarity,public double getNameSimilarity() {
        return nameSimilarity;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getNameSimilarity,public double getNameSimilarity() {
        return nameSimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getNameSimilarity,public double getNameSimilarity() {
        return nameSimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getNameSimilarity,public double getNameSimilarity() {
        return nameSimilarity;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getNameSimilarity,public double getNameSimilarity() {
        return nameSimilarity;
    },5,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
setLineNumberSimilarity,public void setLineNumberSimilarity(double lineNumberSimilarity) {
        this.lineNumberSimilarity = lineNumberSimilarity;
    },5,Body Change,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setLineNumberSimilarity,public void setLineNumberSimilarity(double lineNumberSimilarity) {
        this.lineNumberSimilarity = lineNumberSimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
setLineNumberSimilarity,public void setLineNumberSimilarity(double lineNumberSimilarity) {
        this.lineNumberSimilarity = lineNumberSimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
setLineNumberSimilarity,public void setLineNumberSimilarity(double lineNumberSimilarity) {
        this.lineNumberSimilarity = lineNumberSimilarity;
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
setLineNumberSimilarity,public void setLineNumberSimilarity(double lineNumberSimilarity) {
        this.lineNumberSimilarity = lineNumberSimilarity;
    },5,Body Change,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getOverallSimilarity,public double getOverallSimilarity() {
        computeOverallSimilarity();
        return overallSimilarity;
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getOverallSimilarity,public double getOverallSimilarity() {
        computeOverallSimilarity();
        return overallSimilarity;
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getOverallSimilarity,public double getOverallSimilarity() {
        computeOverallSimilarity();
        return overallSimilarity;
    },5,Minor Modification,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getOverallSimilarity,public double getOverallSimilarity() {
        computeOverallSimilarity();
        return overallSimilarity;
    },5,Body Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getOverallSimilarity,public double getOverallSimilarity() {
        computeOverallSimilarity();
        return overallSimilarity;
    },5,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
toString,@Override
    public String toString() {
        return "BodySimilarity: " + bodySimilarity + "; ScopeSimilarity: " + scopeSimilarity
                + "; NameSimilarity: " + nameSimilarity + "; LineNumberSimilarity: " + lineNumberSimilarity
                + " --- Overall: " + getOverallSimilarity();
    },5,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
toString,@Override
    public String toString() {
        return "BodySimilarity: " + bodySimilarity + "; ScopeSimilarity: " + scopeSimilarity
                + "; NameSimilarity: " + nameSimilarity + "; LineNumberSimilarity: " + lineNumberSimilarity
                + " --- Overall: " + getOverallSimilarity();
    },5,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
toString,@Override
    public String toString() {
        return "BodySimilarity: " + bodySimilarity + "; ScopeSimilarity: " + scopeSimilarity
                + "; NameSimilarity: " + nameSimilarity + "; LineNumberSimilarity: " + lineNumberSimilarity
                + " --- Overall: " + getOverallSimilarity();
    },5,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
toString,@Override
    public String toString() {
        return "BodySimilarity: " + bodySimilarity + "; ScopeSimilarity: " + scopeSimilarity
                + "; NameSimilarity: " + nameSimilarity + "; LineNumberSimilarity: " + lineNumberSimilarity
                + " --- Overall: " + getOverallSimilarity();
    },5,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
toString,@Override
    public String toString() {
        return "BodySimilarity: " + bodySimilarity + "; ScopeSimilarity: " + scopeSimilarity
                + "; NameSimilarity: " + nameSimilarity + "; LineNumberSimilarity: " + lineNumberSimilarity
                + " --- Overall: " + getOverallSimilarity();
    },5,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
Commit,public Commit(RevCommit revCommit) {
		setName(revCommit); // this must be called first!
		setAuthorName(revCommit);
		setAuthorEmail(revCommit);
		setCommitMessage(revCommit);
		setCommitDate(revCommit);
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
Commit,public Commit(RevCommit revCommit) {
		setName(revCommit); // this must be called first!
		setAuthorName(revCommit);
		setAuthorEmail(revCommit);
		setCommitMessage(revCommit);
		setCommitDate(revCommit);
	},4,Minor Modification,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
Commit,public Commit(RevCommit revCommit) {
		setName(revCommit); // this must be called first!
		setAuthorName(revCommit);
		setAuthorEmail(revCommit);
		setCommitMessage(revCommit);
		setCommitDate(revCommit);
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
Commit,public Commit(RevCommit revCommit) {
		setName(revCommit); // this must be called first!
		setAuthorName(revCommit);
		setAuthorEmail(revCommit);
		setCommitMessage(revCommit);
		setCommitDate(revCommit);
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getId,public ObjectId getId() {
		return ObjectId.fromString(this.name);
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getId,public ObjectId getId() {
		return ObjectId.fromString(this.name);
	},4,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getId,public ObjectId getId() {
		return ObjectId.fromString(this.name);
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getId,public ObjectId getId() {
		return ObjectId.fromString(this.name);
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getCommitTime,public long getCommitTime() {
		return commitTime;
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getCommitTime,public long getCommitTime() {
		return commitTime;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitTime,public long getCommitTime() {
		return commitTime;
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getCommitTime,public long getCommitTime() {
		return commitTime;
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
setCommitTime,public void setCommitTime(RevCommit revCommit) {
		this.commitTime = revCommit.getCommitTime();
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setCommitTime,public void setCommitTime(RevCommit revCommit) {
		this.commitTime = revCommit.getCommitTime();
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setCommitTime,public void setCommitTime(RevCommit revCommit) {
		this.commitTime = revCommit.getCommitTime();
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setCommitTime,public void setCommitTime(RevCommit revCommit) {
		this.commitTime = revCommit.getCommitTime();
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
setCommitDate,public void setCommitDate(RevCommit revCommit) {
		this.commitDate = new Date((long) 1000 * revCommit.getCommitTime());
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setCommitDate,public void setCommitDate(RevCommit revCommit) {
		this.commitDate = new Date((long) 1000 * revCommit.getCommitTime());
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setCommitDate,public void setCommitDate(RevCommit revCommit) {
		this.commitDate = new Date((long) 1000 * revCommit.getCommitTime());
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setCommitDate,public void setCommitDate(RevCommit revCommit) {
		this.commitDate = new Date((long) 1000 * revCommit.getCommitTime());
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
setAuthorName,public String setAuthorName(RevCommit revCommit) {
		this.authorName = "";
		try {
			PersonIdent ident = revCommit.getAuthorIdent();
			this.authorName = ident.getName();
		} catch (Exception e) {
			System.out.println("Could not parseMethods author for commit " + getCommitNameShort());
		}
		return authorName;
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setAuthorName,public String setAuthorName(RevCommit revCommit) {
		this.authorName = "";
		try {
			PersonIdent ident = revCommit.getAuthorIdent();
			this.authorName = ident.getName();
		} catch (Exception e) {
			System.out.println("Could not parseMethods author for commit " + getCommitNameShort());
		}
		return authorName;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setAuthorName,public String setAuthorName(RevCommit revCommit) {
		this.authorName = "";
		try {
			PersonIdent ident = revCommit.getAuthorIdent();
			this.authorName = ident.getName();
		} catch (Exception e) {
			System.out.println("Could not parseMethods author for commit " + getCommitNameShort());
		}
		return authorName;
	},4,Minor Modification,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setAuthorName,public String setAuthorName(RevCommit revCommit) {
		this.authorName = "";
		try {
			PersonIdent ident = revCommit.getAuthorIdent();
			this.authorName = ident.getName();
		} catch (Exception e) {
			System.out.println("Could not parseMethods author for commit " + getCommitNameShort());
		}
		return authorName;
	},4,Minor Modification,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
setAuthorEmail,public String setAuthorEmail(RevCommit revCommit) {
		this.authorEmail = "";
		try {
			PersonIdent ident = revCommit.getAuthorIdent();
			this.authorEmail = ident.getEmailAddress();
		} catch (Exception e) {
			System.out.println("Could not parseMethods author for commit " + getCommitNameShort());
		}
		return authorEmail;
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setAuthorEmail,public String setAuthorEmail(RevCommit revCommit) {
		this.authorEmail = "";
		try {
			PersonIdent ident = revCommit.getAuthorIdent();
			this.authorEmail = ident.getEmailAddress();
		} catch (Exception e) {
			System.out.println("Could not parseMethods author for commit " + getCommitNameShort());
		}
		return authorEmail;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setAuthorEmail,public String setAuthorEmail(RevCommit revCommit) {
		this.authorEmail = "";
		try {
			PersonIdent ident = revCommit.getAuthorIdent();
			this.authorEmail = ident.getEmailAddress();
		} catch (Exception e) {
			System.out.println("Could not parseMethods author for commit " + getCommitNameShort());
		}
		return authorEmail;
	},4,Minor Modification,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setAuthorEmail,public String setAuthorEmail(RevCommit revCommit) {
		this.authorEmail = "";
		try {
			PersonIdent ident = revCommit.getAuthorIdent();
			this.authorEmail = ident.getEmailAddress();
		} catch (Exception e) {
			System.out.println("Could not parseMethods author for commit " + getCommitNameShort());
		}
		return authorEmail;
	},4,Minor Modification,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
setCommitMessage,public void setCommitMessage(RevCommit revCommit) {
		try {
			this.commitMessage = revCommit.getFullMessage();
		} catch (NullPointerException e) {
			// It's bad style to catch a NullPointerException but I haven't found out why exactly jGit's getFullMessage
			// would throw a NullPointer. We need to ignore this because we don't want the whole Shovel run for the
			// method to fail just because there's no commit message on a commit.
			this.commitMessage = "[could not be extracted]";
		}

	},4,Body Change,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setCommitMessage,public void setCommitMessage(RevCommit revCommit) {
		try {
			this.commitMessage = revCommit.getFullMessage();
		} catch (NullPointerException e) {
			// It's bad style to catch a NullPointerException but I haven't found out why exactly jGit's getFullMessage
			// would throw a NullPointer. We need to ignore this because we don't want the whole Shovel run for the
			// method to fail just because there's no commit message on a commit.
			this.commitMessage = "[could not be extracted]";
		}

	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setCommitMessage,public void setCommitMessage(RevCommit revCommit) {
		try {
			this.commitMessage = revCommit.getFullMessage();
		} catch (NullPointerException e) {
			// It's bad style to catch a NullPointerException but I haven't found out why exactly jGit's getFullMessage
			// would throw a NullPointer. We need to ignore this because we don't want the whole Shovel run for the
			// method to fail just because there's no commit message on a commit.
			this.commitMessage = "[could not be extracted]";
		}

	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setCommitMessage,public void setCommitMessage(RevCommit revCommit) {
		try {
			this.commitMessage = revCommit.getFullMessage();
		} catch (NullPointerException e) {
			// It's bad style to catch a NullPointerException but I haven't found out why exactly jGit's getFullMessage
			// would throw a NullPointer. We need to ignore this because we don't want the whole Shovel run for the
			// method to fail just because there's no commit message on a commit.
			this.commitMessage = "[could not be extracted]";
		}

	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
setName,public void setName(RevCommit revCommit) {
		this.name = revCommit.getName();
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setName,public void setName(RevCommit revCommit) {
		this.name = revCommit.getName();
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setName,public void setName(RevCommit revCommit) {
		this.name = revCommit.getName();
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setName,public void setName(RevCommit revCommit) {
		this.name = revCommit.getName();
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getCommitDateAsString,public String getCommitDateAsString(Commit revCommit) {
		return Utl.DATE_FORMAT.format(this.commitDate);
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getCommitDateAsString,public String getCommitDateAsString(Commit revCommit) {
		return Utl.DATE_FORMAT.format(this.commitDate);
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitDateAsString,public String getCommitDateAsString(Commit revCommit) {
		return Utl.DATE_FORMAT.format(this.commitDate);
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getCommitDateAsString,public String getCommitDateAsString(Commit revCommit) {
		return Utl.DATE_FORMAT.format(this.commitDate);
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getAuthorName,public String getAuthorName() {
		return authorName;
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getAuthorName,public String getAuthorName() {
		return authorName;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAuthorName,public String getAuthorName() {
		return authorName;
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getAuthorName,public String getAuthorName() {
		return authorName;
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getAuthorEmail,public String getAuthorEmail() {
		return authorEmail;
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getAuthorEmail,public String getAuthorEmail() {
		return authorEmail;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAuthorEmail,public String getAuthorEmail() {
		return authorEmail;
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getAuthorEmail,public String getAuthorEmail() {
		return authorEmail;
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getCommitMessage,public String getCommitMessage() {
		return commitMessage;
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getCommitMessage,public String getCommitMessage() {
		return commitMessage;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitMessage,public String getCommitMessage() {
		return commitMessage;
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getCommitMessage,public String getCommitMessage() {
		return commitMessage;
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getName,public String getName() {
		return name;
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getName,public String getName() {
		return name;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getName,public String getName() {
		return name;
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getName,public String getName() {
		return name;
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getCommitDate,public Date getCommitDate() {
		return commitDate;
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getCommitDate,public Date getCommitDate() {
		return commitDate;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitDate,public Date getCommitDate() {
		return commitDate;
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getCommitDate,public Date getCommitDate() {
		return commitDate;
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getCommitNameShort,public String getCommitNameShort() {
		return this.name.substring(0  6);
	},4,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getCommitNameShort,public String getCommitNameShort() {
		return this.name.substring(0  6);
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitNameShort,public String getCommitNameShort() {
		return this.name.substring(0  6);
	},4,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getCommitNameShort,public String getCommitNameShort() {
		return this.name.substring(0  6);
	},4,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,Signature Change | Body Change,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,09d12d65ff81d7728438215fca820f152cd30bee,Reid Holmes,see #47; get all suites running (either don't add a ENV_NAME or let it be ""). 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,380ccf5f4126c22a12bcb0b32539df66d169c1b2,Reid Holmes,see #37: figured out memory problem  not sure how to fix.  Dynamic tests are all queued up (if you run the suite right now you will see the comparisons (aka the actual run of the executor method in the dynamic test case) all running at the end of the suite. _BUT_: these take a Yresult  which contains a Ychange  which contains a RepositoryService which kindly maintains a large cache. This means that the StartEnvironments aren't being cleared out as we go through the tests as they all need to stick around until the end.  This is also why the tests labels don't update as the tests are made; junit doesn't know about the contents of the test array until it's fully built (which is at the end of the whole process). 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getEnvOptional,private static String getEnvOptional(String envVar  String defaultVal) {
		return Optional.ofNullable(
				System.getenv(envVar)).orElse(defaultVal);
	},13,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
StartEnvironment,public StartEnvironment(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
		this.repositoryPath = repositoryService.getRepositoryPath();
		this.repositoryName = repositoryService.getRepositoryName();
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
StartEnvironment,public StartEnvironment(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
		this.repositoryPath = repositoryService.getRepositoryPath();
		this.repositoryName = repositoryService.getRepositoryName();
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
StartEnvironment,public StartEnvironment(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
		this.repositoryPath = repositoryService.getRepositoryPath();
		this.repositoryName = repositoryService.getRepositoryName();
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
StartEnvironment,public StartEnvironment(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
		this.repositoryPath = repositoryService.getRepositoryPath();
		this.repositoryName = repositoryService.getRepositoryName();
	},5,Minor Modification,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
StartEnvironment,public StartEnvironment(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
		this.repositoryPath = repositoryService.getRepositoryPath();
		this.repositoryName = repositoryService.getRepositoryName();
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getRepositoryService,public RepositoryService getRepositoryService() {
		return this.repositoryService;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getRepositoryService,public RepositoryService getRepositoryService() {
		return this.repositoryService;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepositoryService,public RepositoryService getRepositoryService() {
		return this.repositoryService;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepositoryService,public RepositoryService getRepositoryService() {
		return this.repositoryService;
	},5,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getRepositoryService,public RepositoryService getRepositoryService() {
		return this.repositoryService;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setRepositoryName,public void setRepositoryName(String repositoryName) {
		this.repositoryName = repositoryName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setRepositoryName,public void setRepositoryName(String repositoryName) {
		this.repositoryName = repositoryName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setRepositoryName,public void setRepositoryName(String repositoryName) {
		this.repositoryName = repositoryName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setRepositoryName,public void setRepositoryName(String repositoryName) {
		this.repositoryName = repositoryName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setRepositoryName,public void setRepositoryName(String repositoryName) {
		this.repositoryName = repositoryName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getRepository,public Repository getRepository() {
		return repositoryService.getRepository();
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getRepository,public Repository getRepository() {
		return repositoryService.getRepository();
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepository,public Repository getRepository() {
		return repositoryService.getRepository();
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepository,public Repository getRepository() {
		return repositoryService.getRepository();
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getRepository,public Repository getRepository() {
		return repositoryService.getRepository();
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getGit,public Git getGit() {
		return repositoryService.getGit();
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getGit,public Git getGit() {
		return repositoryService.getGit();
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getGit,public Git getGit() {
		return repositoryService.getGit();
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getGit,public Git getGit() {
		return repositoryService.getGit();
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getGit,public Git getGit() {
		return repositoryService.getGit();
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getFilePath,public String getFilePath() {
		return filePath;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getFilePath,public String getFilePath() {
		return filePath;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFilePath,public String getFilePath() {
		return filePath;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFilePath,public String getFilePath() {
		return filePath;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFilePath,public String getFilePath() {
		return filePath;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getFunctionName,public String getFunctionName() {
		return functionName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getFunctionName,public String getFunctionName() {
		return functionName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionName,public String getFunctionName() {
		return functionName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionName,public String getFunctionName() {
		return functionName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionName,public String getFunctionName() {
		return functionName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getStartCommit,public Commit getStartCommit() {
		return startCommit;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getStartCommit,public Commit getStartCommit() {
		return startCommit;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getStartCommit,public Commit getStartCommit() {
		return startCommit;
	},5,Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getStartCommit,public Commit getStartCommit() {
		return startCommit;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getStartCommit,public Commit getStartCommit() {
		return startCommit;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setStartCommit,public void setStartCommit(Commit startCommit) {
		this.startCommit = startCommit;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setStartCommit,public void setStartCommit(Commit startCommit) {
		this.startCommit = startCommit;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setStartCommit,public void setStartCommit(Commit startCommit) {
		this.startCommit = startCommit;
	},5,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setStartCommit,public void setStartCommit(Commit startCommit) {
		this.startCommit = startCommit;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setStartCommit,public void setStartCommit(Commit startCommit) {
		this.startCommit = startCommit;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getFileName,public String getFileName() {
		return fileName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getFileName,public String getFileName() {
		return fileName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFileName,public String getFileName() {
		return fileName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFileName,public String getFileName() {
		return fileName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFileName,public String getFileName() {
		return fileName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getEnvName,public String getEnvName() {
		return envName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getEnvName,public String getEnvName() {
		return envName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getEnvName,public String getEnvName() {
		return envName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getEnvName,public String getEnvName() {
		return envName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getEnvName,public String getEnvName() {
		return envName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setEnvName,public void setEnvName(String envName) {
		this.envName = envName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setEnvName,public void setEnvName(String envName) {
		this.envName = envName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setEnvName,public void setEnvName(String envName) {
		this.envName = envName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setEnvName,public void setEnvName(String envName) {
		this.envName = envName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setEnvName,public void setEnvName(String envName) {
		this.envName = envName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getExpectedResult,public LinkedHashMap<String  String> getExpectedResult() {
		return expectedResult;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getExpectedResult,public LinkedHashMap<String  String> getExpectedResult() {
		return expectedResult;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getExpectedResult,public LinkedHashMap<String  String> getExpectedResult() {
		return expectedResult;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getExpectedResult,public LinkedHashMap<String  String> getExpectedResult() {
		return expectedResult;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getExpectedResult,public LinkedHashMap<String  String> getExpectedResult() {
		return expectedResult;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setExpectedResult,public void setExpectedResult(LinkedHashMap<String  String> expectedResult) {
		this.expectedResult = expectedResult;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setExpectedResult,public void setExpectedResult(LinkedHashMap<String  String> expectedResult) {
		this.expectedResult = expectedResult;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setExpectedResult,public void setExpectedResult(LinkedHashMap<String  String> expectedResult) {
		this.expectedResult = expectedResult;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setExpectedResult,public void setExpectedResult(LinkedHashMap<String  String> expectedResult) {
		this.expectedResult = expectedResult;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setExpectedResult,public void setExpectedResult(LinkedHashMap<String  String> expectedResult) {
		this.expectedResult = expectedResult;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setBaseline,public void setBaseline(List<String> baseline) {
		this.baseline = baseline;
	},5,Signature Change | Body Change,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setBaseline,public void setBaseline(List<String> baseline) {
		this.baseline = baseline;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setBaseline,public void setBaseline(List<String> baseline) {
		this.baseline = baseline;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setBaseline,public void setBaseline(List<String> baseline) {
		this.baseline = baseline;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setBaseline,public void setBaseline(List<String> baseline) {
		this.baseline = baseline;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getBaseline,public List<String> getBaseline() {
		return baseline;
	},5,Signature Change | Body Change,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getBaseline,public List<String> getBaseline() {
		return baseline;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getBaseline,public List<String> getBaseline() {
		return baseline;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getBaseline,public List<String> getBaseline() {
		return baseline;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getBaseline,public List<String> getBaseline() {
		return baseline;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setRepositoryService,public void setRepositoryService(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setRepositoryService,public void setRepositoryService(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setRepositoryService,public void setRepositoryService(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setRepositoryService,public void setRepositoryService(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setRepositoryService,public void setRepositoryService(RepositoryService repositoryService) {
		this.repositoryService = repositoryService;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setRepositoryPath,public void setRepositoryPath(String repositoryPath) {
		this.repositoryPath = repositoryPath;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setRepositoryPath,public void setRepositoryPath(String repositoryPath) {
		this.repositoryPath = repositoryPath;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setRepositoryPath,public void setRepositoryPath(String repositoryPath) {
		this.repositoryPath = repositoryPath;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setRepositoryPath,public void setRepositoryPath(String repositoryPath) {
		this.repositoryPath = repositoryPath;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setRepositoryPath,public void setRepositoryPath(String repositoryPath) {
		this.repositoryPath = repositoryPath;
	},5,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
setOutputFilePath,public void setOutputFilePath(String outputFilePath) {
		this.outputFilePath = outputFilePath;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
setOutputFilePath,public void setOutputFilePath(String outputFilePath) {
		this.outputFilePath = outputFilePath;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setOutputFilePath,public void setOutputFilePath(String outputFilePath) {
		this.outputFilePath = outputFilePath;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setOutputFilePath,public void setOutputFilePath(String outputFilePath) {
		this.outputFilePath = outputFilePath;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setOutputFilePath,public void setOutputFilePath(String outputFilePath) {
		this.outputFilePath = outputFilePath;
	},5,Signature Change | Body Change,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getOutputFilePath,public String getOutputFilePath() {
		return outputFilePath;
	},5,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
getOutputFilePath,public String getOutputFilePath() {
		return outputFilePath;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getOutputFilePath,public String getOutputFilePath() {
		return outputFilePath;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getOutputFilePath,public String getOutputFilePath() {
		return outputFilePath;
	},5,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getOutputFilePath,public String getOutputFilePath() {
		return outputFilePath;
	},5,Signature Change | Body Change,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
InFileInterpreter,public InFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
	},10,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,Minor Modification,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
interpret,public Ychange interpret() throws Exception {
		Ychange interpretation;

		Yfunction matchedFunction = this.ycommit.getMatchedFunction();
		Yparser parser = this.ycommit.getParser();
		List<Ychange> changes = new ArrayList<>();

		if (isFirstFunctionOccurrence()) {
			Yfunction compareFunction = null;
			if (matchedFunction != null) {
				compareFunction = this.getCompareFunction(this.ycommit);
			}
			if (compareFunction != null) {
				List<Ysignaturechange> majorChanges = parser.getMajorChanges(this.ycommit  compareFunction);
				changes.addAll(majorChanges);
			}

			if (changes.isEmpty()) {
				changes.add(new Yintroduced(this.startEnv  this.ycommit.getMatchedFunction()));
			} else {
				Ysignaturechange firstMajorChange = (Ysignaturechange) changes.get(0);
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  firstMajorChange.getOldFunction());
				changes.addAll(minorChanges);
			}
		} else {
			Yfunction parentMatchedFunction = ycommit.getPrev().getMatchedFunction();
			if (ycommit.getPrev() != null && parentMatchedFunction != null) {
				List<Ychange> minorChanges = parser.getMinorChanges(ycommit  parentMatchedFunction);
				changes.addAll(minorChanges);
			}
		}

		int numChanges = changes.size();
		if (numChanges > 1) {
			interpretation = new Ymultichange(this.startEnv  this.ycommit.getCommit()  changes);
		} else if (numChanges == 1) {
			interpretation = changes.get(0);
		} else {
			interpretation = new Ynochange(this.startEnv  this.ycommit.getCommit());
		}

		return interpretation;
	},10,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,Minor Modification,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,Body Change,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,Body Change,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,Minor Modification,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,Minor Modification,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getCompareFunction,private Yfunction getCompareFunction(Ycommit ycommit) throws Exception {
		Yfunction ret = null;
		Ycommit parentCommit = ycommit.getPrev();
		if (parentCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  ycommit.getCommit()  ycommit.getPrev().getCommit()  false);
			Yfunction matchedFunction = ycommit.getMatchedFunction();
			EditList editList = ydiff.getSingleEditList(ycommit.getFilePath());
			if (editList != null) {
				Yparser parentCommitParser = parentCommit.getParser();
				for (Edit edit : editList) {
					int beginA = edit.getBeginA();
					int endA = edit.getEndA();
					if (isEditInMethod(matchedFunction  edit)) {
						String filePathOldAndNew = ycommit.getFilePath();
						List<Yfunction> candidates = getRemovedFunctions(
								ycommit.getCommit()  parentCommit.getCommit()  filePathOldAndNew  filePathOldAndNew  false);
						List<Yfunction> candidatesLineRange = parentCommitParser.findMethodsByLineRange(beginA  endA);
						candidates.addAll(candidatesLineRange);
						candidates = removeDuplicates(candidates);
						ret = parentCommitParser.getMostSimilarFunction(candidates  matchedFunction  false);
						if (ret != null) {
							break; // found it an we can exit the loop
						}
					}
				}
			}
		}
		return ret;
	},10,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,Signature Change | Body Change,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
isEditInMethod,private boolean isEditInMethod(Yfunction method  Edit edit) {
		int methodStart = method.getNameLineNumber();
		int methodEnd = method.getEndLineNumber();
		int editBegin = edit.getBeginB();
		int editEnd = edit.getEndB();
		return (editBegin >= methodStart && editBegin <= methodEnd) // edit begin is within method line range
				|| (editEnd >= methodStart && editEnd <= methodEnd) // edit end is within method line range
				|| (editBegin <= methodStart && editEnd >= methodEnd); // full method is within edit line range
	},10,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,Signature Change | Body Change,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
removeDuplicates,private List<Yfunction> removeDuplicates(List<Yfunction> functions) {
		Map<String  Yfunction> functionsMap = new HashMap<>();
		for (Yfunction function : functions) {
			functionsMap.put(function.getId()  function);
		}
		return new ArrayList<Yfunction>(functionsMap.values());
	},10,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
isFirstFunctionOccurrence,private boolean isFirstFunctionOccurrence() {
		return this.ycommit.getPrev() == null || this.ycommit.getPrev().getMatchedFunction() == null;
	},10,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
CrossFileInterpreter,public CrossFileInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		super(startEnv  ycommit);
		this.startFunction = ycommit.getMatchedFunction();
		this.startParser = ycommit.getParser();
	},12,,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,Minor Modification,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,Body Change,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
interpret,public Ychange interpret() throws Exception {
		Ychange ret = null;
		Commit commit = this.startFunction.getCommit();
		Commit prevCommit = startEnv.getRepositoryService().getPrevCommitNeglectingFile(commit);
		if (prevCommit != null) {
			Ydiff ydiff = new Ydiff(startEnv.getRepositoryService()  commit  prevCommit  true);
			Map<String  DiffEntry> diffEntries = ydiff.getDiff();
			DiffEntry diffEntry = diffEntries.get(startFunction.getSourceFilePath());
			if (diffEntry != null) {
				String oldFilePath = diffEntry.getOldPath();
 				Yfunction compareFunction = null;
				Ycrossfilechange crossFileChange = null;
				if (diffEntry.getChangeType() == DiffEntry.ChangeType.RENAME) {
					compareFunction = getCompareFunctionFromFile(oldFilePath  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Yfilerename(this.startEnv  this.startFunction  compareFunction);
					}
				} else {
					compareFunction = getCompareFunctionFromMultipleFiles(ydiff  prevCommit);
					if (compareFunction != null) {
						crossFileChange = new Ymovefromfile(this.startEnv  this.startFunction  compareFunction);
					}
				}

				if (crossFileChange != null) {
					List<Ychange> allChanges = new ArrayList<>();
					allChanges.add(crossFileChange);
					List<Ychange> majorChanges = startParser.getMinorChanges(ycommit  compareFunction);
					List<Ysignaturechange> minorChanges = startParser.getMajorChanges(ycommit  compareFunction);
					allChanges.addAll(majorChanges);
					allChanges.addAll(minorChanges);
					if (allChanges.size() == 1) {
						ret = allChanges.get(0);
					} else {
						ret = new Ymultichange(this.startEnv  this.startFunction.getCommit()  allChanges);
					}
				}
			}
		}
		return ret;
	},12,,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,Minor Modification,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,Minor Modification,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,Signature Change,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,Signature Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
getCompareFunctionFromMultipleFiles,/**
	 * Handles comparing methods that are spread across files.
	 *
	 * e.g.  to check if a method was in a previous version of a different file.
	 *
	 * By looking at removed functions this specifically searches for methods
	 * that were moved between files in a revision.
	 *
	 * @param ydiff
	 * @param prevCommit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromMultipleFiles(Ydiff ydiff  Commit prevCommit) throws Exception {
		Yfunction ret = null;
		List<Yfunction> allFunctions = new ArrayList<>();
		String acceptedFileExtension = this.startParser.getAcceptedFileExtension();
		Map<String  String> pathMapping = ydiff.getPathMapping();
		for (String oldPath : pathMapping.keySet()) {
			if (oldPath.matches(acceptedFileExtension)) {
				String newPath = pathMapping.get(oldPath);
				List<Yfunction> removedFunctions = getRemovedFunctions(this.ycommit.getCommit()  prevCommit  oldPath  newPath  true);
				allFunctions.addAll(removedFunctions);
			}
		}

		if (!allFunctions.isEmpty()) {
			ret = this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  true);
		}
		return ret;
	},12,Signature Change,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,Minor Modification,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,Signature Change,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,Signature Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
getCompareFunctionFromFile,/**
	 * Handles comparing methods within a file.
	 *
	 * e.g.  to check if a method was in the previous version of the same file.
	 *
	 * @param filePath
	 * @param commit
	 * @return
	 * @throws Exception
	 */
	private Yfunction getCompareFunctionFromFile(String filePath  Commit commit) throws Exception {
		Yparser parser = createParserForCommitAndFile(commit  filePath);
		List<Yfunction> allFunctions = parser.getAllMethods();
		return this.startParser.getMostSimilarFunction(allFunctions  this.startFunction  false);
	},12,Signature Change,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
interpret,protected abstract Ychange interpret() throws Exception;,8,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
interpret,protected abstract Ychange interpret() throws Exception;,8,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
interpret,protected abstract Ychange interpret() throws Exception;,8,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
interpret,protected abstract Ychange interpret() throws Exception;,8,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
interpret,protected abstract Ychange interpret() throws Exception;,8,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
interpret,protected abstract Ychange interpret() throws Exception;,8,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
interpret,protected abstract Ychange interpret() throws Exception;,8,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
interpret,protected abstract Ychange interpret() throws Exception;,8,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
AbstractInterpreter,public AbstractInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		this.startEnv = startEnv;
		this.repositoryName = startEnv.getRepositoryName();
		this.ycommit = ycommit;
	},8,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
AbstractInterpreter,public AbstractInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		this.startEnv = startEnv;
		this.repositoryName = startEnv.getRepositoryName();
		this.ycommit = ycommit;
	},8,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
AbstractInterpreter,public AbstractInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		this.startEnv = startEnv;
		this.repositoryName = startEnv.getRepositoryName();
		this.ycommit = ycommit;
	},8,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
AbstractInterpreter,public AbstractInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		this.startEnv = startEnv;
		this.repositoryName = startEnv.getRepositoryName();
		this.ycommit = ycommit;
	},8,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
AbstractInterpreter,public AbstractInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		this.startEnv = startEnv;
		this.repositoryName = startEnv.getRepositoryName();
		this.ycommit = ycommit;
	},8,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
AbstractInterpreter,public AbstractInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		this.startEnv = startEnv;
		this.repositoryName = startEnv.getRepositoryName();
		this.ycommit = ycommit;
	},8,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
AbstractInterpreter,public AbstractInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		this.startEnv = startEnv;
		this.repositoryName = startEnv.getRepositoryName();
		this.ycommit = ycommit;
	},8,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
AbstractInterpreter,public AbstractInterpreter(StartEnvironment startEnv  Ycommit ycommit) {
		this.startEnv = startEnv;
		this.repositoryName = startEnv.getRepositoryName();
		this.ycommit = ycommit;
	},8,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
createParserForCommitAndFile,protected Yparser createParserForCommitAndFile(Commit commit  String filePath) throws Exception {
		Yparser ret = null;
		String fileContent = startEnv.getRepositoryService().findFileContent(commit  filePath);
		if (fileContent != null) {
			ret = ParserFactory.getParser(this.startEnv  filePath  fileContent  commit);
		}
		return ret;
	},8,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createParserForCommitAndFile,protected Yparser createParserForCommitAndFile(Commit commit  String filePath) throws Exception {
		Yparser ret = null;
		String fileContent = startEnv.getRepositoryService().findFileContent(commit  filePath);
		if (fileContent != null) {
			ret = ParserFactory.getParser(this.startEnv  filePath  fileContent  commit);
		}
		return ret;
	},8,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createParserForCommitAndFile,protected Yparser createParserForCommitAndFile(Commit commit  String filePath) throws Exception {
		Yparser ret = null;
		String fileContent = startEnv.getRepositoryService().findFileContent(commit  filePath);
		if (fileContent != null) {
			ret = ParserFactory.getParser(this.startEnv  filePath  fileContent  commit);
		}
		return ret;
	},8,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
createParserForCommitAndFile,protected Yparser createParserForCommitAndFile(Commit commit  String filePath) throws Exception {
		Yparser ret = null;
		String fileContent = startEnv.getRepositoryService().findFileContent(commit  filePath);
		if (fileContent != null) {
			ret = ParserFactory.getParser(this.startEnv  filePath  fileContent  commit);
		}
		return ret;
	},8,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
createParserForCommitAndFile,protected Yparser createParserForCommitAndFile(Commit commit  String filePath) throws Exception {
		Yparser ret = null;
		String fileContent = startEnv.getRepositoryService().findFileContent(commit  filePath);
		if (fileContent != null) {
			ret = ParserFactory.getParser(this.startEnv  filePath  fileContent  commit);
		}
		return ret;
	},8,Signature Change,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
createParserForCommitAndFile,protected Yparser createParserForCommitAndFile(Commit commit  String filePath) throws Exception {
		Yparser ret = null;
		String fileContent = startEnv.getRepositoryService().findFileContent(commit  filePath);
		if (fileContent != null) {
			ret = ParserFactory.getParser(this.startEnv  filePath  fileContent  commit);
		}
		return ret;
	},8,Signature Change,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
createParserForCommitAndFile,protected Yparser createParserForCommitAndFile(Commit commit  String filePath) throws Exception {
		Yparser ret = null;
		String fileContent = startEnv.getRepositoryService().findFileContent(commit  filePath);
		if (fileContent != null) {
			ret = ParserFactory.getParser(this.startEnv  filePath  fileContent  commit);
		}
		return ret;
	},8,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
createParserForCommitAndFile,protected Yparser createParserForCommitAndFile(Commit commit  String filePath) throws Exception {
		Yparser ret = null;
		String fileContent = startEnv.getRepositoryService().findFileContent(commit  filePath);
		if (fileContent != null) {
			ret = ParserFactory.getParser(this.startEnv  filePath  fileContent  commit);
		}
		return ret;
	},8,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getRemovedFunctions,protected List<Yfunction> getRemovedFunctions(Commit commitNew  Commit commitOld  String oldFilePath  String newFilePath  boolean strictMode)
			throws Exception {

		List<Yfunction> ret = new ArrayList<>();
		// TODO: this shouldn't be done here because we already have these parsers!
		Yparser parserOld = createParserForCommitAndFile(commitOld  oldFilePath);
		Yparser parserNew = createParserForCommitAndFile(commitNew  newFilePath);
		if (parserNew == null) {
			ret = parserOld.getAllMethods();
		} else {
			Map<String  Yfunction> functionsNew = parserNew.getAllMethodsCount();
			Map<String  Yfunction> functionsOld = parserOld.getAllMethodsCount();
			Map<String  Integer> nameCountNew = getFunctionNameCount(functionsNew);
			Map<String  Integer> nameCountOld = getFunctionNameCount(functionsOld);

			Set<String> newFunctionIds = functionsNew.keySet();

			for (String functionId : functionsOld.keySet()) {
				boolean functionIdLost = !newFunctionIds.contains(functionId);
				if (functionIdLost) {
					if (strictMode) {
						Yfunction functionOld = functionsOld.get(functionId);
						String functionName = functionOld.getName();
						Integer countOld = nameCountOld.get(functionName);
						Integer countNew = nameCountNew.get(functionName);
						if (countNew == null || countNew < countOld) {
							ret.add(functionsOld.get(functionId));
						}
					} else {
						ret.add(functionsOld.get(functionId));
					}
				}
			}
		}

		return ret;
	},8,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRemovedFunctions,protected List<Yfunction> getRemovedFunctions(Commit commitNew  Commit commitOld  String oldFilePath  String newFilePath  boolean strictMode)
			throws Exception {

		List<Yfunction> ret = new ArrayList<>();
		// TODO: this shouldn't be done here because we already have these parsers!
		Yparser parserOld = createParserForCommitAndFile(commitOld  oldFilePath);
		Yparser parserNew = createParserForCommitAndFile(commitNew  newFilePath);
		if (parserNew == null) {
			ret = parserOld.getAllMethods();
		} else {
			Map<String  Yfunction> functionsNew = parserNew.getAllMethodsCount();
			Map<String  Yfunction> functionsOld = parserOld.getAllMethodsCount();
			Map<String  Integer> nameCountNew = getFunctionNameCount(functionsNew);
			Map<String  Integer> nameCountOld = getFunctionNameCount(functionsOld);

			Set<String> newFunctionIds = functionsNew.keySet();

			for (String functionId : functionsOld.keySet()) {
				boolean functionIdLost = !newFunctionIds.contains(functionId);
				if (functionIdLost) {
					if (strictMode) {
						Yfunction functionOld = functionsOld.get(functionId);
						String functionName = functionOld.getName();
						Integer countOld = nameCountOld.get(functionName);
						Integer countNew = nameCountNew.get(functionName);
						if (countNew == null || countNew < countOld) {
							ret.add(functionsOld.get(functionId));
						}
					} else {
						ret.add(functionsOld.get(functionId));
					}
				}
			}
		}

		return ret;
	},8,Parameter Change | Signature Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRemovedFunctions,protected List<Yfunction> getRemovedFunctions(Commit commitNew  Commit commitOld  String oldFilePath  String newFilePath  boolean strictMode)
			throws Exception {

		List<Yfunction> ret = new ArrayList<>();
		// TODO: this shouldn't be done here because we already have these parsers!
		Yparser parserOld = createParserForCommitAndFile(commitOld  oldFilePath);
		Yparser parserNew = createParserForCommitAndFile(commitNew  newFilePath);
		if (parserNew == null) {
			ret = parserOld.getAllMethods();
		} else {
			Map<String  Yfunction> functionsNew = parserNew.getAllMethodsCount();
			Map<String  Yfunction> functionsOld = parserOld.getAllMethodsCount();
			Map<String  Integer> nameCountNew = getFunctionNameCount(functionsNew);
			Map<String  Integer> nameCountOld = getFunctionNameCount(functionsOld);

			Set<String> newFunctionIds = functionsNew.keySet();

			for (String functionId : functionsOld.keySet()) {
				boolean functionIdLost = !newFunctionIds.contains(functionId);
				if (functionIdLost) {
					if (strictMode) {
						Yfunction functionOld = functionsOld.get(functionId);
						String functionName = functionOld.getName();
						Integer countOld = nameCountOld.get(functionName);
						Integer countNew = nameCountNew.get(functionName);
						if (countNew == null || countNew < countOld) {
							ret.add(functionsOld.get(functionId));
						}
					} else {
						ret.add(functionsOld.get(functionId));
					}
				}
			}
		}

		return ret;
	},8,Parameter Change | Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getRemovedFunctions,protected List<Yfunction> getRemovedFunctions(Commit commitNew  Commit commitOld  String oldFilePath  String newFilePath  boolean strictMode)
			throws Exception {

		List<Yfunction> ret = new ArrayList<>();
		// TODO: this shouldn't be done here because we already have these parsers!
		Yparser parserOld = createParserForCommitAndFile(commitOld  oldFilePath);
		Yparser parserNew = createParserForCommitAndFile(commitNew  newFilePath);
		if (parserNew == null) {
			ret = parserOld.getAllMethods();
		} else {
			Map<String  Yfunction> functionsNew = parserNew.getAllMethodsCount();
			Map<String  Yfunction> functionsOld = parserOld.getAllMethodsCount();
			Map<String  Integer> nameCountNew = getFunctionNameCount(functionsNew);
			Map<String  Integer> nameCountOld = getFunctionNameCount(functionsOld);

			Set<String> newFunctionIds = functionsNew.keySet();

			for (String functionId : functionsOld.keySet()) {
				boolean functionIdLost = !newFunctionIds.contains(functionId);
				if (functionIdLost) {
					if (strictMode) {
						Yfunction functionOld = functionsOld.get(functionId);
						String functionName = functionOld.getName();
						Integer countOld = nameCountOld.get(functionName);
						Integer countNew = nameCountNew.get(functionName);
						if (countNew == null || countNew < countOld) {
							ret.add(functionsOld.get(functionId));
						}
					} else {
						ret.add(functionsOld.get(functionId));
					}
				}
			}
		}

		return ret;
	},8,Parameter Change | Body Change,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getRemovedFunctions,protected List<Yfunction> getRemovedFunctions(Commit commitNew  Commit commitOld  String oldFilePath  String newFilePath  boolean strictMode)
			throws Exception {

		List<Yfunction> ret = new ArrayList<>();
		// TODO: this shouldn't be done here because we already have these parsers!
		Yparser parserOld = createParserForCommitAndFile(commitOld  oldFilePath);
		Yparser parserNew = createParserForCommitAndFile(commitNew  newFilePath);
		if (parserNew == null) {
			ret = parserOld.getAllMethods();
		} else {
			Map<String  Yfunction> functionsNew = parserNew.getAllMethodsCount();
			Map<String  Yfunction> functionsOld = parserOld.getAllMethodsCount();
			Map<String  Integer> nameCountNew = getFunctionNameCount(functionsNew);
			Map<String  Integer> nameCountOld = getFunctionNameCount(functionsOld);

			Set<String> newFunctionIds = functionsNew.keySet();

			for (String functionId : functionsOld.keySet()) {
				boolean functionIdLost = !newFunctionIds.contains(functionId);
				if (functionIdLost) {
					if (strictMode) {
						Yfunction functionOld = functionsOld.get(functionId);
						String functionName = functionOld.getName();
						Integer countOld = nameCountOld.get(functionName);
						Integer countNew = nameCountNew.get(functionName);
						if (countNew == null || countNew < countOld) {
							ret.add(functionsOld.get(functionId));
						}
					} else {
						ret.add(functionsOld.get(functionId));
					}
				}
			}
		}

		return ret;
	},8,Body Change,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
getRemovedFunctions,protected List<Yfunction> getRemovedFunctions(Commit commitNew  Commit commitOld  String oldFilePath  String newFilePath  boolean strictMode)
			throws Exception {

		List<Yfunction> ret = new ArrayList<>();
		// TODO: this shouldn't be done here because we already have these parsers!
		Yparser parserOld = createParserForCommitAndFile(commitOld  oldFilePath);
		Yparser parserNew = createParserForCommitAndFile(commitNew  newFilePath);
		if (parserNew == null) {
			ret = parserOld.getAllMethods();
		} else {
			Map<String  Yfunction> functionsNew = parserNew.getAllMethodsCount();
			Map<String  Yfunction> functionsOld = parserOld.getAllMethodsCount();
			Map<String  Integer> nameCountNew = getFunctionNameCount(functionsNew);
			Map<String  Integer> nameCountOld = getFunctionNameCount(functionsOld);

			Set<String> newFunctionIds = functionsNew.keySet();

			for (String functionId : functionsOld.keySet()) {
				boolean functionIdLost = !newFunctionIds.contains(functionId);
				if (functionIdLost) {
					if (strictMode) {
						Yfunction functionOld = functionsOld.get(functionId);
						String functionName = functionOld.getName();
						Integer countOld = nameCountOld.get(functionName);
						Integer countNew = nameCountNew.get(functionName);
						if (countNew == null || countNew < countOld) {
							ret.add(functionsOld.get(functionId));
						}
					} else {
						ret.add(functionsOld.get(functionId));
					}
				}
			}
		}

		return ret;
	},8,Body Change,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
getRemovedFunctions,protected List<Yfunction> getRemovedFunctions(Commit commitNew  Commit commitOld  String oldFilePath  String newFilePath  boolean strictMode)
			throws Exception {

		List<Yfunction> ret = new ArrayList<>();
		// TODO: this shouldn't be done here because we already have these parsers!
		Yparser parserOld = createParserForCommitAndFile(commitOld  oldFilePath);
		Yparser parserNew = createParserForCommitAndFile(commitNew  newFilePath);
		if (parserNew == null) {
			ret = parserOld.getAllMethods();
		} else {
			Map<String  Yfunction> functionsNew = parserNew.getAllMethodsCount();
			Map<String  Yfunction> functionsOld = parserOld.getAllMethodsCount();
			Map<String  Integer> nameCountNew = getFunctionNameCount(functionsNew);
			Map<String  Integer> nameCountOld = getFunctionNameCount(functionsOld);

			Set<String> newFunctionIds = functionsNew.keySet();

			for (String functionId : functionsOld.keySet()) {
				boolean functionIdLost = !newFunctionIds.contains(functionId);
				if (functionIdLost) {
					if (strictMode) {
						Yfunction functionOld = functionsOld.get(functionId);
						String functionName = functionOld.getName();
						Integer countOld = nameCountOld.get(functionName);
						Integer countNew = nameCountNew.get(functionName);
						if (countNew == null || countNew < countOld) {
							ret.add(functionsOld.get(functionId));
						}
					} else {
						ret.add(functionsOld.get(functionId));
					}
				}
			}
		}

		return ret;
	},8,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getRemovedFunctions,protected List<Yfunction> getRemovedFunctions(Commit commitNew  Commit commitOld  String oldFilePath  String newFilePath  boolean strictMode)
			throws Exception {

		List<Yfunction> ret = new ArrayList<>();
		// TODO: this shouldn't be done here because we already have these parsers!
		Yparser parserOld = createParserForCommitAndFile(commitOld  oldFilePath);
		Yparser parserNew = createParserForCommitAndFile(commitNew  newFilePath);
		if (parserNew == null) {
			ret = parserOld.getAllMethods();
		} else {
			Map<String  Yfunction> functionsNew = parserNew.getAllMethodsCount();
			Map<String  Yfunction> functionsOld = parserOld.getAllMethodsCount();
			Map<String  Integer> nameCountNew = getFunctionNameCount(functionsNew);
			Map<String  Integer> nameCountOld = getFunctionNameCount(functionsOld);

			Set<String> newFunctionIds = functionsNew.keySet();

			for (String functionId : functionsOld.keySet()) {
				boolean functionIdLost = !newFunctionIds.contains(functionId);
				if (functionIdLost) {
					if (strictMode) {
						Yfunction functionOld = functionsOld.get(functionId);
						String functionName = functionOld.getName();
						Integer countOld = nameCountOld.get(functionName);
						Integer countNew = nameCountNew.get(functionName);
						if (countNew == null || countNew < countOld) {
							ret.add(functionsOld.get(functionId));
						}
					} else {
						ret.add(functionsOld.get(functionId));
					}
				}
			}
		}

		return ret;
	},8,Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getFunctionNameCount,private Map<String  Integer> getFunctionNameCount(Map<String  Yfunction> functions) {
		Map<String  Integer> ret = new HashMap<>();
		for (Yfunction function : functions.values()) {
			String name = function.getName();
			Integer oldValue = ret.get(name);
			if (oldValue == null) {
				ret.put(name  1);
			} else {
				ret.put(name  oldValue + 1);
			}
		}
		return ret;
	},8,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionNameCount,private Map<String  Integer> getFunctionNameCount(Map<String  Yfunction> functions) {
		Map<String  Integer> ret = new HashMap<>();
		for (Yfunction function : functions.values()) {
			String name = function.getName();
			Integer oldValue = ret.get(name);
			if (oldValue == null) {
				ret.put(name  1);
			} else {
				ret.put(name  oldValue + 1);
			}
		}
		return ret;
	},8,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionNameCount,private Map<String  Integer> getFunctionNameCount(Map<String  Yfunction> functions) {
		Map<String  Integer> ret = new HashMap<>();
		for (Yfunction function : functions.values()) {
			String name = function.getName();
			Integer oldValue = ret.get(name);
			if (oldValue == null) {
				ret.put(name  1);
			} else {
				ret.put(name  oldValue + 1);
			}
		}
		return ret;
	},8,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFunctionNameCount,private Map<String  Integer> getFunctionNameCount(Map<String  Yfunction> functions) {
		Map<String  Integer> ret = new HashMap<>();
		for (Yfunction function : functions.values()) {
			String name = function.getName();
			Integer oldValue = ret.get(name);
			if (oldValue == null) {
				ret.put(name  1);
			} else {
				ret.put(name  oldValue + 1);
			}
		}
		return ret;
	},8,Signature Change | Body Change,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getFunctionNameCount,private Map<String  Integer> getFunctionNameCount(Map<String  Yfunction> functions) {
		Map<String  Integer> ret = new HashMap<>();
		for (Yfunction function : functions.values()) {
			String name = function.getName();
			Integer oldValue = ret.get(name);
			if (oldValue == null) {
				ret.put(name  1);
			} else {
				ret.put(name  oldValue + 1);
			}
		}
		return ret;
	},8,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
getFunctionNameCount,private Map<String  Integer> getFunctionNameCount(Map<String  Yfunction> functions) {
		Map<String  Integer> ret = new HashMap<>();
		for (Yfunction function : functions.values()) {
			String name = function.getName();
			Integer oldValue = ret.get(name);
			if (oldValue == null) {
				ret.put(name  1);
			} else {
				ret.put(name  oldValue + 1);
			}
		}
		return ret;
	},8,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
getFunctionNameCount,private Map<String  Integer> getFunctionNameCount(Map<String  Yfunction> functions) {
		Map<String  Integer> ret = new HashMap<>();
		for (Yfunction function : functions.values()) {
			String name = function.getName();
			Integer oldValue = ret.get(name);
			if (oldValue == null) {
				ret.put(name  1);
			} else {
				ret.put(name  oldValue + 1);
			}
		}
		return ret;
	},8,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionNameCount,private Map<String  Integer> getFunctionNameCount(Map<String  Yfunction> functions) {
		Map<String  Integer> ret = new HashMap<>();
		for (Yfunction function : functions.values()) {
			String name = function.getName();
			Integer oldValue = ret.get(name);
			if (oldValue == null) {
				ret.put(name  1);
			} else {
				ret.put(name  oldValue + 1);
			}
		}
		return ret;
	},8,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,Body Change,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv) {
		this.startEnv = startEnv;
		this.repositoryService = startEnv.getRepositoryService();
		this.repository = this.repositoryService.getRepository();
		this.startCommitName = startEnv.getStartCommitName();
		this.currentYcommitCache = new HashMap<>();
		this.taskSpecificHistory = new ArrayList<>();

		// These must be overwritten by setters if this is not the starting task:
		this.filePath = startEnv.getFilePath();
		this.fileName = startEnv.getFileName();
		this.functionStartLine = startEnv.getFunctionStartLine();
		this.functionName = startEnv.getFunctionName();
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,Body Change,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
AnalysisTask,public AnalysisTask(StartEnvironment startEnv  Yfunction oldFunction) throws Exception {
		this(startEnv);
		this.setStartCommitName(oldFunction.getCommitName());
		this.setFilePath(oldFunction.getSourceFilePath());
		this.setFunctionName(oldFunction.getName());
		this.setFunctionStartLine(oldFunction.getNameLineNumber());
		this.setFunctionEndLine(oldFunction.getEndLineNumber());
		this.setFunctionAnnotation(oldFunction.getAnnotation());
		this.setFunctionDoc(oldFunction.getFunctionDoc());
		this.buildAndValidate();
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
build,public void build() throws Exception {
		this.buildAndValidate();
		this.wasBuilt = true;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
run,public void run() throws Exception {
		if (!wasBuilt) {
			throw new Exception("Task was not built yet. Make sure build() is called before run()");
		}
		this.createCommitCollection();
		this.createResult();
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Minor Modification,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Body Change,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Minor Modification,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Minor Modification,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Body Change,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,Minor Modification,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
createResult,private void createResult() {
		this.yresult = new Yresult();
		int numResults = this.taskSpecificHistory.size();
		log.trace("Creating result of size {{}}..."  numResults);
		int status = 0;
		for (Ycommit ycommit : this.taskSpecificHistory) {
			try {
				status++;
				log.trace(status + " / " + numResults);
				InFileInterpreter ifi = new InFileInterpreter(this.startEnv  ycommit);
				Ychange ychange = ifi.interpret();
				if (!(ychange instanceof Ynochange)) {
					if (ychange instanceof Yintroduced) {
						CrossFileInterpreter cfi = new CrossFileInterpreter(this.startEnv  ycommit);
						Ychange crossFileChange = cfi.interpret();
						if (crossFileChange != null) {
							ychange = crossFileChange;
						}
					}
					this.yresult.put(ycommit.getName()  ychange);
				}
				if (hasMajorChange(ychange)) {
					this.lastMajorChange = ychange;
				}
			} catch (Exception e) {
				log.error("Exception occurred interpreting commit {{}}. Ending analysis."  ycommit.getShortName()  e);
				System.out.println("Error interpreting commit " + ycommit.getShortName() + ". Ending analysis.");
				break;
			}

		}
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
hasMajorChange,private boolean hasMajorChange(Ychange ychange) {
		if (isMajorChange(ychange)) {
			return true;
		} else if (ychange instanceof Ymultichange) {
			for (Ychange subChange : ((Ymultichange) ychange).getChanges()) {
				if (isMajorChange(subChange)) {
					return true;
				}
			}
		}
		return false;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,Body Change,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,Body Change,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
isMajorChange,private boolean isMajorChange(Ychange ychange) {
		return ychange instanceof Yparameterchange || ychange instanceof Yrename
				|| ychange instanceof Ycrossfilechange;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
buildAndValidate,private void buildAndValidate() throws Exception {
		Utl.checkNotNull("repository"  startEnv.getRepository());
		Utl.checkNotNull("startCommitName"  this.getStartCommitName());
		Utl.checkNotNull("filePath"  this.filePath);
		Utl.checkNotNull("fileName"  this.fileName);
		Utl.checkNotNull("functionName"  this.functionName);
		Utl.checkNotNull("functionStartLine"  this.functionStartLine);

		Commit commit = repositoryService.findCommitByName(this.startCommitName);
		Utl.checkNotNull("startCommit"  commit);

		String startFileContent = repositoryService.findFileContent(commit  this.filePath);
		Utl.checkNotNull("startFileContent"  startFileContent);

		Yparser startParser = ParserFactory.getParser(this.startEnv  this.filePath  startFileContent  commit);

		this.startFunction = startParser.findFunctionByNameAndLine(this.functionName  this.functionStartLine);
		Utl.checkNotNull("startFunctionNode"  this.startFunction);

		this.startCommit = getOrCreateYcommit(commit  null);
		Utl.checkNotNull("startCommit"  this.startCommit);

		this.functionEndLine = this.startFunction.getEndLineNumber();
		Utl.checkPositiveInt("functionEndLine"  this.functionEndLine);

		String functionPath = this.startFunction.getName();
		Utl.checkNotNull("functionPath"  functionPath);

	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Body Change,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Body Change,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Body Change,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Minor Modification,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Minor Modification,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
createCommitCollection,private void createCommitCollection() throws IOException  NoParserFoundException {

		Yhistory yhistory = repositoryService.getHistory(this.startCommit.getCommit()  this.filePath);

		Ycommit lastConsideredCommit = null;
		Map<String  Commit> allCommits = yhistory.getCommits();
		Set<String> commitNames = allCommits.keySet();
		this.numCommitsTotal = commitNames.size();
		log.trace("Creating commit collection for all {{}} commits..."  commitNames.size());
		int status = 0;
		for (String commitName : commitNames) {
			status++;
			log.trace(status + " / " + this.numCommitsTotal);
			Commit commit = yhistory.getCommits().get(commitName);
			try {
				RevCommit revCommit = yhistory.getRevCommits().get(commit.getName());
				Ycommit ycommit = getOrCreateYcommit(commit  lastConsideredCommit);
				if (ycommit.getMatchedFunction() == null) {
					break;
				}
				if (revCommit.getParentCount() > 0) {
					RevCommit parentRevCommit = revCommit.getParent(0);
					Commit parentCommit = new Commit(parentRevCommit);
					Ycommit parentYcommit = getOrCreateYcommit(parentCommit  ycommit);
					ycommit.setPrev(parentYcommit);
				}
				lastConsideredCommit = ycommit;
				this.taskSpecificHistory.add(ycommit);
			} catch (ParseException e) {
				System.err.println("ParseException occurred for commit or its parent. Skipping. Commit: " + commit.getCommitNameShort());
				System.err.println("--original message: " + e.getMessage());
			}
		}
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,Minor Modification,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,Parameter Change | Signature Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getOrCreateYcommit,private Ycommit getOrCreateYcommit(Commit commit  Ycommit fromChildCommit)
			throws ParseException  IOException  NoParserFoundException {

		String commitName = commit.getName();
		Ycommit ycommit = currentYcommitCache.get(commitName);
		if (ycommit != null) {
			return ycommit;
		}

		Yfunction compareFunction = this.startFunction;
		if (fromChildCommit != null && fromChildCommit.getMatchedFunction() != null) {
			compareFunction = fromChildCommit.getMatchedFunction();
		}

		ycommit = createBaseYcommit(commit);
		if (ycommit.getFileContent() != null) {
			Yparser parser = ParserFactory.getParser(this.startEnv  ycommit.getFilePath()  ycommit.getFileContent()  ycommit.getCommit());
			ycommit.setParser(parser);
			Yfunction matchedFunction = parser.findFunctionByOtherFunction(compareFunction);

			ycommit.setMatchedFunction(matchedFunction);
		}
		currentYcommitCache.put(commitName  ycommit);
		return ycommit;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
createBaseYcommit,private Ycommit createBaseYcommit(Commit commit) throws IOException {
		Ycommit ret = new Ycommit(commit);
		ret.setFileName(this.fileName);
		ret.setFilePath(this.filePath);

		RevTree tree = repositoryService.findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		treeWalk.setFilter(PathFilter.create(this.filePath));

		if (treeWalk.next()) {
			ObjectId objectId = treeWalk.getObjectId(0);
			String fileContent = repositoryService.getFileContentByObjectId(objectId);
			ret.setFileContent(fileContent);
		}

		return ret;

	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
		String[] pathSplit = filePath.split("/");
		this.fileName = pathSplit[pathSplit.length-1];
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setFunctionStartLine,public void setFunctionStartLine(int functionStartLine) {
		this.functionStartLine = functionStartLine;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setFunctionName,public void setFunctionName(String functionName) {
		this.functionName = functionName;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getYresult,public Yresult getYresult() {
		return yresult;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getLastMajorChange,public Ychange getLastMajorChange() {
		return lastMajorChange;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFilePath,public String getFilePath() {
		return filePath;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFilePath,public String getFilePath() {
		return filePath;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFileName,public String getFileName() {
		return fileName;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFileName,public String getFileName() {
		return fileName;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFileName,public String getFileName() {
		return fileName;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFileName,public String getFileName() {
		return fileName;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFileName,public String getFileName() {
		return fileName;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFileName,public String getFileName() {
		return fileName;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getFileName,public String getFileName() {
		return fileName;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFileName,public String getFileName() {
		return fileName;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFileName,public String getFileName() {
		return fileName;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFileName,public String getFileName() {
		return fileName;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFileName,public String getFileName() {
		return fileName;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFileName,public String getFileName() {
		return fileName;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getFileName,public String getFileName() {
		return fileName;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFileName,public String getFileName() {
		return fileName;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getFileName,public String getFileName() {
		return fileName;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getFileName,public String getFileName() {
		return fileName;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFileName,public String getFileName() {
		return fileName;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFileName,public String getFileName() {
		return fileName;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFileName,public String getFileName() {
		return fileName;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getStartCommit,public Ycommit getStartCommit() {
		return startCommit;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionName,public String getFunctionName() {
		return functionName;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setFunctionEndLine,public void setFunctionEndLine(int functionEndLine) {
		this.functionEndLine = functionEndLine;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getStartFunction,public Yfunction getStartFunction() {
		return startFunction;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setStartCommitName,public void setStartCommitName(String startCommitName) {
		this.startCommitName = startCommitName;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getStartEnv,public StartEnvironment getStartEnv() {
		return startEnv;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,Signature Change | Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getNumCommitsTotal,public int getNumCommitsTotal() {
		return numCommitsTotal;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,Signature Change | Body Change,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setFunctionAnnotation,public  void setFunctionAnnotation(String annotations) {
		this.functionAnnotation = annotations;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,Signature Change | Body Change,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionAnnotation,public String getFunctionAnnotation() {
		return functionAnnotation;
	},19,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionDoc,public String getFunctionDoc() {
		return functionDoc;
	},19,Signature Change | Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,780f3bc11d9cc932eb6347bc2261c5203fb7ad60,Felix Grund,Progress on JavaScript parser make-work-again 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setFunctionDoc,public void setFunctionDoc(String functionDoc) {
		this.functionDoc = functionDoc;
	},19,Signature Change | Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
RecursiveAnalysisTask,public RecursiveAnalysisTask(StartEnvironment startEnv  AnalysisTask startTask) {
		this.startEnv = startEnv;
		this.startTask = startTask;
		this.numAnalyzedCommits = 0;
	},1,Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
run,public void run() throws Exception {
		long startTime = new Date().getTime();
		AnalysisTask task = this.startTask;
		runAndPrintOptionally(task);
		this.recursiveResult = this.startTask.getYresult();
		this.numAnalyzedCommits += this.startTask.getNumCommitsTotal();

		while (task.getLastMajorChange() != null) {
			Ychange majorChange = task.getLastMajorChange();
			List<Ychange> changesToConsider = new ArrayList<>();
			if (majorChange instanceof Ycomparefunctionchange) {
				changesToConsider.add(majorChange);
			} else if (majorChange instanceof Ymultichange) {
				Ymultichange multiChange = (Ymultichange) majorChange;
				changesToConsider.add(multiChange.getChanges().get(0));
			}

			for (Ychange ychange : changesToConsider) {
				if (ychange instanceof Ycomparefunctionchange) {
					Ycomparefunctionchange metaChange = (Ycomparefunctionchange) ychange;
					Yfunction oldFunction = metaChange.getOldFunction();
					task = new AnalysisTask(startEnv  oldFunction);
					runAndPrintOptionally(task);
					this.recursiveResult.putAll(task.getYresult());
					this.numAnalyzedCommits += task.getNumCommitsTotal();
				}
			}
		}

		this.timeTaken = new Date().getTime() - startTime;
	},1,Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
runAndPrintOptionally,private void runAndPrintOptionally(AnalysisTask task) throws Exception {
		task.build();
		if (this.printOutput) {
			Utl.printAnalysisRun(task);
		}
		task.run();
		if (this.printOutput) {
			Utl.printMethodHistory(task);
		}
	},1,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setPrintOutput,public void setPrintOutput(boolean printOutput) {
		this.printOutput = printOutput;
	},1,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getResult,public Yresult getResult() {
		return recursiveResult;
	},1,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getNumAnalyzedCommits,public int getNumAnalyzedCommits() {
		return numAnalyzedCommits;
	},1,Signature Change | Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getTimeTaken,public long getTimeTaken() {
		return timeTaken;
	},1,Signature Change | Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,e2e41a766ac2d80a2d4cf0502eedd5a51f1e2874,Felix Grund,* Changed handling of Nashorn parse errors * Some minor refactoring 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,0c6ebff1d489d948c64f69093c8a9dea7660455b,Felix Grund,Remove unused dependencies and removed Ruby version for now (is now in separate branch) 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
getParser,public static Yparser getParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws NoParserFoundException  ParseException {
		String cacheKey = commit.getName() + "-" + DigestUtils.md5Hex(filePath);
		Yparser parser = parserCache.get(cacheKey);
		if (parser == null) {
			if (filePath.matches(JavaParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new JavaParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(PythonParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new PythonParser(startEnv  filePath  fileContent  commit);
			} else if (filePath.matches(TypeScriptParser.ACCEPTED_FILE_EXTENSION)) {
				parser = new TypeScriptParser(startEnv  filePath  fileContent  commit);
			} else {
				throw new NoParserFoundException("No parser found for filename " + filePath);
			}
		}

		parserCache.put(cacheKey  parser);

		return parser;
	},11,Body Change,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
createRepository,public static Repository createRepository(String repositoryPath) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.setGitDir(new File(repositoryPath))
				.readEnvironment() // scan environment GIT_* variables
				.findGitDir() // scan up the file system tree
				.build();
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
checkNotNull,public static void checkNotNull(String field  Object object) throws Exception {
		if (object == null) {
			String msg = String.format("Field '%s' was not set"  field);
			throw new Exception(msg);
		}
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
checkPositiveInt,public static void checkPositiveInt(String field  Object object) throws Exception {
		checkNotNull(field  object);
		try {
			int number = Integer.parseInt(Objects.toString(object));
			if (number <= 0) {
				throw new Exception("Value was an integer but was not positive");
			}
		} catch (NumberFormatException e) {
			throw new Exception("Value was not an integer");
		}

	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
projectDir,public static String projectDir() {
		return System.getProperty("user.dir");
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getBodySimilarity,public static double getBodySimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getBody()  bFunction.getBody());
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getNameSimilarity,public static double getNameSimilarity(Yfunction aFunction  Yfunction bFunction) {
		return new JaroWinklerDistance().apply(aFunction.getName()  bFunction.getName());
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,Body Change,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printMethodHistory,public static void printMethodHistory(AnalysisTask task) {
		System.out.println("\nCodeShovel Change History: " + task.getYresult().toString());
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,Body Change,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printMethodHistory,public static void printMethodHistory(List<String> commitNames) {
		System.out.println("\nGit Log Change History:");
		for (String commitName : commitNames) {
			System.out.println(commitName);
		}
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printAnalysisRun,public static void printAnalysisRun(AnalysisTask task) {
		System.out.println("====================================================");
		System.out.println(String.format("Running Analysis\nCommit: %s\nMethod: %s\nLines: %s-%s" 
				task.getStartCommitName()  task.getFunctionName()  task.getFunctionStartLine()  task.getFunctionEndLine()));
		System.out.println("====================================================");
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Minor Modification,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Body Change,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Body Change,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Body Change,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Body Change,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Body Change,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Body Change,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Body Change,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Minor Modification,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,Body Change,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeOutputFile,public static void writeOutputFile(String subdir  String commitName  String filePath 
				String functionId  String repoName  String content  String fileExtension) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS) {
			return;
		}

		try {
			String baseDir = GlobalEnv.OUTPUT_DIR + "/" + subdir;
			String commitNameShort = commitName.substring(0  5);
			String targetDirPath = baseDir + "/" + repoName;
			if (functionId != null) {
				targetDirPath +=  "/" + commitNameShort + "/" + filePath;
			} else {
				targetDirPath +=  "/" + filePath;
			}

			File targetDir = new File(targetDirPath);
			targetDir.mkdirs();

			File file;
			String filename;
			if (functionId != null) {
				filename = functionId;
			} else {
				filename = commitName;

			}
			if (filename.length() > 150) {
				filename = filename.substring(0  149);
			}
			filename += fileExtension;
			file = new File(targetDirPath + "/" + filename);

			FileUtils.writeStringToFile(file  content  "utf-8");
		} catch (Exception e) {
			log.error("Could not write file for function {{}}. Skipping."  functionId  e);
		}
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,Signature Change | Body Change,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeOutputFileWithPath,private static final void writeOutputFileWithPath(String filePath  String content) throws IOException {
		File file = new File(filePath);
		FileUtils.writeStringToFile(file  content  "utf-8");
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,Signature Change | Body Change,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_RESULTS) {
			return;
		}
		writeOutputFile(
				"codeshovel"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,Signature Change | Body Change,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeShovelResultFile,public static void writeShovelResultFile(JsonResult jsonResult  String outFilePath) throws IOException {
		File file = new File(outFilePath);
		FileUtils.writeStringToFile(file  jsonResult.toJson()  "utf-8");
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,Signature Change | Body Change,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeGitLogFile,public static void writeGitLogFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GITLOG) {
			return;
		}
		writeOutputFile(
				"logcommand"  jsonResult.getStartCommitName()  jsonResult.getSourceFilePath() 
				jsonResult.getFunctionId()  jsonResult.getRepositoryName()  jsonResult.toJson()  ".json"
		);
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,Signature Change | Body Change,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeJsonOracleToFile,public static void writeJsonOracleToFile(JsonResult jsonResult) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_ORACLES) {
			return;
		}

		try {
			String filePath = jsonResult.getSourceFilePath();
			String[] filePathSplit = filePath.split("/");
			String className = filePathSplit[filePathSplit.length-1].replace(".java"  "");
			String baseDir = GlobalEnv.OUTPUT_DIR + "/oracles";
			File file = new File(baseDir + "/" + jsonResult.getRepositoryName() + "-" + className + "-" + jsonResult.getFunctionName() + ".json");
			JsonOracle oracle = new JsonOracle(jsonResult);
			FileUtils.writeStringToFile(file  oracle.toJson()  "utf-8");
		} catch (Exception e) {
			log.error("Could not write oracle file for function {{}}. Skipping."  jsonResult.getFunctionId()  e);
		}
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,Body Change,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeSimilarityToFile,public static void writeSimilarityToFile(
			JsonSimilarity jsonSimilarity 
			String functionId 
			String repoName 
			String filePath) {

		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}

		writeOutputFile(
				"similarity"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  jsonSimilarity.toJson()  ".json"
		);

		StringBuilder builder = new StringBuilder();
		builder.append("=== COMPARE FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getFunction());
		builder.append("\n\n=== MOST SIMILAR FUNCTION ===\n\n");
		builder.append(jsonSimilarity.getMostSimilarFunction());
		builder.append("\n\n=== SIMILARITY ===\n");
		builder.append(jsonSimilarity.getSimilarity());

		writeOutputFile(
				"similarity_plain"  jsonSimilarity.getCommitName()  filePath  functionId 
				repoName  builder.toString()  ".out"
		);
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,Parameter Change | Signature Change | Body Change,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,Body Change,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeSemanticDiff,public static void writeSemanticDiff(String baselineName  JsonResult originalJsonResult  JsonChangeHistoryDiff diff) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SEMANTIC_DIFFS) {
			return;
		}
		writeOutputFile(
				"diff_semantic_" + baselineName  originalJsonResult.getStartCommitName()  originalJsonResult.getSourceFilePath() 
				originalJsonResult.getFunctionId()  originalJsonResult.getRepositoryName()  diff.toJson()  ".json"
		);
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,Body Change,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeGitDiff,public static void writeGitDiff(String commitName  String filePath  Repository repository 
									String repositoryName) throws Exception {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_GIT_DIFFS) {
			return;
		}
		String diff = CmdUtil.gitDiffParent(commitName  filePath  repository.getDirectory().getParentFile());
		writeOutputFile("diff_git"  commitName  filePath  null  repositoryName   diff  ".diff");
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,Body Change,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,Body Change,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
writeJsonSimilarity,public static void writeJsonSimilarity(String repoName  String filePath  Yfunction compareFunction 
										   Yfunction mostSimilarFunction  FunctionSimilarity similarity) {
		if (GlobalEnv.DISABLE_ALL_OUTPUTS || !GlobalEnv.WRITE_SIMILARITIES) {
			return;
		}
		JsonSimilarity.FunctionEntry compareEntry = new JsonSimilarity.FunctionEntry(
				compareFunction.getCommitName() 
				compareFunction.getName() 
				compareFunction.getId() 
				compareFunction.getSourceFragment());
		JsonSimilarity.FunctionEntry mostSimilarEntry = new JsonSimilarity.FunctionEntry(
				mostSimilarFunction.getCommitName() 
				mostSimilarFunction.getName() 
				mostSimilarFunction.getId() 
				mostSimilarFunction.getSourceFragment());


		JsonSimilarity jsonSimilarity = new JsonSimilarity(compareEntry  mostSimilarEntry  similarity);
		Utl.writeSimilarityToFile(jsonSimilarity  compareFunction.getId()  repoName  filePath);
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,Signature Change | Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getTextFragment,public static String getTextFragment(String text  int beginLine  int endLine) {
		List<String> lines = getLines(text);
		List<String> fragmentLines = lines.subList(beginLine - 1  endLine);
		return StringUtils.join(fragmentLines  "\n");
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,Signature Change | Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getLines,public static List<String> getLines(String string) {
		return Arrays.asList(string.split("\r\n|\r|\n"));
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
countLineNumbers,public static int countLineNumbers(String string) {
		return getLines(string).size();
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getMsBetweenCommits,public static long getMsBetweenCommits(Commit oldCommit  Commit newCommit) {
		long newCommitTime = newCommit.getCommitDate().getTime();
		long oldCommitTime = oldCommit.getCommitDate().getTime();
		return newCommitTime - oldCommitTime;
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getDaysBetweenCommits,public static double getDaysBetweenCommits(Commit oldCommit  Commit newCommit) {
		long msBetweenCommits = getMsBetweenCommits(oldCommit  newCommit);
		double daysBetweenNotRounded = (double) msBetweenCommits / (1000*60*60*24);
		BigDecimal decimal = new BigDecimal(daysBetweenNotRounded);
		decimal = decimal.setScale(2  RoundingMode.HALF_UP);
		return decimal.doubleValue();
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getLineNumberDistance,public static int getLineNumberDistance(Yfunction aFunction  Yfunction bFunction) {
		return Math.abs(aFunction.getNameLineNumber() - bFunction.getNameLineNumber());
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getLineNumberSimilarity,public static double getLineNumberSimilarity(Yfunction aFunction  Yfunction bFunction) {
		String aFileSource = aFunction.getSourceFileContent();
		int aNumLines = Utl.countLineNumbers(aFileSource);
		String bFileSource = bFunction.getSourceFileContent();
		int bNumLines = Utl.countLineNumbers(bFileSource);
		double maxLines = Math.max(aNumLines  bNumLines);
		double lineNumberDistance = getLineNumberDistance(aFunction  bFunction);
		double similarity = (maxLines - lineNumberDistance) / maxLines;
		return similarity;
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getFileExtensionWithoutDot,public static String getFileExtensionWithoutDot(String filePath) {
		String[] dotSplit = filePath.split("\\.");
		return dotSplit[dotSplit.length - 1];
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
getFileName,public static String getFileName(String filePath) {
		String[] pathSplit = filePath.split("/");
		return pathSplit[pathSplit.length-1];
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
sanitizeFunctionId,public static String sanitizeFunctionId(String ident) {
		return ident.replaceAll(":"  "__").replaceAll("#"  "__").replaceAll("<"  "__").replaceAll(">"  "__");
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,Signature Change | Body Change,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
resultMapToString,public static String resultMapToString(Map<String  String> result) {
		StringBuilder builder = new StringBuilder();
		for (String commitName : result.keySet()) {
			builder.append("\n").append(commitName).append(":").append(result.get(commitName));
		}

		return builder.toString();
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,Signature Change | Body Change,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,Body Change,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
parametersMetadataEqual,public static boolean parametersMetadataEqual(List<Yparameter> parametersA  List<Yparameter> parametersB) {
		Map<String  Yparameter> parameterMapA = new HashMap<>();
		for (Yparameter parameter : parametersA) {
			parameterMapA.put(parameter.getNameTypeString()  parameter);
		}

		for (Yparameter paramB : parametersB) {
			String paramString = paramB.getNameTypeString();
			Yparameter paramA = parameterMapA.get(paramString);
			if (paramA != null && !paramA.getMetadataString().equals(paramB.getMetadataString())) {
				return false;
			}
		}

		return true;
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,Signature Change | Body Change,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,Signature Change | Body Change,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,Signature Change | Body Change,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,Signature Change | Body Change,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,Signature Change | Body Change,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
functionsToIdMap,public static Map<String  Yfunction> functionsToIdMap(List<Yfunction> functions) {
		Map<String  Yfunction> ret = new HashMap<>();
		for (Yfunction function : functions) {
			ret.put(function.getId()  function);
		}
		return ret;
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,Signature Change | Body Change,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
parentNamesMatch,public static boolean parentNamesMatch(Yfunction function  Yfunction compareFunction) {
		String aParentName = function.getParentName();
		String bParentName = compareFunction.getParentName();
		if (aParentName != null && bParentName != null) {
			if (aParentName.equals(bParentName)) {
				return true;
			}
		}

		return false;
	},27,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,5ec0d46147930d22ed85a9dc314d36f8caa40249,Nick Bradley,Add support for specifying output dir 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,850faa2a77091658848fe419576022c4c0453c68,Nick Bradley,Fix output dir path construction 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,c646c886fca713c43c7c4ef34eeabccd7a1c10fa,Felix Grund,Extracted output dir to static field 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,9bf1e58a6931e80c4ce070e89aa62249360b7e90,Felix Grund,Output DIR static 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,9e8009beb16532b9412ca4f7d872ec3e94923d7e,Felix Grund,analysis script improvements 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,82bbc02613fe4d2cd69eed457cc71dca2ed8c794,Felix Grund,Merge branch 'stats-script' into develop 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,3a1ddd132ee5600ad88c7e28ed4bf52238df376a,Felix Grund,Stripping output filenames to max 150 chars 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
isFormatChange,/***
	 * Check for formatting changes
	 * <p>
	 *     If indentation  whitespace or any sort of formatting
	 *     was performed on a method the function will return true.
	 *     Otherwise it will return false.
	 * </p>
	 * @param function current matched function
	 * @param compareFunction previous function to compare with
	 * @return boolean True/False
	 */
	public static boolean isFormatChange(Yfunction function  Yfunction compareFunction) {
		// if lexically preserved method's body (unformatted body) are not equal
		// but pretty printed method's body (ignoring whitespace  indentation etc. ) are equal
		// then the change was of Yformatchange type
		if (function != null && compareFunction != null &&
				function.getBody().equals(compareFunction.getBody()) &&
				!function.getUnformattedBody().equals(compareFunction.getUnformattedBody())) {
			return true;
		}
		return false;
	},27,Signature Change | Body Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
gitDiffParent,public static String gitDiffParent(String commitName  String filePath  File repositoryDir) throws Exception {
		Runtime runtime = Runtime.getRuntime();
		String diffCommand = String.format("git diff --unified=50 %s~1:%s %s:%s"  commitName  filePath  commitName  filePath);
		String[] cmd = {
				"/bin/sh" 
				"-c" 
				diffCommand
		};

		Process process = runtime.exec(cmd  null  repositoryDir);
		process.waitFor();
		BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
		return IOUtils.toString(reader);
	},3,Body Change,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
gitDiffParent,public static String gitDiffParent(String commitName  String filePath  File repositoryDir) throws Exception {
		Runtime runtime = Runtime.getRuntime();
		String diffCommand = String.format("git diff --unified=50 %s~1:%s %s:%s"  commitName  filePath  commitName  filePath);
		String[] cmd = {
				"/bin/sh" 
				"-c" 
				diffCommand
		};

		Process process = runtime.exec(cmd  null  repositoryDir);
		process.waitFor();
		BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
		return IOUtils.toString(reader);
	},3,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
gitDiffParent,public static String gitDiffParent(String commitName  String filePath  File repositoryDir) throws Exception {
		Runtime runtime = Runtime.getRuntime();
		String diffCommand = String.format("git diff --unified=50 %s~1:%s %s:%s"  commitName  filePath  commitName  filePath);
		String[] cmd = {
				"/bin/sh" 
				"-c" 
				diffCommand
		};

		Process process = runtime.exec(cmd  null  repositoryDir);
		process.waitFor();
		BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
		return IOUtils.toString(reader);
	},3,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
gitLog,public static BufferedReader gitLog(String startCommitName  File repositoryDir 
			  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Runtime runtime = Runtime.getRuntime();
		String logCommand = String.format("git log %s --no-merges -L %s %s:%s" 
				startCommitName  rangeStart  rangeEnd  filePath);

		logCommand += " | grep 'commit\\s' | sed 's/commit//'";
		String[] cmd = {
				"/bin/sh" 
				"-c" 
				logCommand
		};

		System.out.println("\n==================================");
		System.out.println("LogCommand: " + logCommand);

		Process process = runtime.exec(cmd  null  repositoryDir);
		process.waitFor();
		return new BufferedReader(new InputStreamReader(process.getInputStream()));
	},3,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
gitLog,public static BufferedReader gitLog(String startCommitName  File repositoryDir 
			  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Runtime runtime = Runtime.getRuntime();
		String logCommand = String.format("git log %s --no-merges -L %s %s:%s" 
				startCommitName  rangeStart  rangeEnd  filePath);

		logCommand += " | grep 'commit\\s' | sed 's/commit//'";
		String[] cmd = {
				"/bin/sh" 
				"-c" 
				logCommand
		};

		System.out.println("\n==================================");
		System.out.println("LogCommand: " + logCommand);

		Process process = runtime.exec(cmd  null  repositoryDir);
		process.waitFor();
		return new BufferedReader(new InputStreamReader(process.getInputStream()));
	},3,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
gitLog,public static BufferedReader gitLog(String startCommitName  File repositoryDir 
			  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Runtime runtime = Runtime.getRuntime();
		String logCommand = String.format("git log %s --no-merges -L %s %s:%s" 
				startCommitName  rangeStart  rangeEnd  filePath);

		logCommand += " | grep 'commit\\s' | sed 's/commit//'";
		String[] cmd = {
				"/bin/sh" 
				"-c" 
				logCommand
		};

		System.out.println("\n==================================");
		System.out.println("LogCommand: " + logCommand);

		Process process = runtime.exec(cmd  null  repositoryDir);
		process.waitFor();
		return new BufferedReader(new InputStreamReader(process.getInputStream()));
	},3,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
Yexceptionschange,public Yexceptionschange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getOldValue,@Override
	protected Object getOldValue() {
		return oldFunction.getExceptions();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getNewValue,@Override
	protected Object getNewValue() {
		return newFunction.getExceptions();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Yparametermetachange,public Yparametermetachange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Ymodifierchange,public Ymodifierchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getOldValue,@Override
	protected Object getOldValue() {
		return oldFunction.getModifiers();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getNewValue,@Override
	protected Object getNewValue() {
		return newFunction.getModifiers();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Yparameterchange,public Yparameterchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getOldValue,@Override
	protected Object getOldValue() {
		return oldFunction.getParameters();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getNewValue,@Override
	protected Object getNewValue() {
		return newFunction.getParameters();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Ynochange,public Ynochange(StartEnvironment startEnv  Commit commit) {
		super(startEnv  commit);
	},3,Parameter Change | Signature Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
Ynochange,public Ynochange(StartEnvironment startEnv  Commit commit) {
		super(startEnv  commit);
	},3,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
Ynochange,public Ynochange(StartEnvironment startEnv  Commit commit) {
		super(startEnv  commit);
	},3,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
Yrename,public Yrename(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},2,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
Yrename,public Yrename(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},2,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getOldValue,@Override
	protected Object getOldValue() {
		return oldFunction.getName();
	},2,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getOldValue,@Override
	protected Object getOldValue() {
		return oldFunction.getName();
	},2,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getNewValue,@Override
	protected Object getNewValue() {
		return newFunction.getName();
	},2,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getNewValue,@Override
	protected Object getNewValue() {
		return newFunction.getName();
	},2,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Ymovefromfile,public Ymovefromfile(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},1,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getExtendedDetailsJsonObject,@Override
	public JsonObject getExtendedDetailsJsonObject() {
		JsonObject extendedObj = super.getExtendedDetailsJsonObject();
		String oldPath = oldFunction.getSourceFilePath();
		String newPath = newFunction.getSourceFilePath();
		String oldMethodName = oldFunction.getName();
		String newMethodName = newFunction.getName();
		extendedObj.addProperty("oldPath"  oldPath);
		extendedObj.addProperty("newPath"  newPath);
		extendedObj.addProperty("oldMethodName"  oldMethodName);
		extendedObj.addProperty("newMethodName"  newMethodName);
		return extendedObj;
	},1,Annotation Change | Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
Ychange,public Ychange(StartEnvironment startEnv  Commit commit) {
		this.commit = commit;
		this.repositoryService = startEnv.getRepositoryService();
	},7,Parameter Change | Signature Change | Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
Ychange,public Ychange(StartEnvironment startEnv  Commit commit) {
		this.commit = commit;
		this.repositoryService = startEnv.getRepositoryService();
	},7,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
Ychange,public Ychange(StartEnvironment startEnv  Commit commit) {
		this.commit = commit;
		this.repositoryService = startEnv.getRepositoryService();
	},7,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
Ychange,public Ychange(StartEnvironment startEnv  Commit commit) {
		this.commit = commit;
		this.repositoryService = startEnv.getRepositoryService();
	},7,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
Ychange,public Ychange(StartEnvironment startEnv  Commit commit) {
		this.commit = commit;
		this.repositoryService = startEnv.getRepositoryService();
	},7,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
Ychange,public Ychange(StartEnvironment startEnv  Commit commit) {
		this.commit = commit;
		this.repositoryService = startEnv.getRepositoryService();
	},7,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
Ychange,public Ychange(StartEnvironment startEnv  Commit commit) {
		this.commit = commit;
		this.repositoryService = startEnv.getRepositoryService();
	},7,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getCommit,public Commit getCommit() {
		return commit;
	},7,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommit,public Commit getCommit() {
		return commit;
	},7,Signature Change | Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommit,public Commit getCommit() {
		return commit;
	},7,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommit,public Commit getCommit() {
		return commit;
	},7,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCommit,public Commit getCommit() {
		return commit;
	},7,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommit,public Commit getCommit() {
		return commit;
	},7,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getCommit,public Commit getCommit() {
		return commit;
	},7,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
toString,@Override
	public String toString() {
		return this.getClass().getSimpleName();
	},7,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toString,@Override
	public String toString() {
		return this.getClass().getSimpleName();
	},7,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toString,@Override
	public String toString() {
		return this.getClass().getSimpleName();
	},7,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toString,@Override
	public String toString() {
		return this.getClass().getSimpleName();
	},7,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
toString,@Override
	public String toString() {
		return this.getClass().getSimpleName();
	},7,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
toString,@Override
	public String toString() {
		return this.getClass().getSimpleName();
	},7,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
toString,@Override
	public String toString() {
		return this.getClass().getSimpleName();
	},7,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
toJsonObject,public JsonObject toJsonObject() {
		JsonObject obj = new JsonObject();
		obj.addProperty("type"  getTypeAsString());
		obj.addProperty("commitMessage"  commit.getCommitMessage());
		obj.addProperty("commitDate"  DATE_FORMATTER.format(commit.getCommitDate()));
		obj.addProperty("commitName"  commit.getName());
		obj.addProperty("commitAuthor"  commit.getAuthorName());
		return obj;
	},7,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toJsonObject,public JsonObject toJsonObject() {
		JsonObject obj = new JsonObject();
		obj.addProperty("type"  getTypeAsString());
		obj.addProperty("commitMessage"  commit.getCommitMessage());
		obj.addProperty("commitDate"  DATE_FORMATTER.format(commit.getCommitDate()));
		obj.addProperty("commitName"  commit.getName());
		obj.addProperty("commitAuthor"  commit.getAuthorName());
		return obj;
	},7,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toJsonObject,public JsonObject toJsonObject() {
		JsonObject obj = new JsonObject();
		obj.addProperty("type"  getTypeAsString());
		obj.addProperty("commitMessage"  commit.getCommitMessage());
		obj.addProperty("commitDate"  DATE_FORMATTER.format(commit.getCommitDate()));
		obj.addProperty("commitName"  commit.getName());
		obj.addProperty("commitAuthor"  commit.getAuthorName());
		return obj;
	},7,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toJsonObject,public JsonObject toJsonObject() {
		JsonObject obj = new JsonObject();
		obj.addProperty("type"  getTypeAsString());
		obj.addProperty("commitMessage"  commit.getCommitMessage());
		obj.addProperty("commitDate"  DATE_FORMATTER.format(commit.getCommitDate()));
		obj.addProperty("commitName"  commit.getName());
		obj.addProperty("commitAuthor"  commit.getAuthorName());
		return obj;
	},7,Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
toJsonObject,public JsonObject toJsonObject() {
		JsonObject obj = new JsonObject();
		obj.addProperty("type"  getTypeAsString());
		obj.addProperty("commitMessage"  commit.getCommitMessage());
		obj.addProperty("commitDate"  DATE_FORMATTER.format(commit.getCommitDate()));
		obj.addProperty("commitName"  commit.getName());
		obj.addProperty("commitAuthor"  commit.getAuthorName());
		return obj;
	},7,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
toJsonObject,public JsonObject toJsonObject() {
		JsonObject obj = new JsonObject();
		obj.addProperty("type"  getTypeAsString());
		obj.addProperty("commitMessage"  commit.getCommitMessage());
		obj.addProperty("commitDate"  DATE_FORMATTER.format(commit.getCommitDate()));
		obj.addProperty("commitName"  commit.getName());
		obj.addProperty("commitAuthor"  commit.getAuthorName());
		return obj;
	},7,Minor Modification,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
toJsonObject,public JsonObject toJsonObject() {
		JsonObject obj = new JsonObject();
		obj.addProperty("type"  getTypeAsString());
		obj.addProperty("commitMessage"  commit.getCommitMessage());
		obj.addProperty("commitDate"  DATE_FORMATTER.format(commit.getCommitDate()));
		obj.addProperty("commitName"  commit.getName());
		obj.addProperty("commitAuthor"  commit.getAuthorName());
		return obj;
	},7,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getTypeAsString,public String getTypeAsString() {
		return getClass().getSimpleName();
	},7,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getTypeAsString,public String getTypeAsString() {
		return getClass().getSimpleName();
	},7,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getTypeAsString,public String getTypeAsString() {
		return getClass().getSimpleName();
	},7,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getTypeAsString,public String getTypeAsString() {
		return getClass().getSimpleName();
	},7,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getTypeAsString,public String getTypeAsString() {
		return getClass().getSimpleName();
	},7,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getTypeAsString,public String getTypeAsString() {
		return getClass().getSimpleName();
	},7,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getTypeAsString,public String getTypeAsString() {
		return getClass().getSimpleName();
	},7,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getDiffAsString,protected String getDiffAsString(String sourceOldString  String sourceNewString) throws IOException {
		RawText sourceOld = new RawText(sourceOldString.getBytes());
		RawText sourceNew = new RawText(sourceNewString.getBytes());
		DiffAlgorithm diffAlgorithm = new HistogramDiff();
		RawTextComparator textComparator = RawTextComparator.DEFAULT;
		EditList editList = diffAlgorithm.diff(textComparator  sourceOld  sourceNew);
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		DiffFormatter formatter = new DiffFormatter(out);
		formatter.setContext(1000);
		formatter.format(editList  sourceOld  sourceNew);
		return out.toString(StandardCharsets.UTF_8.name());

	},7,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getDiffAsString,protected String getDiffAsString(String sourceOldString  String sourceNewString) throws IOException {
		RawText sourceOld = new RawText(sourceOldString.getBytes());
		RawText sourceNew = new RawText(sourceNewString.getBytes());
		DiffAlgorithm diffAlgorithm = new HistogramDiff();
		RawTextComparator textComparator = RawTextComparator.DEFAULT;
		EditList editList = diffAlgorithm.diff(textComparator  sourceOld  sourceNew);
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		DiffFormatter formatter = new DiffFormatter(out);
		formatter.setContext(1000);
		formatter.format(editList  sourceOld  sourceNew);
		return out.toString(StandardCharsets.UTF_8.name());

	},7,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getDiffAsString,protected String getDiffAsString(String sourceOldString  String sourceNewString) throws IOException {
		RawText sourceOld = new RawText(sourceOldString.getBytes());
		RawText sourceNew = new RawText(sourceNewString.getBytes());
		DiffAlgorithm diffAlgorithm = new HistogramDiff();
		RawTextComparator textComparator = RawTextComparator.DEFAULT;
		EditList editList = diffAlgorithm.diff(textComparator  sourceOld  sourceNew);
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		DiffFormatter formatter = new DiffFormatter(out);
		formatter.setContext(1000);
		formatter.format(editList  sourceOld  sourceNew);
		return out.toString(StandardCharsets.UTF_8.name());

	},7,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getDiffAsString,protected String getDiffAsString(String sourceOldString  String sourceNewString) throws IOException {
		RawText sourceOld = new RawText(sourceOldString.getBytes());
		RawText sourceNew = new RawText(sourceNewString.getBytes());
		DiffAlgorithm diffAlgorithm = new HistogramDiff();
		RawTextComparator textComparator = RawTextComparator.DEFAULT;
		EditList editList = diffAlgorithm.diff(textComparator  sourceOld  sourceNew);
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		DiffFormatter formatter = new DiffFormatter(out);
		formatter.setContext(1000);
		formatter.format(editList  sourceOld  sourceNew);
		return out.toString(StandardCharsets.UTF_8.name());

	},7,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getDiffAsString,protected String getDiffAsString(String sourceOldString  String sourceNewString) throws IOException {
		RawText sourceOld = new RawText(sourceOldString.getBytes());
		RawText sourceNew = new RawText(sourceNewString.getBytes());
		DiffAlgorithm diffAlgorithm = new HistogramDiff();
		RawTextComparator textComparator = RawTextComparator.DEFAULT;
		EditList editList = diffAlgorithm.diff(textComparator  sourceOld  sourceNew);
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		DiffFormatter formatter = new DiffFormatter(out);
		formatter.setContext(1000);
		formatter.format(editList  sourceOld  sourceNew);
		return out.toString(StandardCharsets.UTF_8.name());

	},7,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getDiffAsString,protected String getDiffAsString(String sourceOldString  String sourceNewString) throws IOException {
		RawText sourceOld = new RawText(sourceOldString.getBytes());
		RawText sourceNew = new RawText(sourceNewString.getBytes());
		DiffAlgorithm diffAlgorithm = new HistogramDiff();
		RawTextComparator textComparator = RawTextComparator.DEFAULT;
		EditList editList = diffAlgorithm.diff(textComparator  sourceOld  sourceNew);
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		DiffFormatter formatter = new DiffFormatter(out);
		formatter.setContext(1000);
		formatter.format(editList  sourceOld  sourceNew);
		return out.toString(StandardCharsets.UTF_8.name());

	},7,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getDiffAsString,protected String getDiffAsString(String sourceOldString  String sourceNewString) throws IOException {
		RawText sourceOld = new RawText(sourceOldString.getBytes());
		RawText sourceNew = new RawText(sourceNewString.getBytes());
		DiffAlgorithm diffAlgorithm = new HistogramDiff();
		RawTextComparator textComparator = RawTextComparator.DEFAULT;
		EditList editList = diffAlgorithm.diff(textComparator  sourceOld  sourceNew);
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		DiffFormatter formatter = new DiffFormatter(out);
		formatter.setContext(1000);
		formatter.format(editList  sourceOld  sourceNew);
		return out.toString(StandardCharsets.UTF_8.name());

	},7,Signature Change | Body Change,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
Yintroduced,public Yintroduced(StartEnvironment startEnv  Yfunction newFunction) {
		super(startEnv  newFunction.getCommit());
		this.newFunction = newFunction;
	},6,Minor Modification,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
Yintroduced,public Yintroduced(StartEnvironment startEnv  Yfunction newFunction) {
		super(startEnv  newFunction.getCommit());
		this.newFunction = newFunction;
	},6,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
Yintroduced,public Yintroduced(StartEnvironment startEnv  Yfunction newFunction) {
		super(startEnv  newFunction.getCommit());
		this.newFunction = newFunction;
	},6,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
Yintroduced,public Yintroduced(StartEnvironment startEnv  Yfunction newFunction) {
		super(startEnv  newFunction.getCommit());
		this.newFunction = newFunction;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
Yintroduced,public Yintroduced(StartEnvironment startEnv  Yfunction newFunction) {
		super(startEnv  newFunction.getCommit());
		this.newFunction = newFunction;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
Yintroduced,public Yintroduced(StartEnvironment startEnv  Yfunction newFunction) {
		super(startEnv  newFunction.getCommit());
		this.newFunction = newFunction;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
toString,@Override
	public String toString() {
		String template = "%s(%s:%s:%s)";
		return String.format(template 
				getClass().getSimpleName() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber()
		);
	},6,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toString,@Override
	public String toString() {
		String template = "%s(%s:%s:%s)";
		return String.format(template 
				getClass().getSimpleName() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber()
		);
	},6,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
toString,@Override
	public String toString() {
		String template = "%s(%s:%s:%s)";
		return String.format(template 
				getClass().getSimpleName() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber()
		);
	},6,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
toString,@Override
	public String toString() {
		String template = "%s(%s:%s:%s)";
		return String.format(template 
				getClass().getSimpleName() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber()
		);
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
toString,@Override
	public String toString() {
		String template = "%s(%s:%s:%s)";
		return String.format(template 
				getClass().getSimpleName() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber()
		);
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
toString,@Override
	public String toString() {
		String template = "%s(%s:%s:%s)";
		return String.format(template 
				getClass().getSimpleName() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber()
		);
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("diff"  getDiffAsString());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		return obj;
	},6,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("diff"  getDiffAsString());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		return obj;
	},6,Annotation Change | Signature Change | Body Change,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("diff"  getDiffAsString());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		return obj;
	},6,Body Change,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("diff"  getDiffAsString());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		return obj;
	},6,Minor Modification,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("diff"  getDiffAsString());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		return obj;
	},6,Minor Modification,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("diff"  getDiffAsString());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		return obj;
	},6,Minor Modification,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			try {
				this.diffString = this.getDiffAsString(""  newFunction.getSourceFragment());
			} catch (IOException e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}

		}
		return diffString;
	},6,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			try {
				this.diffString = this.getDiffAsString(""  newFunction.getSourceFragment());
			} catch (IOException e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}

		}
		return diffString;
	},6,Signature Change | Body Change,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			try {
				this.diffString = this.getDiffAsString(""  newFunction.getSourceFragment());
			} catch (IOException e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}

		}
		return diffString;
	},6,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			try {
				this.diffString = this.getDiffAsString(""  newFunction.getSourceFragment());
			} catch (IOException e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}

		}
		return diffString;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			try {
				this.diffString = this.getDiffAsString(""  newFunction.getSourceFragment());
			} catch (IOException e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}

		}
		return diffString;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			try {
				this.diffString = this.getDiffAsString(""  newFunction.getSourceFragment());
			} catch (IOException e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}

		}
		return diffString;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
Ysignaturechange,public Ysignaturechange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getOldValue,protected abstract Object getOldValue();,1,Signature Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getNewValue,protected abstract Object getNewValue();,1,Signature Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getExtendedDetailsJsonObject,@Override
	public JsonObject getExtendedDetailsJsonObject() {
		JsonObject extendedObj = new JsonObject();
		String oldValue = "";
		String newValue = "";
		if (getOldValue() != null) {
			oldValue = getOldValue().toString();
		}
		if (getNewValue() != null) {
			newValue = getNewValue().toString();
		}
		extendedObj.addProperty("oldValue"  oldValue);
		extendedObj.addProperty("newValue"  newValue);
		return extendedObj;
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Ymultichange,public Ymultichange(StartEnvironment startEnv  Commit commit  List<Ychange> changes) {
		super(startEnv  commit);
		this.changes = changes;
	},5,Parameter Change | Signature Change | Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
Ymultichange,public Ymultichange(StartEnvironment startEnv  Commit commit  List<Ychange> changes) {
		super(startEnv  commit);
		this.changes = changes;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
Ymultichange,public Ymultichange(StartEnvironment startEnv  Commit commit  List<Ychange> changes) {
		super(startEnv  commit);
		this.changes = changes;
	},5,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
Ymultichange,public Ymultichange(StartEnvironment startEnv  Commit commit  List<Ychange> changes) {
		super(startEnv  commit);
		this.changes = changes;
	},5,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
Ymultichange,public Ymultichange(StartEnvironment startEnv  Commit commit  List<Ychange> changes) {
		super(startEnv  commit);
		this.changes = changes;
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getChanges,public List<Ychange> getChanges() {
		return changes;
	},5,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getChanges,public List<Ychange> getChanges() {
		return changes;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getChanges,public List<Ychange> getChanges() {
		return changes;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getChanges,public List<Ychange> getChanges() {
		return changes;
	},5,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getChanges,public List<Ychange> getChanges() {
		return changes;
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
toString,@Override
	public String toString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.toString());
		}
		return "Ymultichange(\n- "+StringUtils.join(substrings  "\n- ")+"\n)";
	},5,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toString,@Override
	public String toString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.toString());
		}
		return "Ymultichange(\n- "+StringUtils.join(substrings  "\n- ")+"\n)";
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toString,@Override
	public String toString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.toString());
		}
		return "Ymultichange(\n- "+StringUtils.join(substrings  "\n- ")+"\n)";
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toString,@Override
	public String toString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.toString());
		}
		return "Ymultichange(\n- "+StringUtils.join(substrings  "\n- ")+"\n)";
	},5,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
toString,@Override
	public String toString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.toString());
		}
		return "Ymultichange(\n- "+StringUtils.join(substrings  "\n- ")+"\n)";
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		JsonArray subchanges = new JsonArray();
		for (Ychange change : this.changes) {
			subchanges.add(change.toJsonObject());
		}

		obj.add("subchanges"  subchanges);
		return obj;
	},5,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		JsonArray subchanges = new JsonArray();
		for (Ychange change : this.changes) {
			subchanges.add(change.toJsonObject());
		}

		obj.add("subchanges"  subchanges);
		return obj;
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		JsonArray subchanges = new JsonArray();
		for (Ychange change : this.changes) {
			subchanges.add(change.toJsonObject());
		}

		obj.add("subchanges"  subchanges);
		return obj;
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		JsonArray subchanges = new JsonArray();
		for (Ychange change : this.changes) {
			subchanges.add(change.toJsonObject());
		}

		obj.add("subchanges"  subchanges);
		return obj;
	},5,Annotation Change | Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		JsonArray subchanges = new JsonArray();
		for (Ychange change : this.changes) {
			subchanges.add(change.toJsonObject());
		}

		obj.add("subchanges"  subchanges);
		return obj;
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getTypeAsString,@Override
	public String getTypeAsString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.getTypeAsString());
		}
		return "Ymultichange(" +StringUtils.join(substrings  " ") + ")";
	},5,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getTypeAsString,@Override
	public String getTypeAsString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.getTypeAsString());
		}
		return "Ymultichange(" +StringUtils.join(substrings  " ") + ")";
	},5,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getTypeAsString,@Override
	public String getTypeAsString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.getTypeAsString());
		}
		return "Ymultichange(" +StringUtils.join(substrings  " ") + ")";
	},5,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getTypeAsString,@Override
	public String getTypeAsString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.getTypeAsString());
		}
		return "Ymultichange(" +StringUtils.join(substrings  " ") + ")";
	},5,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getTypeAsString,@Override
	public String getTypeAsString() {
		List<String> substrings = new ArrayList<>();
		for (Ychange change : changes) {
			substrings.add(change.getTypeAsString());
		}
		return "Ymultichange(" +StringUtils.join(substrings  " ") + ")";
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
Yfilerename,public Yfilerename(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},1,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getExtendedDetailsJsonObject,@Override
	public JsonObject getExtendedDetailsJsonObject() {
		JsonObject extendedObj = new JsonObject();
		String oldPath = oldFunction.getSourceFilePath();
		String newPath = newFunction.getSourceFilePath();
		extendedObj.addProperty("oldPath"  oldPath);
		extendedObj.addProperty("newPath"  newPath);
		return extendedObj;
	},1,Annotation Change | Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
Ycomparefunctionchange,public Ycomparefunctionchange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction.getCommit());
		this.oldCommit = oldFunction.getCommit();
		this.newFunction = newFunction;
		this.oldFunction = oldFunction;
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
toString,@Override
	public String toString() {
		String baseTemplate = "%s(%s:%s:%s:%s => %s:%s:%s:%s)";
		String baseString = String.format(baseTemplate 
				getClass().getSimpleName() 
				oldFunction.getCommitNameShort() 
				oldFunction.getName() 
				oldFunction.getNameLineNumber() 
				oldFunction.getSourceFilePath() 
				newFunction.getCommitNameShort() 
				newFunction.getName() 
				newFunction.getNameLineNumber() 
				newFunction.getSourceFilePath()
		);

		if (INCLUDE_META_DATA) {
			String metadataTemplate = "TimeBetweenCommits(%s) - NumCommitsBetween(ForRepo:%s ForFile:%s)";
			String metadataString = String.format(metadataTemplate 
					getDaysBetweenCommits() 
					getCommitsBetweenForRepo().size() 
					getCommitsBetweenForFile().size());
			baseString += "|" + metadataString;
		}

		return baseString;

	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,Annotation Change | Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,Body Change,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,Body Change,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,Body Change,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,Body Change,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,Minor Modification,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,Minor Modification,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
toJsonObject,@Override
	public JsonObject toJsonObject() {
		JsonObject obj = super.toJsonObject();
		obj.addProperty("commitDateOld"  Ychange.DATE_FORMATTER.format(oldCommit.getCommitDate()));
		obj.addProperty("commitNameOld"  oldCommit.getName());
		obj.addProperty("commitAuthorOld"  oldCommit.getAuthorName());
		obj.addProperty("daysBetweenCommits"  getDaysBetweenCommits());
		obj.addProperty("commitsBetweenForRepo"  getCommitsBetweenForRepo().size());
		obj.addProperty("commitsBetweenForFile"  getCommitsBetweenForFile().size());
		obj.addProperty("actualSource"  newFunction.getSourceFragment());
		obj.addProperty("path"  newFunction.getSourceFilePath());
		obj.addProperty("functionStartLine"  newFunction.getNameLineNumber());
		obj.addProperty("functionName"  newFunction.getName());
		obj.addProperty("functionAnnotation"  newFunction.getAnnotation());
		obj.addProperty("functionDoc"  newFunction.getFunctionDoc());
		obj.addProperty("diff"  getDiffAsString());
		obj.add("extendedDetails"  getExtendedDetailsJsonObject());
		return obj;
	},12,Minor Modification,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getExtendedDetailsJsonObject,public JsonObject getExtendedDetailsJsonObject() {
		return new JsonObject();
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getNewFunction,public Yfunction getNewFunction() {
		return newFunction;
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getOldFunction,public Yfunction getOldFunction() {
		return oldFunction;
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getDaysBetweenCommits,public double getDaysBetweenCommits() {
		if (this.daysBetweenCommits == null) {
			this.daysBetweenCommits = Utl.getDaysBetweenCommits(oldFunction.getCommit()  newFunction.getCommit());
		}
		return daysBetweenCommits;
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getCommitsBetweenForRepo,public List<Commit> getCommitsBetweenForRepo() {
		if (this.commitsBetweenForRepo == null) {
			this.commitsBetweenForRepo = new ArrayList<>();
			try {
				this.commitsBetweenForRepo = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						null);
			} catch (Exception e) {
				log.warn("Failed to generate diff string: " + e.getMessage());
			}
		}
		return commitsBetweenForRepo;
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,Body Change,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getCommitsBetweenForFile,public List<Commit> getCommitsBetweenForFile() {
		if (this.commitsBetweenForFile == null) {
			this.commitsBetweenForFile = new ArrayList<>();
			try {
				this.commitsBetweenForFile = repositoryService.getCommitsBetween(
						this.oldFunction.getCommit() 
						this.newFunction.getCommit() 
						this.newFunction.getSourceFilePath());
			} catch (Exception e) {
				// Note: this is a relatively common error and seems to be handled correctly by callers
				System.err.println("Ycomparefunctionchange::getCommitsBetweenForFile() - failed to get commits between files");
				if (this.oldFunction != null){
					System.out.println("oldFunc commit: "+this.oldFunction.getCommit().getCommitNameShort());
					System.out.println("oldFunc name: "+this.oldFunction.getName()+"; path: "+this.oldFunction.getSourceFilePath());
				} else {
					System.out.println("oldFunc: null");
				}

				if (this.newFunction!= null){
					System.out.println("newFunc commit: "+this.newFunction.getCommit().getCommitNameShort());
					System.out.println("newFunc name: "+this.newFunction.getName()+"; path: "+this.newFunction.getSourceFilePath());
				} else {
					System.out.println("newFunc: null");
				}

				// e.printStackTrace();
			}
		}
		return commitsBetweenForFile;
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,Signature Change | Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,Modifier Change | Signature Change | Body Change,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getDiffAsString,private String getDiffAsString() {
		if (this.diffString == null) {
			String sourceOldString = oldFunction.getSourceFragment();
			String sourceNewString = newFunction.getSourceFragment();
			try {
				this.diffString = this.getDiffAsString(sourceOldString  sourceNewString);
			} catch (IOException e) {
				e.printStackTrace();
			}

		}
		return diffString;
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,Signature Change | Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,870bd9e6894c6f03cd6bce969226ee9a0c21de8f,Syed Ishtiaque Ahmad,Add extra attributes in the JSON result object - Add filepath of the method - Add start line of the method - Add name of the method - Add actual source code in JSON result 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,d5e74858b7ae845f83d962d3676c1e68a15672eb,Syed Ishtiaque Ahmad,Merge pull request #1 from ataraxie/reid_icse2021  Reid icse2021
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getOldCommit,public Commit getOldCommit() {
		return oldCommit;
	},12,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
Yreturntypechange,public Yreturntypechange(StartEnvironment startEnv  Yfunction newFunction  Yfunction oldFunction) {
		super(startEnv  newFunction  oldFunction);
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getOldValue,@Override
	protected Object getOldValue() {
		return oldFunction.getReturnStmt();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getNewValue,@Override
	protected Object getNewValue() {
		return newFunction.getReturnStmt();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getBody,/**
	 * @return Method body as string
	 */
	String getBody();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getName,/**
	 * @return Method name as string
	 */
	String getName();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParameters,/**
	 * @return List of parameters
	 */
	List<Yparameter> getParameters();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,Signature Change | Body Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getReturnStmt,/**
	 * @return Statement/type of the method. Should be {@code Yreturn.NONE} for untyped languages.
	 */
	Yreturn getReturnStmt();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,Signature Change | Body Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getModifiers,/**
	 * @return Method modifiers. Should be {@code Ymodifiers.NONE} for languages that don't have method modifiers.
	 */
	Ymodifiers getModifiers();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,Signature Change | Body Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getExceptions,/**
	 * @return Thrown exception types. Should be {@code Yexceptions.NONE} for untyped languages.
	 */
	Yexceptions getExceptions();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getNameLineNumber,/**
	 * @return Line number in which the method name appears.
	 */
	int getNameLineNumber();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getEndLineNumber,/**
	 * @return Line number in which the method ends (e.g. with `}`)
	 */
	int getEndLineNumber();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCommitName,/**
	 * @return Full commit SHA of the commit that has this method
	 */
	String getCommitName();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCommitNameShort,/**
	 * @return Short 6-digit commit SHA of the commit that has this method
	 */
	String getCommitNameShort();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCommit,/**
	 * @return Commit object that has this method
	 */
	Commit getCommit();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getId,/**
	 * @return Unique identifier for the method within the file
	 */
	String getId();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,Signature Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionPath,/**
	 * Some AST parsers use paths for methods  especially for parent/child scope relationships. If the parser/language
	 * doesn't support this  return null.
	 *
	 * @return Path to the method in the file
	 */
	String getFunctionPath();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getSourceFileContent,/**
	 * @return Content of the source file as string where this method is in
	 */
	String getSourceFileContent();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getSourceFilePath,/**
	 * @return File path to the source file relative to the repository root directory
	 */
	String getSourceFilePath();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,Signature Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getSourceFragment,/**
	 * @return The source code fragment for this method as string
	 */
	String getSourceFragment();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,Signature Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParentName,/**
	 * @return If this method has some kind of parent (e.g. class  module)  return its name. Otherwise return null.
	 */
	String getParentName();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,Signature Change,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAnnotation,/**
	 * @return If this method has some kind of annotation (e.g. @Test  @Override)  return it. Otherwise return null
	 */
	String getAnnotation();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,Signature Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionDoc,/**
	 * @return java documentation of a method if present
	 * */
	String getFunctionDoc();,10,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getUnformattedBody,/***
	 * @return the unformatted method's body preserving whitespace  indentation and other formatting
	 */
	String getUnformattedBody();,10,Signature Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
TypeScriptFunction,TypeScriptFunction(V8Object function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
TypeScriptFunction,TypeScriptFunction(V8Object function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
TypeScriptFunction,TypeScriptFunction(V8Object function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
TypeScriptFunction,TypeScriptFunction(V8Object function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParameter,private Yparameter getParameter(V8Object param) {
        String stype;
        V8Object v8type = param.getObject("type");
        if (v8type.isUndefined()) {
            stype = "";
        } else {
            stype = v8type.executeStringFunction("getText"  new V8Array(v8type.getRuntime()));
        }
        return new Yparameter(param.getObject("name").getString("escapedText").trim()  stype);
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getParameter,private Yparameter getParameter(V8Object param) {
        String stype;
        V8Object v8type = param.getObject("type");
        if (v8type.isUndefined()) {
            stype = "";
        } else {
            stype = v8type.executeStringFunction("getText"  new V8Array(v8type.getRuntime()));
        }
        return new Yparameter(param.getObject("name").getString("escapedText").trim()  stype);
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getParameter,private Yparameter getParameter(V8Object param) {
        String stype;
        V8Object v8type = param.getObject("type");
        if (v8type.isUndefined()) {
            stype = "";
        } else {
            stype = v8type.executeStringFunction("getText"  new V8Array(v8type.getRuntime()));
        }
        return new Yparameter(param.getObject("name").getString("escapedText").trim()  stype);
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParameter,private Yparameter getParameter(V8Object param) {
        String stype;
        V8Object v8type = param.getObject("type");
        if (v8type.isUndefined()) {
            stype = "";
        } else {
            stype = v8type.executeStringFunction("getText"  new V8Array(v8type.getRuntime()));
        }
        return new Yparameter(param.getObject("name").getString("escapedText").trim()  stype);
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getModifier,private String getModifier(V8Object modifier) {
        return modifier.executeStringFunction("getText"  new V8Array(modifier.getRuntime()));
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getModifier,private String getModifier(V8Object modifier) {
        return modifier.executeStringFunction("getText"  new V8Array(modifier.getRuntime()));
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getModifier,private String getModifier(V8Object modifier) {
        return modifier.executeStringFunction("getText"  new V8Array(modifier.getRuntime()));
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getModifier,private String getModifier(V8Object modifier) {
        return modifier.executeStringFunction("getText"  new V8Array(modifier.getRuntime()));
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialName,@Override
    protected String getInitialName(V8Object function) {
        /**
         * TODO this magic number of 162 is _extremely_ brittle
         * this line should read `if (new TypeScriptVisitor().isKind(function  "Constructor")) {`
         * however it causes extreme performance degradation
         */
        if (function.getInteger("kind") == 162) {
            return "constructor";
        } else {
            return function.getObject("name").getString("escapedText");
        }
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialName,@Override
    protected String getInitialName(V8Object function) {
        /**
         * TODO this magic number of 162 is _extremely_ brittle
         * this line should read `if (new TypeScriptVisitor().isKind(function  "Constructor")) {`
         * however it causes extreme performance degradation
         */
        if (function.getInteger("kind") == 162) {
            return "constructor";
        } else {
            return function.getObject("name").getString("escapedText");
        }
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialName,@Override
    protected String getInitialName(V8Object function) {
        /**
         * TODO this magic number of 162 is _extremely_ brittle
         * this line should read `if (new TypeScriptVisitor().isKind(function  "Constructor")) {`
         * however it causes extreme performance degradation
         */
        if (function.getInteger("kind") == 162) {
            return "constructor";
        } else {
            return function.getObject("name").getString("escapedText");
        }
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialName,@Override
    protected String getInitialName(V8Object function) {
        /**
         * TODO this magic number of 162 is _extremely_ brittle
         * this line should read `if (new TypeScriptVisitor().isKind(function  "Constructor")) {`
         * however it causes extreme performance degradation
         */
        if (function.getInteger("kind") == 162) {
            return "constructor";
        } else {
            return function.getObject("name").getString("escapedText");
        }
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialType,@Override
    protected String getInitialType(V8Object function) {
        String stype;
        V8Object v8type = function.getObject("type");
        if (v8type.isUndefined()) {
            stype = null;
        } else {
            stype = v8type.executeStringFunction("getText"  new V8Array(v8type.getRuntime()));
        }
        return stype;
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialType,@Override
    protected String getInitialType(V8Object function) {
        String stype;
        V8Object v8type = function.getObject("type");
        if (v8type.isUndefined()) {
            stype = null;
        } else {
            stype = v8type.executeStringFunction("getText"  new V8Array(v8type.getRuntime()));
        }
        return stype;
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialType,@Override
    protected String getInitialType(V8Object function) {
        String stype;
        V8Object v8type = function.getObject("type");
        if (v8type.isUndefined()) {
            stype = null;
        } else {
            stype = v8type.executeStringFunction("getText"  new V8Array(v8type.getRuntime()));
        }
        return stype;
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialType,@Override
    protected String getInitialType(V8Object function) {
        String stype;
        V8Object v8type = function.getObject("type");
        if (v8type.isUndefined()) {
            stype = null;
        } else {
            stype = v8type.executeStringFunction("getText"  new V8Array(v8type.getRuntime()));
        }
        return stype;
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(V8Object function) {
        List<String> ymodifiers = new ArrayList<>();
        V8Object maybeModifiers = function.getObject("modifiers");
        if (!maybeModifiers.isUndefined()) {
            V8Array modifiers = (V8Array) maybeModifiers;
            int length = modifiers.length();
            for (int i = 0; i < length; ++i) {
                V8Object mod = modifiers.getObject(i);
                ymodifiers.add(getModifier(mod));
            }
        }
        return new Ymodifiers(ymodifiers);
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(V8Object function) {
        List<String> ymodifiers = new ArrayList<>();
        V8Object maybeModifiers = function.getObject("modifiers");
        if (!maybeModifiers.isUndefined()) {
            V8Array modifiers = (V8Array) maybeModifiers;
            int length = modifiers.length();
            for (int i = 0; i < length; ++i) {
                V8Object mod = modifiers.getObject(i);
                ymodifiers.add(getModifier(mod));
            }
        }
        return new Ymodifiers(ymodifiers);
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(V8Object function) {
        List<String> ymodifiers = new ArrayList<>();
        V8Object maybeModifiers = function.getObject("modifiers");
        if (!maybeModifiers.isUndefined()) {
            V8Array modifiers = (V8Array) maybeModifiers;
            int length = modifiers.length();
            for (int i = 0; i < length; ++i) {
                V8Object mod = modifiers.getObject(i);
                ymodifiers.add(getModifier(mod));
            }
        }
        return new Ymodifiers(ymodifiers);
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(V8Object function) {
        List<String> ymodifiers = new ArrayList<>();
        V8Object maybeModifiers = function.getObject("modifiers");
        if (!maybeModifiers.isUndefined()) {
            V8Array modifiers = (V8Array) maybeModifiers;
            int length = modifiers.length();
            for (int i = 0; i < length; ++i) {
                V8Object mod = modifiers.getObject(i);
                ymodifiers.add(getModifier(mod));
            }
        }
        return new Ymodifiers(ymodifiers);
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(V8Object function) {
        return Yexceptions.NONE;
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(V8Object function) {
        return Yexceptions.NONE;
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(V8Object function) {
        return Yexceptions.NONE;
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(V8Object function) {
        return Yexceptions.NONE;
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(V8Object function) {
        List<Yparameter> yparameters = new ArrayList<>();
        V8Array params = function.getArray("parameters");
        int length = params.length();
        for (int i = 0; i < length; ++i) {
            V8Object param = params.getObject(i);
            yparameters.add(getParameter(param));
        }
        return yparameters;
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(V8Object function) {
        List<Yparameter> yparameters = new ArrayList<>();
        V8Array params = function.getArray("parameters");
        int length = params.length();
        for (int i = 0; i < length; ++i) {
            V8Object param = params.getObject(i);
            yparameters.add(getParameter(param));
        }
        return yparameters;
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(V8Object function) {
        List<Yparameter> yparameters = new ArrayList<>();
        V8Array params = function.getArray("parameters");
        int length = params.length();
        for (int i = 0; i < length; ++i) {
            V8Object param = params.getObject(i);
            yparameters.add(getParameter(param));
        }
        return yparameters;
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(V8Object function) {
        List<Yparameter> yparameters = new ArrayList<>();
        V8Array params = function.getArray("parameters");
        int length = params.length();
        for (int i = 0; i < length; ++i) {
            V8Object param = params.getObject(i);
            yparameters.add(getParameter(param));
        }
        return yparameters;
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialBody,@Override
    protected String getInitialBody(V8Object function) {
        String sbody;
        V8Object v8body = function.getObject("body");
        if (v8body.isUndefined()) {
            sbody = null;
        } else {
            sbody = v8body.executeStringFunction("getText"  new V8Array(v8body.getRuntime()));
        }
        return sbody;
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialBody,@Override
    protected String getInitialBody(V8Object function) {
        String sbody;
        V8Object v8body = function.getObject("body");
        if (v8body.isUndefined()) {
            sbody = null;
        } else {
            sbody = v8body.executeStringFunction("getText"  new V8Array(v8body.getRuntime()));
        }
        return sbody;
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialBody,@Override
    protected String getInitialBody(V8Object function) {
        String sbody;
        V8Object v8body = function.getObject("body");
        if (v8body.isUndefined()) {
            sbody = null;
        } else {
            sbody = v8body.executeStringFunction("getText"  new V8Array(v8body.getRuntime()));
        }
        return sbody;
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialBody,@Override
    protected String getInitialBody(V8Object function) {
        String sbody;
        V8Object v8body = function.getObject("body");
        if (v8body.isUndefined()) {
            sbody = null;
        } else {
            sbody = v8body.executeStringFunction("getText"  new V8Array(v8body.getRuntime()));
        }
        return sbody;
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialBeginLine,@Override
    protected int getInitialBeginLine(V8Object function) {
        return function.getInteger("nameStartLine");
    },4,Minor Modification,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialBeginLine,@Override
    protected int getInitialBeginLine(V8Object function) {
        return function.getInteger("nameStartLine");
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialBeginLine,@Override
    protected int getInitialBeginLine(V8Object function) {
        return function.getInteger("nameStartLine");
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialBeginLine,@Override
    protected int getInitialBeginLine(V8Object function) {
        return function.getInteger("nameStartLine");
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialEndLine,@Override
    protected int getInitialEndLine(V8Object function) {
        return function.getInteger("endLine");
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialEndLine,@Override
    protected int getInitialEndLine(V8Object function) {
        return function.getInteger("endLine");
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialEndLine,@Override
    protected int getInitialEndLine(V8Object function) {
        return function.getInteger("endLine");
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialEndLine,@Override
    protected int getInitialEndLine(V8Object function) {
        return function.getInteger("endLine");
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialParentName,@Override
    protected String getInitialParentName(V8Object function) {
        String sparent = "";
        V8Object v8current = function.getObject("parent");
        while (!v8current.isUndefined()) {
            if (v8current.contains("name")) {
                sparent = v8current.getObject("name").getString("escapedText");
                break;
            } else {
                v8current = v8current.getObject("parent");
            }
        }
        return sparent;
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialParentName,@Override
    protected String getInitialParentName(V8Object function) {
        String sparent = "";
        V8Object v8current = function.getObject("parent");
        while (!v8current.isUndefined()) {
            if (v8current.contains("name")) {
                sparent = v8current.getObject("name").getString("escapedText");
                break;
            } else {
                v8current = v8current.getObject("parent");
            }
        }
        return sparent;
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialParentName,@Override
    protected String getInitialParentName(V8Object function) {
        String sparent = "";
        V8Object v8current = function.getObject("parent");
        while (!v8current.isUndefined()) {
            if (v8current.contains("name")) {
                sparent = v8current.getObject("name").getString("escapedText");
                break;
            } else {
                v8current = v8current.getObject("parent");
            }
        }
        return sparent;
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialParentName,@Override
    protected String getInitialParentName(V8Object function) {
        String sparent = "";
        V8Object v8current = function.getObject("parent");
        while (!v8current.isUndefined()) {
            if (v8current.contains("name")) {
                sparent = v8current.getObject("name").getString("escapedText");
                break;
            } else {
                v8current = v8current.getObject("parent");
            }
        }
        return sparent;
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(V8Object function) {
        StringBuilder path = new StringBuilder();
        V8Object v8current = function.getObject("parent");
        while (!v8current.isUndefined()) {
            if (v8current.contains("name")) {
                path.insert(0  "/");
                path.insert(0  v8current.getObject("name").getString("escapedText"));
            }
            v8current = v8current.getObject("parent");
        }
        return path.toString();
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(V8Object function) {
        StringBuilder path = new StringBuilder();
        V8Object v8current = function.getObject("parent");
        while (!v8current.isUndefined()) {
            if (v8current.contains("name")) {
                path.insert(0  "/");
                path.insert(0  v8current.getObject("name").getString("escapedText"));
            }
            v8current = v8current.getObject("parent");
        }
        return path.toString();
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(V8Object function) {
        StringBuilder path = new StringBuilder();
        V8Object v8current = function.getObject("parent");
        while (!v8current.isUndefined()) {
            if (v8current.contains("name")) {
                path.insert(0  "/");
                path.insert(0  v8current.getObject("name").getString("escapedText"));
            }
            v8current = v8current.getObject("parent");
        }
        return path.toString();
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(V8Object function) {
        StringBuilder path = new StringBuilder();
        V8Object v8current = function.getObject("parent");
        while (!v8current.isUndefined()) {
            if (v8current.contains("name")) {
                path.insert(0  "/");
                path.insert(0  v8current.getObject("name").getString("escapedText"));
            }
            v8current = v8current.getObject("parent");
        }
        return path.toString();
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialAnnotation,@Override
    protected String getInitialAnnotation(V8Object rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        if (rawMethod.contains("decorators") && !rawMethod.getObject("decorators").isUndefined()) {
            V8Array decoratorObjects = rawMethod.getArray("decorators");
            int length = decoratorObjects.length();
            for (int i = 0; i < length; i = i + 1) {
                V8Object decoratorObject = decoratorObjects.getObject(i);
                String decoratorObjectText = decoratorObject
                        .executeStringFunction("getText"  new V8Array(decoratorObject.getRuntime()));
                decoratorList.add(decoratorObjectText);
            }
        }
        return StringUtils.join(decoratorList  " ");
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialAnnotation,@Override
    protected String getInitialAnnotation(V8Object rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        if (rawMethod.contains("decorators") && !rawMethod.getObject("decorators").isUndefined()) {
            V8Array decoratorObjects = rawMethod.getArray("decorators");
            int length = decoratorObjects.length();
            for (int i = 0; i < length; i = i + 1) {
                V8Object decoratorObject = decoratorObjects.getObject(i);
                String decoratorObjectText = decoratorObject
                        .executeStringFunction("getText"  new V8Array(decoratorObject.getRuntime()));
                decoratorList.add(decoratorObjectText);
            }
        }
        return StringUtils.join(decoratorList  " ");
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialAnnotation,@Override
    protected String getInitialAnnotation(V8Object rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        if (rawMethod.contains("decorators") && !rawMethod.getObject("decorators").isUndefined()) {
            V8Array decoratorObjects = rawMethod.getArray("decorators");
            int length = decoratorObjects.length();
            for (int i = 0; i < length; i = i + 1) {
                V8Object decoratorObject = decoratorObjects.getObject(i);
                String decoratorObjectText = decoratorObject
                        .executeStringFunction("getText"  new V8Array(decoratorObject.getRuntime()));
                decoratorList.add(decoratorObjectText);
            }
        }
        return StringUtils.join(decoratorList  " ");
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialAnnotation,@Override
    protected String getInitialAnnotation(V8Object rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        if (rawMethod.contains("decorators") && !rawMethod.getObject("decorators").isUndefined()) {
            V8Array decoratorObjects = rawMethod.getArray("decorators");
            int length = decoratorObjects.length();
            for (int i = 0; i < length; i = i + 1) {
                V8Object decoratorObject = decoratorObjects.getObject(i);
                String decoratorObjectText = decoratorObject
                        .executeStringFunction("getText"  new V8Array(decoratorObject.getRuntime()));
                decoratorList.add(decoratorObjectText);
            }
        }
        return StringUtils.join(decoratorList  " ");
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialDoc,@Override
    protected String getInitialDoc(V8Object rawMethod) {
        // TODO: implement function for typescript
        return null;
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialDoc,@Override
    protected String getInitialDoc(V8Object rawMethod) {
        // TODO: implement function for typescript
        return null;
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialDoc,@Override
    protected String getInitialDoc(V8Object rawMethod) {
        // TODO: implement function for typescript
        return null;
    },4,Annotation Change | Signature Change | Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialDoc,@Override
    protected String getInitialDoc(V8Object rawMethod) {
        // TODO: implement function for typescript
        return null;
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(V8Object rawMethod) {
        // TODO: implement function for typescript
        return null;
    },4,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(V8Object rawMethod) {
        // TODO: implement function for typescript
        return null;
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(V8Object rawMethod) {
        // TODO: implement function for typescript
        return null;
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(V8Object rawMethod) {
        // TODO: implement function for typescript
        return null;
    },4,Annotation Change | Signature Change | Body Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(V8Object rawMethod) {
        int startLine = rawMethod.getInteger("startLine");
        int endLine = getEndLineNumber();
        String source = getSourceFileContent();
        return Utl.getTextFragment(source  startLine  endLine);
    },4,Annotation Change | Signature Change | Body Change,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(V8Object rawMethod) {
        int startLine = rawMethod.getInteger("startLine");
        int endLine = getEndLineNumber();
        String source = getSourceFileContent();
        return Utl.getTextFragment(source  startLine  endLine);
    },4,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(V8Object rawMethod) {
        int startLine = rawMethod.getInteger("startLine");
        int endLine = getEndLineNumber();
        String source = getSourceFileContent();
        return Utl.getTextFragment(source  startLine  endLine);
    },4,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(V8Object rawMethod) {
        int startLine = rawMethod.getInteger("startLine");
        int endLine = getEndLineNumber();
        String source = getSourceFileContent();
        return Utl.getTextFragment(source  startLine  endLine);
    },4,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
TypeScriptParser,public TypeScriptParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
TypeScriptParser,public TypeScriptParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
TypeScriptParser,public TypeScriptParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
            TypeScriptMethodVisitor visitor = new TypeScriptMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            visitor.visit(this.fileContent);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            throw new ParseException(e.getMessage()  this.filePath  this.fileContent);
        }
    },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
            TypeScriptMethodVisitor visitor = new TypeScriptMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            visitor.visit(this.fileContent);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            throw new ParseException(e.getMessage()  this.filePath  this.fileContent);
        }
    },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
            TypeScriptMethodVisitor visitor = new TypeScriptMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            visitor.visit(this.fileContent);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            throw new ParseException(e.getMessage()  this.filePath  this.fileContent);
        }
    },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0; // TODO
    },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0; // TODO
    },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0; // TODO
    },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        // TODO: handle Ydocchange
        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        return changes;
    },3,Body Change,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        // TODO: handle Ydocchange
        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        return changes;
    },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        // TODO: handle Ydocchange
        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        return changes;
    },3,Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
transformMethod,private Yfunction transformMethod(V8Object function) {
        return new TypeScriptFunction(function  this.commit  this.filePath  this.fileContent);
    },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
transformMethod,private Yfunction transformMethod(V8Object function) {
        return new TypeScriptFunction(function  this.commit  this.filePath  this.fileContent);
    },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
transformMethod,private Yfunction transformMethod(V8Object function) {
        return new TypeScriptFunction(function  this.commit  this.filePath  this.fileContent);
    },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,public abstract boolean methodMatches(Yfunction method);,3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,public abstract boolean methodMatches(Yfunction method);,3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
methodMatches,public abstract boolean methodMatches(Yfunction method);,3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visit,@Override
        public void visit(String source) {
            sourceFile = getSource(source);
            visit(sourceFile);
            sourceFile = null;
            clear();
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
visit,@Override
        public void visit(String source) {
            sourceFile = getSource(source);
            visit(sourceFile);
            sourceFile = null;
            clear();
        },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visit,@Override
        public void visit(String source) {
            sourceFile = getSource(source);
            visit(sourceFile);
            sourceFile = null;
            clear();
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitArrowFunction,@Override
        public void visitArrowFunction(V8Object arrowFunction) {
            // TODO handle this function with no name
            visitChildren(arrowFunction);
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
visitArrowFunction,@Override
        public void visitArrowFunction(V8Object arrowFunction) {
            // TODO handle this function with no name
            visitChildren(arrowFunction);
        },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visitArrowFunction,@Override
        public void visitArrowFunction(V8Object arrowFunction) {
            // TODO handle this function with no name
            visitChildren(arrowFunction);
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitConstructor,@Override
        public void visitConstructor(V8Object constructor) {
            addStartAndEndLines(constructor);
            Yfunction yfunction = transformMethod(constructor);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(constructor);
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
visitConstructor,@Override
        public void visitConstructor(V8Object constructor) {
            addStartAndEndLines(constructor);
            Yfunction yfunction = transformMethod(constructor);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(constructor);
        },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visitConstructor,@Override
        public void visitConstructor(V8Object constructor) {
            addStartAndEndLines(constructor);
            Yfunction yfunction = transformMethod(constructor);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(constructor);
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitFunctionDeclaration,@Override
        public void visitFunctionDeclaration(V8Object function) {
            addStartAndEndLines(function);
            Yfunction yfunction = transformMethod(function);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(function);
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
visitFunctionDeclaration,@Override
        public void visitFunctionDeclaration(V8Object function) {
            addStartAndEndLines(function);
            Yfunction yfunction = transformMethod(function);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(function);
        },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visitFunctionDeclaration,@Override
        public void visitFunctionDeclaration(V8Object function) {
            addStartAndEndLines(function);
            Yfunction yfunction = transformMethod(function);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(function);
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitFunctionExpression,@Override
        public void visitFunctionExpression(V8Object functionExpression) {
            // TODO handle this function with potentially no name
            visitChildren(functionExpression);
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
visitFunctionExpression,@Override
        public void visitFunctionExpression(V8Object functionExpression) {
            // TODO handle this function with potentially no name
            visitChildren(functionExpression);
        },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visitFunctionExpression,@Override
        public void visitFunctionExpression(V8Object functionExpression) {
            // TODO handle this function with potentially no name
            visitChildren(functionExpression);
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitMethodDeclaration,@Override
        public void visitMethodDeclaration(V8Object methodDeclaration) {
            addStartAndEndLines(methodDeclaration);
            Yfunction yfunction = transformMethod(methodDeclaration);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(methodDeclaration);
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
visitMethodDeclaration,@Override
        public void visitMethodDeclaration(V8Object methodDeclaration) {
            addStartAndEndLines(methodDeclaration);
            Yfunction yfunction = transformMethod(methodDeclaration);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(methodDeclaration);
        },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visitMethodDeclaration,@Override
        public void visitMethodDeclaration(V8Object methodDeclaration) {
            addStartAndEndLines(methodDeclaration);
            Yfunction yfunction = transformMethod(methodDeclaration);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            visitChildren(methodDeclaration);
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMatchedNodes,List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMatchedNodes,List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },3,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getMatchedNodes,List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getLineFrom,private int getLineFrom(V8 runtime  V8Object node  String function) {
            int start = node.executeIntegerFunction(function  new V8Array(runtime));
            V8Array parameters = new V8Array(runtime).push(start);
            V8Object startLineAndCharacterOfPosition = sourceFile.executeObjectFunction("getLineAndCharacterOfPosition"  parameters);
            int line = startLineAndCharacterOfPosition.getInteger("line");

            parameters.release();
            startLineAndCharacterOfPosition.release();

            return line;
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getLineFrom,private int getLineFrom(V8 runtime  V8Object node  String function) {
            int start = node.executeIntegerFunction(function  new V8Array(runtime));
            V8Array parameters = new V8Array(runtime).push(start);
            V8Object startLineAndCharacterOfPosition = sourceFile.executeObjectFunction("getLineAndCharacterOfPosition"  parameters);
            int line = startLineAndCharacterOfPosition.getInteger("line");

            parameters.release();
            startLineAndCharacterOfPosition.release();

            return line;
        },3,Signature Change | Body Change,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getLineFrom,private int getLineFrom(V8 runtime  V8Object node  String function) {
            int start = node.executeIntegerFunction(function  new V8Array(runtime));
            V8Array parameters = new V8Array(runtime).push(start);
            V8Object startLineAndCharacterOfPosition = sourceFile.executeObjectFunction("getLineAndCharacterOfPosition"  parameters);
            int line = startLineAndCharacterOfPosition.getInteger("line");

            parameters.release();
            startLineAndCharacterOfPosition.release();

            return line;
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
addStartAndEndLines,private void addStartAndEndLines(V8Object node) {
            V8 runtime = ts.getRuntime();

            int startLine = getLineFrom(runtime  node  "getStart");
            int endLine = getLineFrom(runtime  node  "getEnd");
            int nameStartLine;

            V8Object name = node.getObject("name");
            if (!name.isUndefined()) {
                nameStartLine = getLineFrom(runtime  name  "getStart");
            } else {
                // If name is undefined then we have a constructor (no decorators possible)
                nameStartLine = startLine;
            }

            // Add one because lines are zero indexed in ts
            node.add("startLine"  startLine + 1);
            node.add("endLine"  endLine + 1);
            node.add("nameStartLine"  nameStartLine + 1);
        },3,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
addStartAndEndLines,private void addStartAndEndLines(V8Object node) {
            V8 runtime = ts.getRuntime();

            int startLine = getLineFrom(runtime  node  "getStart");
            int endLine = getLineFrom(runtime  node  "getEnd");
            int nameStartLine;

            V8Object name = node.getObject("name");
            if (!name.isUndefined()) {
                nameStartLine = getLineFrom(runtime  name  "getStart");
            } else {
                // If name is undefined then we have a constructor (no decorators possible)
                nameStartLine = startLine;
            }

            // Add one because lines are zero indexed in ts
            node.add("startLine"  startLine + 1);
            node.add("endLine"  endLine + 1);
            node.add("nameStartLine"  nameStartLine + 1);
        },3,Body Change,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
addStartAndEndLines,private void addStartAndEndLines(V8Object node) {
            V8 runtime = ts.getRuntime();

            int startLine = getLineFrom(runtime  node  "getStart");
            int endLine = getLineFrom(runtime  node  "getEnd");
            int nameStartLine;

            V8Object name = node.getObject("name");
            if (!name.isUndefined()) {
                nameStartLine = getLineFrom(runtime  name  "getStart");
            } else {
                // If name is undefined then we have a constructor (no decorators possible)
                nameStartLine = startLine;
            }

            // Add one because lines are zero indexed in ts
            node.add("startLine"  startLine + 1);
            node.add("endLine"  endLine + 1);
            node.add("nameStartLine"  nameStartLine + 1);
        },3,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,Parameter Change | Signature Change | Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,Parameter Change | Body Change,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
JavaFunction,public JavaFunction(MethodDeclaration method  Commit commit  String sourceFilePath  String sourceFileContent) {
		super(method  commit  sourceFilePath  sourceFileContent);
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,Signature Change | Body Change,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
createParameterMetadataMap,private Map<String String> createParameterMetadataMap(Parameter parameterElement) {
		Map<String  String> metadata = new HashMap<>();
		String modifiersString = createParameterModifiersString(parameterElement);
		if (modifiersString != null) {
			metadata.put("modifiers"  modifiersString);
		}
		String annotationsString = createParameterAnnotationsString(parameterElement);
		if (annotationsString != null) {
			metadata.put("annotations"  annotationsString);
		}
		return metadata;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,Signature Change | Body Change,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
createParameterModifiersString,private String createParameterModifiersString(Parameter parameterElement) {
		String ret = null;
		List<String> modifiers = new ArrayList<String>();
		for (Modifier modifier : parameterElement.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		if (modifiers.size() > 0) {
			ret = StringUtils.join(modifiers  "-");
		}
		return ret;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,Signature Change | Body Change,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
createParameterAnnotationsString,private String createParameterAnnotationsString(Parameter parameterElement) {
		String ret = null;
		List<String> annotations = new ArrayList<String>();
		for (Node node : parameterElement.getAnnotations()) {
			annotations.add(node.toString());
		}
		if (annotations.size() > 0) {
			ret = StringUtils.join(annotations  "-");
		}
		return ret;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialName,@Override
	protected String getInitialName(MethodDeclaration method) {
		return method.getNameAsString();
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialType,@Override
	protected String getInitialType(MethodDeclaration method) {
		return method.getTypeAsString();
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialModifiers,@Override
	protected Ymodifiers getInitialModifiers(MethodDeclaration method) {
		List<String> modifiers = new ArrayList<>();
		for (Modifier modifier : method.getModifiers()) {
			modifiers.add(modifier.asString());
		}
		return new Ymodifiers(modifiers);
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialExceptions,@Override
	protected Yexceptions getInitialExceptions(MethodDeclaration method) {
		List<String> exceptions = new ArrayList<>();
		for (ReferenceType type : method.getThrownExceptions()) {
			exceptions.add(type.asString());
		}
		return new Yexceptions(exceptions);
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialParameters,@Override
	protected List<Yparameter> getInitialParameters(MethodDeclaration method) {
		List<Yparameter> parametersList = new ArrayList<>();
		List<Parameter> parameterElements = method.getParameters();
		for (Parameter parameterElement : parameterElements) {
			Yparameter parameter = new Yparameter(parameterElement.getNameAsString()  parameterElement.getTypeAsString());
			Map<String  String> metadata = createParameterMetadataMap(parameterElement);
			parameter.setMetadata(metadata);
			parametersList.add(parameter);
		}
		return parametersList;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialBody,@Override
	protected String getInitialBody(MethodDeclaration method) {
		String body = null;
		if (method.getBody().isPresent()) {
			body = method.getBody().get().toString(new PrettyPrinterConfiguration().setPrintComments(true));
		}
		return body;
	},17,Body Change,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialBeginLine,@Override
	protected int getInitialBeginLine(MethodDeclaration method) {
		int beginLine = 0;
		if (method.getName().getBegin().isPresent()) {
			beginLine = method.getName().getBegin().get().line;
		}
		return beginLine;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialEndLine,@Override
	protected int getInitialEndLine(MethodDeclaration method) {
		int endLine = 0;
		if (method.getEnd().isPresent()) {
			endLine = method.getEnd().get().line;
		}
		return endLine;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialParentName,@Override
	protected String getInitialParentName(MethodDeclaration method) {
		String parentName = null;
		if (method.getParentNode().isPresent()) {
			Node node = method.getParentNode().get();
			if (node instanceof NodeWithName) {
				parentName = ((NodeWithName) method.getParentNode().get()).getNameAsString();
			} else if (node instanceof NodeWithSimpleName) {
				parentName = ((NodeWithSimpleName) method.getParentNode().get()).getNameAsString();
			}
		}
		return parentName;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialFunctionPath,@Override
	protected String getInitialFunctionPath(MethodDeclaration method) {
		return null;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,Annotation Change | Signature Change | Body Change,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,Annotation Change | Signature Change | Body Change,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,Annotation Change | Signature Change | Body Change,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialId,@Override
	protected String getInitialId(MethodDeclaration method) {
		String ident = getName();
		if (isNestedMethod(method)) {
			ident = "$" + ident;
		}
		String idParameterString = super.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,Annotation Change | Signature Change | Body Change,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialSourceFragment,@Override
	protected String getInitialSourceFragment(MethodDeclaration method) {
		return method.toString(new PrettyPrinterConfiguration().setPrintComments(false));
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,Annotation Change | Signature Change | Body Change,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,Minor Modification,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialAnnotation,/**
	 * @return all the annotation of a method
	 * Source Code Example:
	 * @Override
	 * @Test
	 * public void foo() {}
	 * This will return "@Override @Test" since foo has two annotations @Test and @Override
	 * */
	@Override
	protected String getInitialAnnotation(MethodDeclaration method) {
		List<String> annotationsList = new ArrayList<>();
		for(AnnotationExpr annotation: method.getAnnotations()) {
			annotationsList.add(annotation.toString());
		}
		return StringUtils.join(annotationsList  " ");
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,Signature Change | Body Change,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,Signature Change | Body Change,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,Signature Change | Body Change,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
isNestedMethod,private boolean isNestedMethod(MethodDeclaration method) {
		if (method.getParentNode().isPresent()) {
			Node parentNode = method.getParentNode().get();
			if (parentNode.getParentNode().isPresent()) {
				Node grandParentNode = parentNode.getParentNode().get();
				return grandParentNode instanceof NodeWithSimpleName;
			}
		}
		return false;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,Annotation Change | Signature Change | Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialDoc,@Override
	protected String getInitialDoc(MethodDeclaration method) {
		return method.hasJavaDocComment() ? method.getJavadoc().get().toText() : "" ;
	},17,,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,23b951ff27902c94861f0aa466bbf66508d39b05,fgrund,Fix test setup such that environment flags work properly again 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,00c7764edaa819f7b836cc4dfbbddc5b91d58c8b,fgrund,Merge branch 'integrate-shaifuls-fork' into develop  # Conflicts: #	src/main/java/com/felixgrund/codeshovel/parser/impl/JavaFunction.java 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,Annotation Change | Signature Change | Body Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialUnformattedBody,@Override
	protected String getInitialUnformattedBody(MethodDeclaration method) {
		if (method.getBody().isPresent()) {
			LexicalPreservingPrinter.setup(method);
			return LexicalPreservingPrinter.print(method.getBody().get());
		} else {
			return null;
		}
	},17,Body Change,272b37ac9cdf0d055d63dc1587fff23c4c23d53a,Syed Ishtiaque Ahmad,Feature #76 Fix test failures for Yformatchange - Check if method body is present before getting unformatted body - Fix all java test failures related to Yformatchange 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,Minor Modification,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,Minor Modification,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,Minor Modification,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
JavaParser,public JavaParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,Annotation Change | Signature Change | Body Change,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,Body Change,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,Body Change,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,Minor Modification,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,Signature Change | Body Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,Signature Change | Body Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,Signature Change | Body Change,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
//			CompilationUnit rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
//			if (rootCompilationUnit == null) {
//				throw new ParseException("Could not parseMethods root compilation unit."  this.filePath  this.fileContent);
//			}
            CompilationUnit rootCompilationUnit = null;
            try {
                rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);
            } catch (Exception e) {
                return new ArrayList<>();
            }
            JavaMethodVisitor visitor = new JavaMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            rootCompilationUnit.accept(visitor  null);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            System.err.println("JavaParser::parseMethods() - parse error. path: " + this.filePath + "; content:\n" + this.fileContent);
            throw new ParseException("Error during parsing of content"  this.filePath  this.fileContent);
        }
    },26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,Parameter Change | Signature Change | Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,Body Change,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,Minor Modification,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,Signature Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,Signature Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,Signature Change,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,Body Change,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,Body Change,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,Signature Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,Signature Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,Signature Change,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,Minor Modification,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,Minor Modification,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,Minor Modification,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,Body Change,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,Signature Change | Body Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,Signature Change | Body Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,Signature Change | Body Change,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,Body Change,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yexceptionschange yexceptionschange = getExceptionsChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Yformatchange yformatchange = getFormatChange(commit  compareFunction);
        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        Ydocchange ydocchange = getDocChange(commit  compareFunction);

        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yexceptionschange != null) {
            changes.add(yexceptionschange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        if (ydocchange != null) {
            changes.add(ydocchange);
        }
        if (yformatchange != null) {
            changes.add(yformatchange);
        }
        return changes;
    },26,Body Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,Signature Change | Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,Minor Modification,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,Minor Modification,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,Minor Modification,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
transformMethod,private Yfunction transformMethod(MethodDeclaration method) {
        return new JavaFunction(method  this.commit  this.filePath  this.fileContent);
    },26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,Parameter Change | Signature Change | Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,Body Change,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,Minor Modification,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,Signature Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,Signature Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,Signature Change,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,public abstract boolean methodMatches(Yfunction method);,26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,Signature Change | Body Change,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,Signature Change | Body Change,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,Signature Change | Body Change,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visit,@Override
        public void visit(MethodDeclaration method  Void arg) {
            super.visit(method  arg);
            boolean hasBody = method.getBody().isPresent();
            Yfunction yfunction = transformMethod(method);
            if (hasBody && methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
        },26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,217fb8daf87b06ba3cdd1395ba2a908fd6ce6e2d,Felix Grund,Fixed parentNameEquals bug 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,0e317de0b95568921649c9fc0a2a3d8dd49b6592,Felix Grund,fix javaparser 0 changes issue 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,9bb5d705447141be0d990e3473a8145951118a2d,Felix Grund,reverted fix 0 changes issue 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,Signature Change | Return Type Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,b40a6bb5358d8a5cdbe2cfcbbf3bbabfddde651a,Felix Grund,Added simple null check 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,7bcc29a9796c0e9dbf5caabfcdcaddc9c8f3416f,fgrund,Remove incomplete/obsolete JavaScript implementation 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,887417f97c67a15eacdb79f4b36585965c0f278e,Reid Holmes,see #47 improve the reporting at a couple of common error messages. update the tests to sort in alph order instead of lex order so the test set runs before the validation set. 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,Minor Modification,934f4e5da70c622d6be56ce309c87853fda3c003,Reid Holmes,see #47 Intermediate changes while simplifying the algorithim. (This will be a messy commit because a lot of in-progress work was rolled back). 189/200 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,Minor Modification,231baf5b72eec6254ba59d9735077a761100d632,Braxton Hall,Python Support (#49)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Add modifier change to python  * Remove C frontend  * Consistently use regex in ParserFactory  * Resolve conflict in ParserFactory  * Add import statement to ParserFactory  * Add Python repos to clone script
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,Minor Modification,e655d3d3d02e9166b50d7da1d83b841b7e3bb141,reid holmes,resolve conflicts bringing develop up-to-date with master  Merge remote-tracking branch 'origin/icse2021' into develop 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMatchedNodes,public List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },26,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
PythonParser,public PythonParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
PythonParser,public PythonParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        super(startEnv  filePath  fileContent  commit);
    },2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
            CharStream input = CharStreams.fromString(this.fileContent);
            PythonLexer lexer = new PythonLexer(input);
            TokenStream tokenStream = new CommonTokenStream(lexer);
            PythonParseTree.PythonParser parser = new PythonParseTree.PythonParser(tokenStream);
            ParseTree tree = parser.file_input();
            PythonMethodVisitor visitor = new PythonMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            visitor.visit(tree);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            throw new ParseException(e.getMessage()  this.filePath  this.fileContent);
        }
    },2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
parseMethods,@Override
    protected List<Yfunction> parseMethods() throws ParseException {
        try {
            CharStream input = CharStreams.fromString(this.fileContent);
            PythonLexer lexer = new PythonLexer(input);
            TokenStream tokenStream = new CommonTokenStream(lexer);
            PythonParseTree.PythonParser parser = new PythonParseTree.PythonParser(tokenStream);
            ParseTree tree = parser.file_input();
            PythonMethodVisitor visitor = new PythonMethodVisitor() {
                @Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                }
            };
            visitor.visit(tree);
            return visitor.getMatchedNodes();
        } catch (Exception e) {
            throw new ParseException(e.getMessage()  this.filePath  this.fileContent);
        }
    },2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,@Override
                public boolean methodMatches(Yfunction method) {
                    return method.getBody() != null;
                },2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getScopeSimilarity,@Override
    public double getScopeSimilarity(Yfunction function  Yfunction compareFunction) {
        return Utl.parentNamesMatch(function  compareFunction) ? 1.0 : 0.0;
    },2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getAcceptedFileExtension,@Override
    public String getAcceptedFileExtension() {
        return ACCEPTED_FILE_EXTENSION;
    },2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();

        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        // TODO handle Ydocchange

        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        return changes;
    },2,Body Change,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();

        Yparametermetachange yparametermetachange = getParametersMetaChange(commit  compareFunction);
        Yreturntypechange yreturntypechange = getReturnTypeChange(commit  compareFunction);
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        Ymodifierchange ymodifierchange = getModifiersChange(commit  compareFunction);
        Yannotationchange yannotationchange = getAnnotationChange(commit  compareFunction);
        // TODO handle Ydocchange

        if (yparametermetachange != null) {
            changes.add(yparametermetachange);
        }
        if (yreturntypechange != null) {
            changes.add(yreturntypechange);
        }
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        if (ymodifierchange != null) {
            changes.add(ymodifierchange);
        }
        if (yannotationchange != null) {
            changes.add(yannotationchange);
        }
        return changes;
    },2,Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
transformMethod,private Yfunction transformMethod(PythonParseTree.PythonParser.FuncdefContext function) {
        return new PythonFunction(function  this.commit  this.filePath  this.fileContent);
    },2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
transformMethod,private Yfunction transformMethod(PythonParseTree.PythonParser.FuncdefContext function) {
        return new PythonFunction(function  this.commit  this.filePath  this.fileContent);
    },2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,public abstract boolean methodMatches(Yfunction method);,2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,public abstract boolean methodMatches(Yfunction method);,2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitFuncdef,@Override
        public Void visitFuncdef(PythonParseTree.PythonParser.FuncdefContext function) {
            Yfunction yfunction = transformMethod(function);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            return visitChildren(function);
        },2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
visitFuncdef,@Override
        public Void visitFuncdef(PythonParseTree.PythonParser.FuncdefContext function) {
            Yfunction yfunction = transformMethod(function);
            if (methodMatches(yfunction)) {
                matchedNodes.add(yfunction);
            }
            return visitChildren(function);
        },2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMatchedNodes,List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },2,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMatchedNodes,List<Yfunction> getMatchedNodes() {
            return matchedNodes;
        },2,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
PythonFunction,PythonFunction(PythonParseTree.PythonParser.FuncdefContext function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
PythonFunction,PythonFunction(PythonParseTree.PythonParser.FuncdefContext function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
PythonFunction,PythonFunction(PythonParseTree.PythonParser.FuncdefContext function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
PythonFunction,PythonFunction(PythonParseTree.PythonParser.FuncdefContext function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
PythonFunction,PythonFunction(PythonParseTree.PythonParser.FuncdefContext function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
PythonFunction,PythonFunction(PythonParseTree.PythonParser.FuncdefContext function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
PythonFunction,PythonFunction(PythonParseTree.PythonParser.FuncdefContext function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
PythonFunction,PythonFunction(PythonParseTree.PythonParser.FuncdefContext function  Commit commit  String sourceFilePath  String sourceFileContent) {
        super(function  commit  sourceFilePath  sourceFileContent);
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParameter,private Yparameter getParameter(PythonParser.Def_parameterContext param) {
        if (param.named_parameter() != null) {
            String argumentName = param.named_parameter().name().getText();
            String argumentType = param.named_parameter().test() == null ? "" :
                    param.named_parameter().test().getText();
            return new Yparameter(argumentName  argumentType);
        } else {
            return new Yparameter(param.getText()  "");
        }
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getParameter,private Yparameter getParameter(PythonParser.Def_parameterContext param) {
        if (param.named_parameter() != null) {
            String argumentName = param.named_parameter().name().getText();
            String argumentType = param.named_parameter().test() == null ? "" :
                    param.named_parameter().test().getText();
            return new Yparameter(argumentName  argumentType);
        } else {
            return new Yparameter(param.getText()  "");
        }
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getParameter,private Yparameter getParameter(PythonParser.Def_parameterContext param) {
        if (param.named_parameter() != null) {
            String argumentName = param.named_parameter().name().getText();
            String argumentType = param.named_parameter().test() == null ? "" :
                    param.named_parameter().test().getText();
            return new Yparameter(argumentName  argumentType);
        } else {
            return new Yparameter(param.getText()  "");
        }
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getParameter,private Yparameter getParameter(PythonParser.Def_parameterContext param) {
        if (param.named_parameter() != null) {
            String argumentName = param.named_parameter().name().getText();
            String argumentType = param.named_parameter().test() == null ? "" :
                    param.named_parameter().test().getText();
            return new Yparameter(argumentName  argumentType);
        } else {
            return new Yparameter(param.getText()  "");
        }
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getParameter,private Yparameter getParameter(PythonParser.Def_parameterContext param) {
        if (param.named_parameter() != null) {
            String argumentName = param.named_parameter().name().getText();
            String argumentType = param.named_parameter().test() == null ? "" :
                    param.named_parameter().test().getText();
            return new Yparameter(argumentName  argumentType);
        } else {
            return new Yparameter(param.getText()  "");
        }
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getParameter,private Yparameter getParameter(PythonParser.Def_parameterContext param) {
        if (param.named_parameter() != null) {
            String argumentName = param.named_parameter().name().getText();
            String argumentType = param.named_parameter().test() == null ? "" :
                    param.named_parameter().test().getText();
            return new Yparameter(argumentName  argumentType);
        } else {
            return new Yparameter(param.getText()  "");
        }
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getParameter,private Yparameter getParameter(PythonParser.Def_parameterContext param) {
        if (param.named_parameter() != null) {
            String argumentName = param.named_parameter().name().getText();
            String argumentType = param.named_parameter().test() == null ? "" :
                    param.named_parameter().test().getText();
            return new Yparameter(argumentName  argumentType);
        } else {
            return new Yparameter(param.getText()  "");
        }
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParameter,private Yparameter getParameter(PythonParser.Def_parameterContext param) {
        if (param.named_parameter() != null) {
            String argumentName = param.named_parameter().name().getText();
            String argumentType = param.named_parameter().test() == null ? "" :
                    param.named_parameter().test().getText();
            return new Yparameter(argumentName  argumentType);
        } else {
            return new Yparameter(param.getText()  "");
        }
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParameter,private Yparameter getParameter(PythonParser.Named_parameterContext param) {
        String argumentName = "";
        if (param.getParent().getChild(0).getText().contains("*")) {
            // OK this looks a little shaky but is meant to include *args and **kwargs
            argumentName += param.getParent().getChild(0).getText();
        }
        argumentName += param.name().getText();
        String argumentType = param.test() == null ? "" : param.test().getText();
        return new Yparameter(argumentName  argumentType);
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getParameter,private Yparameter getParameter(PythonParser.Named_parameterContext param) {
        String argumentName = "";
        if (param.getParent().getChild(0).getText().contains("*")) {
            // OK this looks a little shaky but is meant to include *args and **kwargs
            argumentName += param.getParent().getChild(0).getText();
        }
        argumentName += param.name().getText();
        String argumentType = param.test() == null ? "" : param.test().getText();
        return new Yparameter(argumentName  argumentType);
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getParameter,private Yparameter getParameter(PythonParser.Named_parameterContext param) {
        String argumentName = "";
        if (param.getParent().getChild(0).getText().contains("*")) {
            // OK this looks a little shaky but is meant to include *args and **kwargs
            argumentName += param.getParent().getChild(0).getText();
        }
        argumentName += param.name().getText();
        String argumentType = param.test() == null ? "" : param.test().getText();
        return new Yparameter(argumentName  argumentType);
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getParameter,private Yparameter getParameter(PythonParser.Named_parameterContext param) {
        String argumentName = "";
        if (param.getParent().getChild(0).getText().contains("*")) {
            // OK this looks a little shaky but is meant to include *args and **kwargs
            argumentName += param.getParent().getChild(0).getText();
        }
        argumentName += param.name().getText();
        String argumentType = param.test() == null ? "" : param.test().getText();
        return new Yparameter(argumentName  argumentType);
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getParameter,private Yparameter getParameter(PythonParser.Named_parameterContext param) {
        String argumentName = "";
        if (param.getParent().getChild(0).getText().contains("*")) {
            // OK this looks a little shaky but is meant to include *args and **kwargs
            argumentName += param.getParent().getChild(0).getText();
        }
        argumentName += param.name().getText();
        String argumentType = param.test() == null ? "" : param.test().getText();
        return new Yparameter(argumentName  argumentType);
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getParameter,private Yparameter getParameter(PythonParser.Named_parameterContext param) {
        String argumentName = "";
        if (param.getParent().getChild(0).getText().contains("*")) {
            // OK this looks a little shaky but is meant to include *args and **kwargs
            argumentName += param.getParent().getChild(0).getText();
        }
        argumentName += param.name().getText();
        String argumentType = param.test() == null ? "" : param.test().getText();
        return new Yparameter(argumentName  argumentType);
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getParameter,private Yparameter getParameter(PythonParser.Named_parameterContext param) {
        String argumentName = "";
        if (param.getParent().getChild(0).getText().contains("*")) {
            // OK this looks a little shaky but is meant to include *args and **kwargs
            argumentName += param.getParent().getChild(0).getText();
        }
        argumentName += param.name().getText();
        String argumentType = param.test() == null ? "" : param.test().getText();
        return new Yparameter(argumentName  argumentType);
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParameter,private Yparameter getParameter(PythonParser.Named_parameterContext param) {
        String argumentName = "";
        if (param.getParent().getChild(0).getText().contains("*")) {
            // OK this looks a little shaky but is meant to include *args and **kwargs
            argumentName += param.getParent().getChild(0).getText();
        }
        argumentName += param.name().getText();
        String argumentType = param.test() == null ? "" : param.test().getText();
        return new Yparameter(argumentName  argumentType);
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getDefaultArguments,private Map<String  String> getDefaultArguments(PythonParser.Def_parameterContext param) {
        return param.test() == null ? null : getDefaultArguments(param.test().getText());
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getDefaultArguments,private Map<String  String> getDefaultArguments(PythonParser.Def_parameterContext param) {
        return param.test() == null ? null : getDefaultArguments(param.test().getText());
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getDefaultArguments,private Map<String  String> getDefaultArguments(PythonParser.Def_parameterContext param) {
        return param.test() == null ? null : getDefaultArguments(param.test().getText());
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getDefaultArguments,private Map<String  String> getDefaultArguments(PythonParser.Def_parameterContext param) {
        return param.test() == null ? null : getDefaultArguments(param.test().getText());
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getDefaultArguments,private Map<String  String> getDefaultArguments(PythonParser.Def_parameterContext param) {
        return param.test() == null ? null : getDefaultArguments(param.test().getText());
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getDefaultArguments,private Map<String  String> getDefaultArguments(PythonParser.Def_parameterContext param) {
        return param.test() == null ? null : getDefaultArguments(param.test().getText());
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getDefaultArguments,private Map<String  String> getDefaultArguments(PythonParser.Def_parameterContext param) {
        return param.test() == null ? null : getDefaultArguments(param.test().getText());
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getDefaultArguments,private Map<String  String> getDefaultArguments(PythonParser.Def_parameterContext param) {
        return param.test() == null ? null : getDefaultArguments(param.test().getText());
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getDefaultArguments,private Map<String  String> getDefaultArguments(String defaultArgument) {
        Map<String  String> metadata = new HashMap<>();
        metadata.put("default"  defaultArgument);
        return metadata;
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getDefaultArguments,private Map<String  String> getDefaultArguments(String defaultArgument) {
        Map<String  String> metadata = new HashMap<>();
        metadata.put("default"  defaultArgument);
        return metadata;
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getDefaultArguments,private Map<String  String> getDefaultArguments(String defaultArgument) {
        Map<String  String> metadata = new HashMap<>();
        metadata.put("default"  defaultArgument);
        return metadata;
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getDefaultArguments,private Map<String  String> getDefaultArguments(String defaultArgument) {
        Map<String  String> metadata = new HashMap<>();
        metadata.put("default"  defaultArgument);
        return metadata;
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getDefaultArguments,private Map<String  String> getDefaultArguments(String defaultArgument) {
        Map<String  String> metadata = new HashMap<>();
        metadata.put("default"  defaultArgument);
        return metadata;
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getDefaultArguments,private Map<String  String> getDefaultArguments(String defaultArgument) {
        Map<String  String> metadata = new HashMap<>();
        metadata.put("default"  defaultArgument);
        return metadata;
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getDefaultArguments,private Map<String  String> getDefaultArguments(String defaultArgument) {
        Map<String  String> metadata = new HashMap<>();
        metadata.put("default"  defaultArgument);
        return metadata;
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getDefaultArguments,private Map<String  String> getDefaultArguments(String defaultArgument) {
        Map<String  String> metadata = new HashMap<>();
        metadata.put("default"  defaultArgument);
        return metadata;
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialName,@Override
    protected String getInitialName(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.name().getText();
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialName,@Override
    protected String getInitialName(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.name().getText();
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialName,@Override
    protected String getInitialName(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.name().getText();
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialName,@Override
    protected String getInitialName(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.name().getText();
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialName,@Override
    protected String getInitialName(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.name().getText();
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialName,@Override
    protected String getInitialName(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.name().getText();
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialName,@Override
    protected String getInitialName(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.name().getText();
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialName,@Override
    protected String getInitialName(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.name().getText();
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialType,@Override
    protected String getInitialType(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.test() == null ? null : function.test().getText();
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialType,@Override
    protected String getInitialType(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.test() == null ? null : function.test().getText();
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialType,@Override
    protected String getInitialType(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.test() == null ? null : function.test().getText();
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialType,@Override
    protected String getInitialType(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.test() == null ? null : function.test().getText();
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialType,@Override
    protected String getInitialType(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.test() == null ? null : function.test().getText();
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialType,@Override
    protected String getInitialType(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.test() == null ? null : function.test().getText();
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialType,@Override
    protected String getInitialType(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.test() == null ? null : function.test().getText();
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialType,@Override
    protected String getInitialType(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.test() == null ? null : function.test().getText();
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(PythonParseTree.PythonParser.FuncdefContext function) {
        List<String> modifiers = new ArrayList<>();
        if (function.ASYNC() != null) {
            modifiers.add("async");
        }
        return new Ymodifiers(modifiers);
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(PythonParseTree.PythonParser.FuncdefContext function) {
        List<String> modifiers = new ArrayList<>();
        if (function.ASYNC() != null) {
            modifiers.add("async");
        }
        return new Ymodifiers(modifiers);
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(PythonParseTree.PythonParser.FuncdefContext function) {
        List<String> modifiers = new ArrayList<>();
        if (function.ASYNC() != null) {
            modifiers.add("async");
        }
        return new Ymodifiers(modifiers);
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(PythonParseTree.PythonParser.FuncdefContext function) {
        List<String> modifiers = new ArrayList<>();
        if (function.ASYNC() != null) {
            modifiers.add("async");
        }
        return new Ymodifiers(modifiers);
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(PythonParseTree.PythonParser.FuncdefContext function) {
        List<String> modifiers = new ArrayList<>();
        if (function.ASYNC() != null) {
            modifiers.add("async");
        }
        return new Ymodifiers(modifiers);
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(PythonParseTree.PythonParser.FuncdefContext function) {
        List<String> modifiers = new ArrayList<>();
        if (function.ASYNC() != null) {
            modifiers.add("async");
        }
        return new Ymodifiers(modifiers);
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(PythonParseTree.PythonParser.FuncdefContext function) {
        List<String> modifiers = new ArrayList<>();
        if (function.ASYNC() != null) {
            modifiers.add("async");
        }
        return new Ymodifiers(modifiers);
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialModifiers,@Override
    protected Ymodifiers getInitialModifiers(PythonParseTree.PythonParser.FuncdefContext function) {
        List<String> modifiers = new ArrayList<>();
        if (function.ASYNC() != null) {
            modifiers.add("async");
        }
        return new Ymodifiers(modifiers);
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialExceptions,@Override
    protected Yexceptions getInitialExceptions(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(PythonParseTree.PythonParser.FuncdefContext function) {
        List<Yparameter> parametersList = new ArrayList<>();
        new PythonParserBaseVisitor<Void>() {
            @Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            }
            @Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            }

            private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            }
        }.visit(function);
        return parametersList;
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(PythonParseTree.PythonParser.FuncdefContext function) {
        List<Yparameter> parametersList = new ArrayList<>();
        new PythonParserBaseVisitor<Void>() {
            @Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            }
            @Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            }

            private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            }
        }.visit(function);
        return parametersList;
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(PythonParseTree.PythonParser.FuncdefContext function) {
        List<Yparameter> parametersList = new ArrayList<>();
        new PythonParserBaseVisitor<Void>() {
            @Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            }
            @Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            }

            private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            }
        }.visit(function);
        return parametersList;
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(PythonParseTree.PythonParser.FuncdefContext function) {
        List<Yparameter> parametersList = new ArrayList<>();
        new PythonParserBaseVisitor<Void>() {
            @Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            }
            @Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            }

            private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            }
        }.visit(function);
        return parametersList;
    },8,Body Change,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(PythonParseTree.PythonParser.FuncdefContext function) {
        List<Yparameter> parametersList = new ArrayList<>();
        new PythonParserBaseVisitor<Void>() {
            @Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            }
            @Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            }

            private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            }
        }.visit(function);
        return parametersList;
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(PythonParseTree.PythonParser.FuncdefContext function) {
        List<Yparameter> parametersList = new ArrayList<>();
        new PythonParserBaseVisitor<Void>() {
            @Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            }
            @Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            }

            private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            }
        }.visit(function);
        return parametersList;
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(PythonParseTree.PythonParser.FuncdefContext function) {
        List<Yparameter> parametersList = new ArrayList<>();
        new PythonParserBaseVisitor<Void>() {
            @Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            }
            @Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            }

            private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            }
        }.visit(function);
        return parametersList;
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialParameters,@Override
    protected List<Yparameter> getInitialParameters(PythonParseTree.PythonParser.FuncdefContext function) {
        List<Yparameter> parametersList = new ArrayList<>();
        new PythonParserBaseVisitor<Void>() {
            @Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            }
            @Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            }

            private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            }
        }.visit(function);
        return parametersList;
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
visitDef_parameter,@Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
visitDef_parameter,@Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
visitDef_parameter,@Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
visitDef_parameter,@Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            },8,Body Change,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
visitDef_parameter,@Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visitDef_parameter,@Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
visitDef_parameter,@Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitDef_parameter,@Override public Void visitDef_parameter(PythonParser.Def_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                Map<String  String> metadata = getDefaultArguments(ctx);
                return visitParameterImpl(parameter  metadata);
            },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
visitNamed_parameter,@Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
visitNamed_parameter,@Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
visitNamed_parameter,@Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
visitNamed_parameter,@Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            },8,Body Change,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
visitNamed_parameter,@Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visitNamed_parameter,@Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
visitNamed_parameter,@Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitNamed_parameter,@Override public Void visitNamed_parameter(PythonParser.Named_parameterContext ctx) {
                Yparameter parameter = getParameter(ctx);
                // not possible to have arguments here
                return visitParameterImpl(parameter  null);
            },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
visitParameterImpl,private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
visitParameterImpl,private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
visitParameterImpl,private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
visitParameterImpl,private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            },8,Signature Change | Body Change,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
visitParameterImpl,private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
visitParameterImpl,private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
visitParameterImpl,private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
visitParameterImpl,private Void visitParameterImpl(Yparameter parameter  Map<String  String> metadata) {
                if (metadata != null) {
                    parameter.setMetadata(metadata);
                }
                parametersList.add(parameter);
                return null;
            },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialBody,@Override
    protected String getInitialBody(PythonParseTree.PythonParser.FuncdefContext function) {
        // This does not include any whitespace
        return function.suite().getText();
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialBody,@Override
    protected String getInitialBody(PythonParseTree.PythonParser.FuncdefContext function) {
        // This does not include any whitespace
        return function.suite().getText();
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialBody,@Override
    protected String getInitialBody(PythonParseTree.PythonParser.FuncdefContext function) {
        // This does not include any whitespace
        return function.suite().getText();
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialBody,@Override
    protected String getInitialBody(PythonParseTree.PythonParser.FuncdefContext function) {
        // This does not include any whitespace
        return function.suite().getText();
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialBody,@Override
    protected String getInitialBody(PythonParseTree.PythonParser.FuncdefContext function) {
        // This does not include any whitespace
        return function.suite().getText();
    },8,Body Change,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialBody,@Override
    protected String getInitialBody(PythonParseTree.PythonParser.FuncdefContext function) {
        // This does not include any whitespace
        return function.suite().getText();
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialBody,@Override
    protected String getInitialBody(PythonParseTree.PythonParser.FuncdefContext function) {
        // This does not include any whitespace
        return function.suite().getText();
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialBody,@Override
    protected String getInitialBody(PythonParseTree.PythonParser.FuncdefContext function) {
        // This does not include any whitespace
        return function.suite().getText();
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialBeginLine,@Override
    protected int getInitialBeginLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStart().getLine();
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialBeginLine,@Override
    protected int getInitialBeginLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStart().getLine();
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialBeginLine,@Override
    protected int getInitialBeginLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStart().getLine();
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialBeginLine,@Override
    protected int getInitialBeginLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStart().getLine();
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialBeginLine,@Override
    protected int getInitialBeginLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStart().getLine();
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialBeginLine,@Override
    protected int getInitialBeginLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStart().getLine();
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialBeginLine,@Override
    protected int getInitialBeginLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStart().getLine();
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialBeginLine,@Override
    protected int getInitialBeginLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStart().getLine();
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialEndLine,@Override
    protected int getInitialEndLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStop().getLine() - 1;
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialEndLine,@Override
    protected int getInitialEndLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStop().getLine() - 1;
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialEndLine,@Override
    protected int getInitialEndLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStop().getLine() - 1;
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialEndLine,@Override
    protected int getInitialEndLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStop().getLine() - 1;
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialEndLine,@Override
    protected int getInitialEndLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStop().getLine() - 1;
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialEndLine,@Override
    protected int getInitialEndLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStop().getLine() - 1;
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialEndLine,@Override
    protected int getInitialEndLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStop().getLine() - 1;
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialEndLine,@Override
    protected int getInitialEndLine(PythonParseTree.PythonParser.FuncdefContext function) {
        return function.getStop().getLine() - 1;
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialParentName,@Override
    protected String getInitialParentName(PythonParseTree.PythonParser.FuncdefContext function) {
        RuleContext parent = function.getParent();
        while (parent != null) {
            if (parent instanceof PythonParseTree.PythonParser.FuncdefContext) {
                return ((PythonParseTree.PythonParser.FuncdefContext) parent).name().getText();
            } else if (parent instanceof PythonParseTree.PythonParser.ClassdefContext) {
                return ((PythonParseTree.PythonParser.ClassdefContext) parent).name().getText();
            } else {
                parent = parent.getParent();
            }
        }
        return "";
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialParentName,@Override
    protected String getInitialParentName(PythonParseTree.PythonParser.FuncdefContext function) {
        RuleContext parent = function.getParent();
        while (parent != null) {
            if (parent instanceof PythonParseTree.PythonParser.FuncdefContext) {
                return ((PythonParseTree.PythonParser.FuncdefContext) parent).name().getText();
            } else if (parent instanceof PythonParseTree.PythonParser.ClassdefContext) {
                return ((PythonParseTree.PythonParser.ClassdefContext) parent).name().getText();
            } else {
                parent = parent.getParent();
            }
        }
        return "";
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialParentName,@Override
    protected String getInitialParentName(PythonParseTree.PythonParser.FuncdefContext function) {
        RuleContext parent = function.getParent();
        while (parent != null) {
            if (parent instanceof PythonParseTree.PythonParser.FuncdefContext) {
                return ((PythonParseTree.PythonParser.FuncdefContext) parent).name().getText();
            } else if (parent instanceof PythonParseTree.PythonParser.ClassdefContext) {
                return ((PythonParseTree.PythonParser.ClassdefContext) parent).name().getText();
            } else {
                parent = parent.getParent();
            }
        }
        return "";
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialParentName,@Override
    protected String getInitialParentName(PythonParseTree.PythonParser.FuncdefContext function) {
        RuleContext parent = function.getParent();
        while (parent != null) {
            if (parent instanceof PythonParseTree.PythonParser.FuncdefContext) {
                return ((PythonParseTree.PythonParser.FuncdefContext) parent).name().getText();
            } else if (parent instanceof PythonParseTree.PythonParser.ClassdefContext) {
                return ((PythonParseTree.PythonParser.ClassdefContext) parent).name().getText();
            } else {
                parent = parent.getParent();
            }
        }
        return "";
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialParentName,@Override
    protected String getInitialParentName(PythonParseTree.PythonParser.FuncdefContext function) {
        RuleContext parent = function.getParent();
        while (parent != null) {
            if (parent instanceof PythonParseTree.PythonParser.FuncdefContext) {
                return ((PythonParseTree.PythonParser.FuncdefContext) parent).name().getText();
            } else if (parent instanceof PythonParseTree.PythonParser.ClassdefContext) {
                return ((PythonParseTree.PythonParser.ClassdefContext) parent).name().getText();
            } else {
                parent = parent.getParent();
            }
        }
        return "";
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialParentName,@Override
    protected String getInitialParentName(PythonParseTree.PythonParser.FuncdefContext function) {
        RuleContext parent = function.getParent();
        while (parent != null) {
            if (parent instanceof PythonParseTree.PythonParser.FuncdefContext) {
                return ((PythonParseTree.PythonParser.FuncdefContext) parent).name().getText();
            } else if (parent instanceof PythonParseTree.PythonParser.ClassdefContext) {
                return ((PythonParseTree.PythonParser.ClassdefContext) parent).name().getText();
            } else {
                parent = parent.getParent();
            }
        }
        return "";
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialParentName,@Override
    protected String getInitialParentName(PythonParseTree.PythonParser.FuncdefContext function) {
        RuleContext parent = function.getParent();
        while (parent != null) {
            if (parent instanceof PythonParseTree.PythonParser.FuncdefContext) {
                return ((PythonParseTree.PythonParser.FuncdefContext) parent).name().getText();
            } else if (parent instanceof PythonParseTree.PythonParser.ClassdefContext) {
                return ((PythonParseTree.PythonParser.ClassdefContext) parent).name().getText();
            } else {
                parent = parent.getParent();
            }
        }
        return "";
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialParentName,@Override
    protected String getInitialParentName(PythonParseTree.PythonParser.FuncdefContext function) {
        RuleContext parent = function.getParent();
        while (parent != null) {
            if (parent instanceof PythonParseTree.PythonParser.FuncdefContext) {
                return ((PythonParseTree.PythonParser.FuncdefContext) parent).name().getText();
            } else if (parent instanceof PythonParseTree.PythonParser.ClassdefContext) {
                return ((PythonParseTree.PythonParser.ClassdefContext) parent).name().getText();
            } else {
                parent = parent.getParent();
            }
        }
        return "";
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialFunctionPath,@Override
    protected String getInitialFunctionPath(PythonParseTree.PythonParser.FuncdefContext function) {
        return null;
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialAnnotation,@Override
    protected String getInitialAnnotation(PythonParser.FuncdefContext rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        RuleContext parent = rawMethod.getParent();
        if (parent instanceof PythonParser.Class_or_func_def_stmtContext) {
            List<PythonParser.DecoratorContext> decoratorContexts =
                    ((PythonParser.Class_or_func_def_stmtContext) parent).decorator();
            for (PythonParser.DecoratorContext decoratorContext : decoratorContexts) {
                decoratorList.add(decoratorContext.getText());
            }
        }
        return StringUtils.join(decoratorList  " ");
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialAnnotation,@Override
    protected String getInitialAnnotation(PythonParser.FuncdefContext rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        RuleContext parent = rawMethod.getParent();
        if (parent instanceof PythonParser.Class_or_func_def_stmtContext) {
            List<PythonParser.DecoratorContext> decoratorContexts =
                    ((PythonParser.Class_or_func_def_stmtContext) parent).decorator();
            for (PythonParser.DecoratorContext decoratorContext : decoratorContexts) {
                decoratorList.add(decoratorContext.getText());
            }
        }
        return StringUtils.join(decoratorList  " ");
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialAnnotation,@Override
    protected String getInitialAnnotation(PythonParser.FuncdefContext rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        RuleContext parent = rawMethod.getParent();
        if (parent instanceof PythonParser.Class_or_func_def_stmtContext) {
            List<PythonParser.DecoratorContext> decoratorContexts =
                    ((PythonParser.Class_or_func_def_stmtContext) parent).decorator();
            for (PythonParser.DecoratorContext decoratorContext : decoratorContexts) {
                decoratorList.add(decoratorContext.getText());
            }
        }
        return StringUtils.join(decoratorList  " ");
    },8,Annotation Change | Signature Change | Body Change,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialAnnotation,@Override
    protected String getInitialAnnotation(PythonParser.FuncdefContext rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        RuleContext parent = rawMethod.getParent();
        if (parent instanceof PythonParser.Class_or_func_def_stmtContext) {
            List<PythonParser.DecoratorContext> decoratorContexts =
                    ((PythonParser.Class_or_func_def_stmtContext) parent).decorator();
            for (PythonParser.DecoratorContext decoratorContext : decoratorContexts) {
                decoratorList.add(decoratorContext.getText());
            }
        }
        return StringUtils.join(decoratorList  " ");
    },8,Minor Modification,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialAnnotation,@Override
    protected String getInitialAnnotation(PythonParser.FuncdefContext rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        RuleContext parent = rawMethod.getParent();
        if (parent instanceof PythonParser.Class_or_func_def_stmtContext) {
            List<PythonParser.DecoratorContext> decoratorContexts =
                    ((PythonParser.Class_or_func_def_stmtContext) parent).decorator();
            for (PythonParser.DecoratorContext decoratorContext : decoratorContexts) {
                decoratorList.add(decoratorContext.getText());
            }
        }
        return StringUtils.join(decoratorList  " ");
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialAnnotation,@Override
    protected String getInitialAnnotation(PythonParser.FuncdefContext rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        RuleContext parent = rawMethod.getParent();
        if (parent instanceof PythonParser.Class_or_func_def_stmtContext) {
            List<PythonParser.DecoratorContext> decoratorContexts =
                    ((PythonParser.Class_or_func_def_stmtContext) parent).decorator();
            for (PythonParser.DecoratorContext decoratorContext : decoratorContexts) {
                decoratorList.add(decoratorContext.getText());
            }
        }
        return StringUtils.join(decoratorList  " ");
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialAnnotation,@Override
    protected String getInitialAnnotation(PythonParser.FuncdefContext rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        RuleContext parent = rawMethod.getParent();
        if (parent instanceof PythonParser.Class_or_func_def_stmtContext) {
            List<PythonParser.DecoratorContext> decoratorContexts =
                    ((PythonParser.Class_or_func_def_stmtContext) parent).decorator();
            for (PythonParser.DecoratorContext decoratorContext : decoratorContexts) {
                decoratorList.add(decoratorContext.getText());
            }
        }
        return StringUtils.join(decoratorList  " ");
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialAnnotation,@Override
    protected String getInitialAnnotation(PythonParser.FuncdefContext rawMethod) {
        List<String> decoratorList = new ArrayList<>();
        RuleContext parent = rawMethod.getParent();
        if (parent instanceof PythonParser.Class_or_func_def_stmtContext) {
            List<PythonParser.DecoratorContext> decoratorContexts =
                    ((PythonParser.Class_or_func_def_stmtContext) parent).decorator();
            for (PythonParser.DecoratorContext decoratorContext : decoratorContexts) {
                decoratorList.add(decoratorContext.getText());
            }
        }
        return StringUtils.join(decoratorList  " ");
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialDoc,@Override
    protected String getInitialDoc(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialDoc,@Override
    protected String getInitialDoc(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialDoc,@Override
    protected String getInitialDoc(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialDoc,@Override
    protected String getInitialDoc(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialDoc,@Override
    protected String getInitialDoc(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialDoc,@Override
    protected String getInitialDoc(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialDoc,@Override
    protected String getInitialDoc(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,Annotation Change | Signature Change | Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialDoc,@Override
    protected String getInitialDoc(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialUnformattedBody,@Override
    protected String getInitialUnformattedBody(PythonParser.FuncdefContext rawMethod) {
        // TODO: implement function for python
        return null;
    },8,Annotation Change | Signature Change | Body Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(PythonParseTree.PythonParser.FuncdefContext function) {
        // Note: This will not work on lambdas
        int startWithDecorators;
        RuleContext parent = function.getParent();
        if (parent instanceof PythonParseTree.PythonParser.Class_or_func_def_stmtContext) {
            startWithDecorators = ((PythonParseTree.PythonParser.Class_or_func_def_stmtContext) parent).getStart().getLine();
        } else {
            startWithDecorators = getNameLineNumber();
        }
        String source = getSourceFileContent() + "\n<EOF>";
        // TODO remove trailing whitespace lines
        return Utl.getTextFragment(source  startWithDecorators  getEndLineNumber());
    },8,,fa7e150110c4c2ef7d99e6697442c0a1542e6ec7,Braxton Hall,Add in missing PythonFunction method (#53)  
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(PythonParseTree.PythonParser.FuncdefContext function) {
        // Note: This will not work on lambdas
        int startWithDecorators;
        RuleContext parent = function.getParent();
        if (parent instanceof PythonParseTree.PythonParser.Class_or_func_def_stmtContext) {
            startWithDecorators = ((PythonParseTree.PythonParser.Class_or_func_def_stmtContext) parent).getStart().getLine();
        } else {
            startWithDecorators = getNameLineNumber();
        }
        String source = getSourceFileContent() + "\n<EOF>";
        // TODO remove trailing whitespace lines
        return Utl.getTextFragment(source  startWithDecorators  getEndLineNumber());
    },8,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(PythonParseTree.PythonParser.FuncdefContext function) {
        // Note: This will not work on lambdas
        int startWithDecorators;
        RuleContext parent = function.getParent();
        if (parent instanceof PythonParseTree.PythonParser.Class_or_func_def_stmtContext) {
            startWithDecorators = ((PythonParseTree.PythonParser.Class_or_func_def_stmtContext) parent).getStart().getLine();
        } else {
            startWithDecorators = getNameLineNumber();
        }
        String source = getSourceFileContent() + "\n<EOF>";
        // TODO remove trailing whitespace lines
        return Utl.getTextFragment(source  startWithDecorators  getEndLineNumber());
    },8,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(PythonParseTree.PythonParser.FuncdefContext function) {
        // Note: This will not work on lambdas
        int startWithDecorators;
        RuleContext parent = function.getParent();
        if (parent instanceof PythonParseTree.PythonParser.Class_or_func_def_stmtContext) {
            startWithDecorators = ((PythonParseTree.PythonParser.Class_or_func_def_stmtContext) parent).getStart().getLine();
        } else {
            startWithDecorators = getNameLineNumber();
        }
        String source = getSourceFileContent() + "\n<EOF>";
        // TODO remove trailing whitespace lines
        return Utl.getTextFragment(source  startWithDecorators  getEndLineNumber());
    },8,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(PythonParseTree.PythonParser.FuncdefContext function) {
        // Note: This will not work on lambdas
        int startWithDecorators;
        RuleContext parent = function.getParent();
        if (parent instanceof PythonParseTree.PythonParser.Class_or_func_def_stmtContext) {
            startWithDecorators = ((PythonParseTree.PythonParser.Class_or_func_def_stmtContext) parent).getStart().getLine();
        } else {
            startWithDecorators = getNameLineNumber();
        }
        String source = getSourceFileContent() + "\n<EOF>";
        // TODO remove trailing whitespace lines
        return Utl.getTextFragment(source  startWithDecorators  getEndLineNumber());
    },8,Annotation Change | Signature Change | Body Change,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(PythonParseTree.PythonParser.FuncdefContext function) {
        // Note: This will not work on lambdas
        int startWithDecorators;
        RuleContext parent = function.getParent();
        if (parent instanceof PythonParseTree.PythonParser.Class_or_func_def_stmtContext) {
            startWithDecorators = ((PythonParseTree.PythonParser.Class_or_func_def_stmtContext) parent).getStart().getLine();
        } else {
            startWithDecorators = getNameLineNumber();
        }
        String source = getSourceFileContent() + "\n<EOF>";
        // TODO remove trailing whitespace lines
        return Utl.getTextFragment(source  startWithDecorators  getEndLineNumber());
    },8,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(PythonParseTree.PythonParser.FuncdefContext function) {
        // Note: This will not work on lambdas
        int startWithDecorators;
        RuleContext parent = function.getParent();
        if (parent instanceof PythonParseTree.PythonParser.Class_or_func_def_stmtContext) {
            startWithDecorators = ((PythonParseTree.PythonParser.Class_or_func_def_stmtContext) parent).getStart().getLine();
        } else {
            startWithDecorators = getNameLineNumber();
        }
        String source = getSourceFileContent() + "\n<EOF>";
        // TODO remove trailing whitespace lines
        return Utl.getTextFragment(source  startWithDecorators  getEndLineNumber());
    },8,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialSourceFragment,@Override
    protected String getInitialSourceFragment(PythonParseTree.PythonParser.FuncdefContext function) {
        // Note: This will not work on lambdas
        int startWithDecorators;
        RuleContext parent = function.getParent();
        if (parent instanceof PythonParseTree.PythonParser.Class_or_func_def_stmtContext) {
            startWithDecorators = ((PythonParseTree.PythonParser.Class_or_func_def_stmtContext) parent).getStart().getLine();
        } else {
            startWithDecorators = getNameLineNumber();
        }
        String source = getSourceFileContent() + "\n<EOF>";
        // TODO remove trailing whitespace lines
        return Utl.getTextFragment(source  startWithDecorators  getEndLineNumber());
    },8,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,Minor Modification,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
AbstractParser,public AbstractParser(StartEnvironment startEnv  String filePath  String fileContent  Commit commit) throws ParseException {
        this.startEnv = startEnv;

        this.filePath = filePath;
        this.fileContent = fileContent;
        this.commit = commit;
        this.allMethods = parseMethods();
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getScopeSimilarity,public abstract double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAcceptedFileExtension,public abstract String getAcceptedFileExtension();,29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,Signature Change,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
parseMethods,protected abstract List<Yfunction> parseMethods() throws ParseException;,29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Signature Change | Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getDocChange,protected Ydocchange getDocChange(Ycommit commit  Yfunction compareFunction) {
        Ydocchange ret = null;
        String docA = compareFunction.getFunctionDoc();
        String docB = commit.getMatchedFunction().getFunctionDoc();
        if(!docA.equals(docB)) {
            ret = new Ydocchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Signature Change | Body Change,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAnnotationChange,protected Yannotationchange getAnnotationChange(Ycommit commit  Yfunction compareFunction) {
        Yannotationchange ret = null;
        String annotationA = compareFunction.getAnnotation();
        String annotationB = commit.getMatchedFunction().getAnnotation();
        if (!annotationA.equals(annotationB)) {
            ret = new Yannotationchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFormatChange,protected Yformatchange getFormatChange(Ycommit commit  Yfunction compareFunction) {
        Yformatchange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (Utl.isFormatChange(function  compareFunction)) {
            ret = new Yformatchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Signature Change | Body Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getReturnTypeChange,protected Yreturntypechange getReturnTypeChange(Ycommit commit  Yfunction compareFunction) {
        Yreturntypechange ret = null;
        Yreturn returnA = compareFunction.getReturnStmt();
        Yreturn returnB = commit.getMatchedFunction().getReturnStmt();
        if (returnA != null && !returnA.equals(returnB)) {
            ret = new Yreturntypechange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionRename,protected Yrename getFunctionRename(Ycommit commit  Yfunction compareFunction) {
        Yrename ret = null;
        if (compareFunction != null) {
            if (!functionNamesConsideredEqual(commit.getMatchedFunction().getName()  compareFunction.getName())) {
                ret = new Yrename(this.startEnv  commit.getMatchedFunction()  compareFunction);
            }
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParametersChange,protected Yparameterchange getParametersChange(Ycommit commit  Yfunction compareFunction) {
        Yparameterchange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!parametersA.equals(parametersB)) {
            ret = new Yparameterchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Signature Change | Body Change,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParametersMetaChange,protected Yparametermetachange getParametersMetaChange(Ycommit commit  Yfunction compareFunction) {
        Yparametermetachange ret = null;
        List<Yparameter> parametersA = compareFunction.getParameters();
        List<Yparameter> parametersB = commit.getMatchedFunction().getParameters();
        if (!Utl.parametersMetadataEqual(parametersA  parametersB)) {
            ret = new Yparametermetachange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getExceptionsChange,protected Yexceptionschange getExceptionsChange(Ycommit commit  Yfunction compareFunction) {
        Yexceptionschange ret = null;
        Yexceptions exceptionsA = compareFunction.getExceptions();
        Yexceptions exceptionsB = commit.getMatchedFunction().getExceptions();
        if (exceptionsA != null && !exceptionsA.equals(exceptionsB)) {
            ret = new Yexceptionschange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getModifiersChange,protected Ymodifierchange getModifiersChange(Ycommit commit  Yfunction compareFunction) {
        Ymodifierchange ret = null;
        Ymodifiers modifiersA = compareFunction.getModifiers();
        Ymodifiers modifiersB = commit.getMatchedFunction().getModifiers();
        if (modifiersA != null && !modifiersA.equals(modifiersB)) {
            ret = new Ymodifierchange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getBodyChange,protected Ybodychange getBodyChange(Ycommit commit  Yfunction compareFunction) {
        Ybodychange ret = null;
        Yfunction function = commit.getMatchedFunction();
        if (function != null && compareFunction != null && !function.getBody().equals(compareFunction.getBody())) {
            ret = new Ybodychange(this.startEnv  commit.getMatchedFunction()  compareFunction);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,Annotation Change | Signature Change | Body Change,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMinorChanges,@Override
    public List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ychange> changes = new ArrayList<>();
        Ybodychange ybodychange = getBodyChange(commit  compareFunction);
        if (ybodychange != null) {
            changes.add(ybodychange);
        }
        return changes;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,Annotation Change | Signature Change | Body Change,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,Minor Modification,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMajorChanges,@Override
    public List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) {
        List<Ysignaturechange> changes = new ArrayList<>();
        Yparameterchange yparameterchange = getParametersChange(commit  compareFunction);
        Yrename yinfilerename = getFunctionRename(commit  compareFunction);
        if (yinfilerename != null) {
            changes.add(yinfilerename);
        }
        if (yparameterchange != null) {
            changes.add(yparameterchange);
        }
        return changes;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Minor Modification,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Minor Modification,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Minor Modification,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Parameter Change,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Minor Modification,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Minor Modification,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Minor Modification,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Minor Modification,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Signature Change | Body Change,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Signature Change | Body Change,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,Body Change,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getMostSimilarFunction,/**
     * Finds the most similar function to compareFunction from a list of candidates.
     * <p>
     * This is used by both:
     * CrossFileInterpreter
     * InFileInterpreter
     * <p>
     * Making two copies of this function  one for cross-file and one for
     * within-file would make the code simpler to understand  but might
     * cause challenges when updating in the future when changes need to be
     * made to both.
     *
     * @param candidates      Set of candidate methods
     * @param compareFunction Similar method
     * @param crossFile       True if other files in commit should be searched  false if only in-file
     * @return a match  if one is made  otherwise null
     */
    @Override
    public Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile) {
        log.trace("Trying to find most similar function");
        final double EXACT_MATCH = 1;

        Map<Yfunction  FunctionSimilarity> similarities = new HashMap<>();
        Map<String  Yfunction> functionSignatureMap = Utl.functionsToIdMap(candidates);

        // Phase 1
        // First look for a similar match with the same (exact) signature
        Yfunction sameSignatureFunction = functionSignatureMap.get(compareFunction.getId());
        if (sameSignatureFunction != null) {
            // If we are in-file just return because the signature will exist only once.
            // If we are cross-file  take bodySimilarity as an additional measure.
            if (crossFile == false) {
                log.trace("Matched same sig within file.");
                return sameSignatureFunction;
            } else {
                // use body similarity  not function similarity as the signature is already known to be identical
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  sameSignatureFunction);
                if (isFunctionSimilar(compareFunction  sameSignatureFunction  bodySimilarity)) {
                    log.trace("Matched same sig cross file.");
                    return sameSignatureFunction;
                }
            }
        }

        // Phase 2
        // Next  look for candidates that have extremely similar bodies
        if (crossFile == false) {
            // If the body is identical  assume it the same method
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                if (bodySimilarity == EXACT_MATCH) {
                    log.trace("Matched same body within file.");
                    return candidate;
                }
            }
        } else {
            // If the body and scope are similar
            for (Yfunction candidate : candidates) {
                double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
                double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
                // If the body is identical -or-
                // The scope is identical and the body is very close
                if (bodySimilarity == EXACT_MATCH ||
                        (bodySimilarity > Thresholds.MOST_SIM_FUNCTION_MAX.val() &&  // BODY_SIM_THRESHOLD
                                scopeSimilarity == EXACT_MATCH)) {
                    log.trace("Matched extremely similar body cross file.");
                    return candidate;
                }
            }
        }

        // Generate similarity scores for all candidates
        // Identify functions with the same name
        // (but maybe not with the same full signature)
        List<Yfunction> candidatesWithSameName = new ArrayList<>();
        for (Yfunction candidate : candidates) {
            if (candidate.getName().equals(compareFunction.getName())) {
                candidatesWithSameName.add(candidate);
            }

            double bodySimilarity = Utl.getBodySimilarity(compareFunction  candidate);
            double scopeSimilarity = getScopeSimilarity(compareFunction  candidate);
            double nameSimilarity = Utl.getNameSimilarity(compareFunction  candidate);

            FunctionSimilarity similarity = new FunctionSimilarity(crossFile);
            similarity.setBodySimilarity(bodySimilarity);
            similarity.setScopeSimilarity(scopeSimilarity);
            similarity.setNameSimilarity(nameSimilarity);
            if (crossFile == false) {
                // line number similarity does not make sense cross-file
                double lineNumberSimilarity = Utl.getLineNumberSimilarity(candidate  compareFunction);
                similarity.setLineNumberSimilarity(lineNumberSimilarity);
            }
            similarities.put(candidate  similarity);
        }

        // Phase 3
        // If a function does have the same name  consider it ahead of other matches
        if (candidatesWithSameName.size() > 0) {
            // prepopulate with first option
            Yfunction highestCandidate = candidatesWithSameName.get(0);
            FunctionSimilarity highestSimilarity = similarities.get(highestCandidate);

            // if there are candidates with the same name  take the best
            for (Yfunction candidate : candidatesWithSameName) {
                FunctionSimilarity similarity = similarities.get(candidate);
                if (similarity.getOverallSimilarity() > highestSimilarity.getOverallSimilarity()) {
                    highestSimilarity = similarity;
                    highestCandidate = candidate;
                }
            }

            // TODO: Function name matching could be much stronger:
            // Could use parameters  param types  return type  etc.
            // Easiest way would be to build them into FunctionSimilarity
            // so that getOverallSimilarity would consider them.

            if (crossFile == false) {
                // Within-file similarity can be less strict
                if (highestSimilarity.getOverallSimilarity() > Thresholds.BODY_SIM_WITHIN_FILE.val()) {
                    log.trace("Matched most similar function within file.");
                    return highestCandidate;
                }
            } else {
                // Cross-file similarity is more strict
                // as it's much more likely that a method with the same
                // name was removed that is completely independent.
                if (highestSimilarity.getBodySimilarity() > Thresholds.BODY_SIM_CROSS_FILE.val()) {
                    log.trace("Matched most similar function cross file.");
                    return highestCandidate;
                }
            }
        }

        // Phase 4: Find the most similar function
        // Does not have cross-file dependencies because this is handled
        // by FunctionSimilarity::computeOverallSimilarity()
        Yfunction mostSimilarFunction = null;
        double mostSimilarFunctionSimilarity = -1;
        for (Yfunction candidate : similarities.keySet()) {
            FunctionSimilarity similarity = similarities.get(candidate);

            double overallSimilarity = similarity.getOverallSimilarity();
            if (overallSimilarity > mostSimilarFunctionSimilarity) {
                mostSimilarFunctionSimilarity = overallSimilarity;
                mostSimilarFunction = candidate;
            }
        }

        FunctionSimilarity similarity = similarities.get(mostSimilarFunction);
        // log.trace("Highest similarity with overall similarity of {}"  similarity);

        // Write logs  if requested
        if (GlobalEnv.WRITE_SIMILARITIES && mostSimilarFunction != null) {
            Utl.writeJsonSimilarity(this.repositoryName  this.filePath 
                    compareFunction  mostSimilarFunction  similarity);
        }

        // Finally  see if the best-matched function that remains is close enough
        // Use Overall similarity  not body similarity
        if (mostSimilarFunction != null) {
            if (isFunctionSimilar(compareFunction  mostSimilarFunction  mostSimilarFunctionSimilarity)) {
                log.trace("Matched close enough function.");
                return mostSimilarFunction;
            }
        }

        log.trace("Failed to match.");
        return null;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,Signature Change | Body Change,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,Body Change,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
isFunctionSimilar,private boolean isFunctionSimilar(Yfunction compareFcn  Yfunction candidateFcn  double simScore) {
        if (compareFcn == null || candidateFcn == null) {
            return false;
        }
        if (isShortFunction(compareFcn  candidateFcn)) {
            // be more strict because small functions are
            // more prone to spurious matches
            if (simScore > Thresholds.MOST_SIM_FUNCTION_MAX.val()) {
                return true;
            }
        } else {
            // initial threshold check is sufficient for long functions
            if (simScore > Thresholds.MOST_SIM_FUNCTION.val()) {
                return true;
            }
        }
        return false;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,Signature Change | Body Change,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
isShortFunction,private boolean isShortFunction(Yfunction aFunction  Yfunction bFunction) {
        String aBody = aFunction.getBody();
        String bBody = bFunction.getBody();

        return aBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val() ||
                bBody.length() < Thresholds.LONG_METHOD_CHAR_THRESHOLD.val();
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,Signature Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAllMethodsCount,@Override
    public Map<String  Yfunction> getAllMethodsCount() {
        return transformMethodsToMap(getAllMethods());
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,Signature Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAllMethods,@Override
    public List<Yfunction> getAllMethods() {
        return this.allMethods;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,Annotation Change | Modifier Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,Signature Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
functionNamesConsideredEqual,@Override
    public boolean functionNamesConsideredEqual(String aName  String bName) {
        return aName != null && aName.equals(bName);
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
transformMethodsToMap,protected Map<String  Yfunction> transformMethodsToMap(List<Yfunction> methods) {
        Map<String  Yfunction> ret = new HashMap<>();
        for (Yfunction method : methods) {
            ret.put(method.getId()  method);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
findMethodsByLineRange,@Override
    public List<Yfunction> findMethodsByLineRange(int beginLine  int endLine) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            }
        });
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                int lineNumber = method.getNameLineNumber();
                return lineNumber >= beginLine && lineNumber <= endLine;
            },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
findAllMethods,protected List<Yfunction> findAllMethods(MethodVisitor visitor) {
        List<Yfunction> matchedMethods = new ArrayList<>();
        for (Yfunction method : this.allMethods) {
            if (visitor.methodMatches(method)) {
                matchedMethods.add(method);
            }
        }
        return matchedMethods;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
findMethod,private Yfunction findMethod(MethodVisitor visitor) {
        Yfunction ret = null;
        List<Yfunction> matchedNodes = findAllMethods(visitor);
        if (matchedNodes.size() > 0) {
            ret = matchedNodes.get(0);
        }
        return ret;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
findFunctionByNameAndLine,@Override
    public Yfunction findFunctionByNameAndLine(String name  int line) {
        return findMethod(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            }
        });
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                String methodName = method.getName();
                int methodLineNumber = method.getNameLineNumber();
                return name.equals(methodName) && line == methodLineNumber;
            },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,Signature Change | Body Change,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCandidateWithSameParent,private Yfunction getCandidateWithSameParent(List<Yfunction> candidates  Yfunction compareMethod) {
        for (Yfunction candidateMethod : candidates) {
            if (candidateMethod.getParentName() != null && candidateMethod.getParentName().equals(compareMethod.getParentName())) {
                log.trace("Found correct candidate. Parent name: {}"  candidateMethod.getParentName());
                return candidateMethod;
            }
        }
        return null;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,Annotation Change | Signature Change | Body Change,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
findFunctionByOtherFunction,@Override
    public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {
        Yfunction function = null;
        List<Yfunction> candidatesByNameAndParams = findFunctionsByNameAndParams(otherMethod);
        if (candidatesByNameAndParams.size() == 1) {
            function = candidatesByNameAndParams.get(0);
        } else if (candidatesByNameAndParams.size() > 1) {
            log.trace("Found more than one matches for name and parameters. Finding candidate with highest body similarity");
            function = getMostSimilarFunction(candidatesByNameAndParams  otherMethod  false);
        }

        return function;
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,Signature Change | Body Change,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
findFunctionsByNameAndParams,private List<Yfunction> findFunctionsByNameAndParams(Yfunction otherFunction) {
        return findAllMethods(new MethodVisitor(this.allMethods) {
            @Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            }
        });
    },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,fa9848601d9a5de07813d841c9989a901c59fb07,Felix Grund,Moved getMajorChanges up into AbstractParser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,1c89ee62dea633ad3323d523e3ad8febbf355d33,Felix Grund,Improved similarity algorithm if there is only one candidate with the same name among removed functions. Created stubs for flink repository and got JUnit framework to run again. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,c1aac955d6b36bbf5e6eba91184707af6e08728e,Felix Grund,different fixes and improvements and more stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6,Felix Grund,minor tweak on similarity algorithms and more stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,170dbff31d185708df26634f977bdc69180493f4,Felix Grund,Revert "minor tweak on similarity algorithms and more stubs"  This reverts commit 6ea1cb8c957d6ea11a4de86beda4f34bfc4b73b6. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,b714ac75d5e94d8d1f654678b007942b1ce41f50,Felix Grund,Revert "different fixes and improvements and more stubs"  This reverts commit c1aac955d6b36bbf5e6eba91184707af6e08728e. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,4549947a4b5637378e6641cc0810fd2f741bacea,Felix Grund,More refactoring 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,0ba182df0560475861f1844648eeed8a82b43dc8,Felix Grund,Refactoring of AbstractParsers and individual parsers; created EVAL.md 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,Signature Change | Body Change,6a9967e7a785105d593f80f4316a17b757e19759,Reid Holmes,see #47 pull out constants into specific Thresholds class. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,2a73090df4d4785b16fbdcb378f293a15ebb1815,Reid Holmes,see #47; pull out alg thresholds into single file for better reference and easier modification. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,1ae0c869d879b462fb2cee6e9fad985b99e19e4a,Reid Holmes,see #47 Significant cleanup of core similarity matcher (AbstractParser::getMostSimilarFunction). Fixed several edge cases that were working by chance  improve robusness (e.g.  if multiple functions have the same name  don't take the first one but the best one). Improve docs and code flow. Will still need to take another pass to better match with the paper  but this is easier to read for sure. No performance improvement (aka returns the exact same result as the ICSE 2021 paper). 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,80cc1e03ee245777de9f7a987cae5a1137d49179,Reid Holmes,see #47 Add documentation to classes so people can actually figure out how to get started. 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,f80dc6f58b56d8d9d495cffa0b094b9136bf794b,Reid Holmes,see #47 more simplification in abstract parser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,1c5d324c39459851e54174892bdf5ca4ef932e98,Reid Holmes,see #47 add more meaningful output for matches in abstractparser 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,df01e3107b60b7d345e1d06803f967b04af627bd,Reid Holmes,see #47 add phase indicators 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,dc75fa4bbe336ff9aed725548ae1b249dc17a00b,braxtonhall,Add annotation change 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
methodMatches,@Override
            public boolean methodMatches(Yfunction method) {
                List<Yparameter> parametersCurrent = method.getParameters();
                String functionNameCurrent = method.getName();
                boolean nameMatches = functionNamesConsideredEqual(functionNameCurrent  otherFunction.getName());
                boolean paramsMatch = parametersCurrent.equals(otherFunction.getParameters());
                return nameMatches && paramsMatch;
            },29,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
findFunctionByNameAndLine,/**
	 * Find a method by the given name and line number
	 * @param name Method name
	 * @param line Line number
	 * @return Method if found  null otherwise
	 */
	Yfunction findFunctionByNameAndLine(String name  int line);,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findFunctionByNameAndLine,/**
	 * Find a method by the given name and line number
	 * @param name Method name
	 * @param line Line number
	 * @return Method if found  null otherwise
	 */
	Yfunction findFunctionByNameAndLine(String name  int line);,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findFunctionByNameAndLine,/**
	 * Find a method by the given name and line number
	 * @param name Method name
	 * @param line Line number
	 * @return Method if found  null otherwise
	 */
	Yfunction findFunctionByNameAndLine(String name  int line);,4,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findFunctionByNameAndLine,/**
	 * Find a method by the given name and line number
	 * @param name Method name
	 * @param line Line number
	 * @return Method if found  null otherwise
	 */
	Yfunction findFunctionByNameAndLine(String name  int line);,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
findMethodsByLineRange,/**
	 * Find a method using the given line range
	 * @param beginLine Start line of the line range
	 * @param endLine End line of the line range
	 * @return Method if found  null otherwise
	 */
	List<Yfunction> findMethodsByLineRange(int beginLine  int endLine);,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findMethodsByLineRange,/**
	 * Find a method using the given line range
	 * @param beginLine Start line of the line range
	 * @param endLine End line of the line range
	 * @return Method if found  null otherwise
	 */
	List<Yfunction> findMethodsByLineRange(int beginLine  int endLine);,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findMethodsByLineRange,/**
	 * Find a method using the given line range
	 * @param beginLine Start line of the line range
	 * @param endLine End line of the line range
	 * @return Method if found  null otherwise
	 */
	List<Yfunction> findMethodsByLineRange(int beginLine  int endLine);,4,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findMethodsByLineRange,/**
	 * Find a method using the given line range
	 * @param beginLine Start line of the line range
	 * @param endLine End line of the line range
	 * @return Method if found  null otherwise
	 */
	List<Yfunction> findMethodsByLineRange(int beginLine  int endLine);,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getAllMethods,/**
	 * @return All methods in this file
	 */
	List<Yfunction> getAllMethods();,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getAllMethods,/**
	 * @return All methods in this file
	 */
	List<Yfunction> getAllMethods();,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getAllMethods,/**
	 * @return All methods in this file
	 */
	List<Yfunction> getAllMethods();,4,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAllMethods,/**
	 * @return All methods in this file
	 */
	List<Yfunction> getAllMethods();,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getAllMethodsCount,/**
	 * @return A mapping MethodName => Method for all methods in this file
	 */
	Map<String  Yfunction> getAllMethodsCount();,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getAllMethodsCount,/**
	 * @return A mapping MethodName => Method for all methods in this file
	 */
	Map<String  Yfunction> getAllMethodsCount();,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getAllMethodsCount,/**
	 * @return A mapping MethodName => Method for all methods in this file
	 */
	Map<String  Yfunction> getAllMethodsCount();,4,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAllMethodsCount,/**
	 * @return A mapping MethodName => Method for all methods in this file
	 */
	Map<String  Yfunction> getAllMethodsCount();,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
findFunctionByOtherFunction,/**
	 * Find a method that is similar to the given other method
	 * @param otherFunction The similar method
	 * @return Method if found  null otherwise
	 */
	Yfunction findFunctionByOtherFunction(Yfunction otherFunction);,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
findFunctionByOtherFunction,/**
	 * Find a method that is similar to the given other method
	 * @param otherFunction The similar method
	 * @return Method if found  null otherwise
	 */
	Yfunction findFunctionByOtherFunction(Yfunction otherFunction);,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
findFunctionByOtherFunction,/**
	 * Find a method that is similar to the given other method
	 * @param otherFunction The similar method
	 * @return Method if found  null otherwise
	 */
	Yfunction findFunctionByOtherFunction(Yfunction otherFunction);,4,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
findFunctionByOtherFunction,/**
	 * Find a method that is similar to the given other method
	 * @param otherFunction The similar method
	 * @return Method if found  null otherwise
	 */
	Yfunction findFunctionByOtherFunction(Yfunction otherFunction);,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
functionNamesConsideredEqual,/**
	 * Check if the given method names are equal (i.e. == in most languages or .equals in others)
	 * @param aName First method name
	 * @param bName Second method name
	 * @return True if method names are equal  false otherwise
	 */
	boolean functionNamesConsideredEqual(String aName  String bName);,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
functionNamesConsideredEqual,/**
	 * Check if the given method names are equal (i.e. == in most languages or .equals in others)
	 * @param aName First method name
	 * @param bName Second method name
	 * @return True if method names are equal  false otherwise
	 */
	boolean functionNamesConsideredEqual(String aName  String bName);,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
functionNamesConsideredEqual,/**
	 * Check if the given method names are equal (i.e. == in most languages or .equals in others)
	 * @param aName First method name
	 * @param bName Second method name
	 * @return True if method names are equal  false otherwise
	 */
	boolean functionNamesConsideredEqual(String aName  String bName);,4,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
functionNamesConsideredEqual,/**
	 * Check if the given method names are equal (i.e. == in most languages or .equals in others)
	 * @param aName First method name
	 * @param bName Second method name
	 * @return True if method names are equal  false otherwise
	 */
	boolean functionNamesConsideredEqual(String aName  String bName);,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getMostSimilarFunction,/**
	 * Find the most similar method as the given compareFunction in the given set of candidate methods
	 * @param candidates Set of candidate methods
	 * @param compareFunction Similar method
	 * @param crossFile True if other files in commit should be searched  false if only in-file
	 * @return Similar method if found  null otherwise
	 */
	Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile);,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getMostSimilarFunction,/**
	 * Find the most similar method as the given compareFunction in the given set of candidate methods
	 * @param candidates Set of candidate methods
	 * @param compareFunction Similar method
	 * @param crossFile True if other files in commit should be searched  false if only in-file
	 * @return Similar method if found  null otherwise
	 */
	Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile);,4,Parameter Change,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getMostSimilarFunction,/**
	 * Find the most similar method as the given compareFunction in the given set of candidate methods
	 * @param candidates Set of candidate methods
	 * @param compareFunction Similar method
	 * @param crossFile True if other files in commit should be searched  false if only in-file
	 * @return Similar method if found  null otherwise
	 */
	Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile);,4,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getMostSimilarFunction,/**
	 * Find the most similar method as the given compareFunction in the given set of candidate methods
	 * @param candidates Set of candidate methods
	 * @param compareFunction Similar method
	 * @param crossFile True if other files in commit should be searched  false if only in-file
	 * @return Similar method if found  null otherwise
	 */
	Yfunction getMostSimilarFunction(List<Yfunction> candidates  Yfunction compareFunction  boolean crossFile);,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getScopeSimilarity,/**
	 * @param function Method 1
	 * @param compareFunction Method 2
	 * @return Number between 0 and 1 for the similarity of the scope of the two given methods
	 */
	double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getScopeSimilarity,/**
	 * @param function Method 1
	 * @param compareFunction Method 2
	 * @return Number between 0 and 1 for the similarity of the scope of the two given methods
	 */
	double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getScopeSimilarity,/**
	 * @param function Method 1
	 * @param compareFunction Method 2
	 * @return Number between 0 and 1 for the similarity of the scope of the two given methods
	 */
	double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,4,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getScopeSimilarity,/**
	 * @param function Method 1
	 * @param compareFunction Method 2
	 * @return Number between 0 and 1 for the similarity of the scope of the two given methods
	 */
	double getScopeSimilarity(Yfunction function  Yfunction compareFunction);,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getMajorChanges,/**
	 * Retrieves the set of "major changes" (i.e. all derivates of Ysignaturechange as of now) for the given commit
	 * and method.
	 * @param commit Commit
	 * @param compareFunction Method
	 * @return Set of major changes
	 * @throws Exception
	 */
	List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) throws Exception;,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getMajorChanges,/**
	 * Retrieves the set of "major changes" (i.e. all derivates of Ysignaturechange as of now) for the given commit
	 * and method.
	 * @param commit Commit
	 * @param compareFunction Method
	 * @return Set of major changes
	 * @throws Exception
	 */
	List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) throws Exception;,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getMajorChanges,/**
	 * Retrieves the set of "major changes" (i.e. all derivates of Ysignaturechange as of now) for the given commit
	 * and method.
	 * @param commit Commit
	 * @param compareFunction Method
	 * @return Set of major changes
	 * @throws Exception
	 */
	List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) throws Exception;,4,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getMajorChanges,/**
	 * Retrieves the set of "major changes" (i.e. all derivates of Ysignaturechange as of now) for the given commit
	 * and method.
	 * @param commit Commit
	 * @param compareFunction Method
	 * @return Set of major changes
	 * @throws Exception
	 */
	List<Ysignaturechange> getMajorChanges(Ycommit commit  Yfunction compareFunction) throws Exception;,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getMinorChanges,/**
	 * Retrieves the set of "minor changes" (i.e. all changes that are NOT derivates of Ysignaturechange as of now)
	 * for the given commit and method.
	 * @param commit Commit
	 * @param compareFunction Method
	 * @return Set of minor changes
	 * @throws Exception
	 */
	List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) throws Exception;,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getMinorChanges,/**
	 * Retrieves the set of "minor changes" (i.e. all changes that are NOT derivates of Ysignaturechange as of now)
	 * for the given commit and method.
	 * @param commit Commit
	 * @param compareFunction Method
	 * @return Set of minor changes
	 * @throws Exception
	 */
	List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) throws Exception;,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getMinorChanges,/**
	 * Retrieves the set of "minor changes" (i.e. all changes that are NOT derivates of Ysignaturechange as of now)
	 * for the given commit and method.
	 * @param commit Commit
	 * @param compareFunction Method
	 * @return Set of minor changes
	 * @throws Exception
	 */
	List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) throws Exception;,4,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getMinorChanges,/**
	 * Retrieves the set of "minor changes" (i.e. all changes that are NOT derivates of Ysignaturechange as of now)
	 * for the given commit and method.
	 * @param commit Commit
	 * @param compareFunction Method
	 * @return Set of minor changes
	 * @throws Exception
	 */
	List<Ychange> getMinorChanges(Ycommit commit  Yfunction compareFunction) throws Exception;,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getAcceptedFileExtension,/**
	 * @return The accepted file extension for this language as string (e.g. ".js"  ".java")
	 */
	String getAcceptedFileExtension();,4,,d0326e5e302787f00ab03540b4b84cf69077c371,Felix Grund,whole range of bugfixes 
getAcceptedFileExtension,/**
	 * @return The accepted file extension for this language as string (e.g. ".js"  ".java")
	 */
	String getAcceptedFileExtension();,4,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getAcceptedFileExtension,/**
	 * @return The accepted file extension for this language as string (e.g. ".js"  ".java")
	 */
	String getAcceptedFileExtension();,4,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAcceptedFileExtension,/**
	 * @return The accepted file extension for this language as string (e.g. ".js"  ".java")
	 */
	String getAcceptedFileExtension();,4,Signature Change,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialName,protected abstract String getInitialName(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialType,protected abstract String getInitialType(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialModifiers,protected abstract Ymodifiers getInitialModifiers(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialExceptions,protected abstract Yexceptions getInitialExceptions(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialParameters,protected abstract List<Yparameter> getInitialParameters(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialBody,protected abstract String getInitialBody(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialBeginLine,protected abstract int getInitialBeginLine(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialEndLine,protected abstract int getInitialEndLine(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialParentName,protected abstract String getInitialParentName(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialFunctionPath,protected abstract String getInitialFunctionPath(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,Signature Change,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialAnnotation,protected abstract String getInitialAnnotation(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,Signature Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialDoc,protected abstract String getInitialDoc(E rawMethod);,16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialUnformattedBody,protected abstract String getInitialUnformattedBody(E rawMethod);,16,Signature Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Parameter Change | Signature Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Parameter Change | Signature Change | Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Parameter Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Minor Modification,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Minor Modification,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Minor Modification,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Minor Modification,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Minor Modification,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Minor Modification,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
AbstractFunction,public AbstractFunction(E rawMethod  Commit commit  String sourceFilePath  String sourceFileContent) {
		this.commit = commit;
		this.sourceFilePath = sourceFilePath;
		this.sourceFileContent = sourceFileContent;

		// Assign all the values in sequence.
		// NOTE: the order of these calls does matter!
		this.name = getInitialName(rawMethod);
		this.parameters = getInitialParameters(rawMethod);
		this.parentName = getInitialParentName(rawMethod);
		this.id = getInitialId(rawMethod);
		this.type = getInitialType(rawMethod);
		this.modifiers = getInitialModifiers(rawMethod);
		this.exceptions = getInitialExceptions(rawMethod);
		this.body = getInitialBody(rawMethod);
		this.beginLine = getInitialBeginLine(rawMethod);
		this.endLine = getInitialEndLine(rawMethod);
		this.functionPath = getInitialFunctionPath(rawMethod);
		this.returnStmt = getInitialReturnStmt(rawMethod); // Must be called after getInitialType
		this.annotation = getInitialAnnotation(rawMethod);
		this.functionDoc = getInitialDoc(rawMethod);
		this.unformattedBody = getInitialUnformattedBody(rawMethod);
		this.sourceFragment = getInitialSourceFragment(rawMethod); // Must be called after begin/endLine
	},16,Minor Modification,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,Body Change,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,Modifier Change | Signature Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,Modifier Change | Signature Change,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getIdParameterString,protected String getIdParameterString() {
		List<String> parts = new ArrayList<>();
		for (Yparameter parameter : getParameters()) {
			parts.add(parameter.toString());
		}
		return StringUtils.join(parts  "__");
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,Body Change,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,Modifier Change | Signature Change | Body Change,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,Modifier Change | Signature Change | Body Change,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialId,protected String getInitialId(E rawMethod) {
		String ident = getParentName() + "#" + getName();
		String idParameterString = this.getIdParameterString();
		if (StringUtils.isNotBlank(idParameterString)) {
			ident += "___" + idParameterString;
		}
		return Utl.sanitizeFunctionId(ident);
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialReturnStmt,protected Yreturn getInitialReturnStmt(E rawMethod) {
		if (this.type == null) {
			return Yreturn.NONE;
		} else {
			return new Yreturn(this.type);
		}
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,Signature Change | Body Change,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getInitialSourceFragment,protected String getInitialSourceFragment(E rawMethod) {
		// Naive implementation
		// Will not work if there is more than one function on a line
		int beginLine = getNameLineNumber();
		int endLine = getEndLineNumber();
		String source = getSourceFileContent();
		return Utl.getTextFragment(source  beginLine  endLine);
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getId,@Override
	public String getId() {
		return this.id;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getId,@Override
	public String getId() {
		return this.id;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getId,@Override
	public String getId() {
		return this.id;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getId,@Override
	public String getId() {
		return this.id;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getId,@Override
	public String getId() {
		return this.id;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getId,@Override
	public String getId() {
		return this.id;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getId,@Override
	public String getId() {
		return this.id;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getId,@Override
	public String getId() {
		return this.id;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getId,@Override
	public String getId() {
		return this.id;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getId,@Override
	public String getId() {
		return this.id;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getId,@Override
	public String getId() {
		return this.id;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getId,@Override
	public String getId() {
		return this.id;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getId,@Override
	public String getId() {
		return this.id;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getId,@Override
	public String getId() {
		return this.id;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getId,@Override
	public String getId() {
		return this.id;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getId,@Override
	public String getId() {
		return this.id;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,Annotation Change | Signature Change | Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,Body Change,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getSourceFragment,@Override
	public String getSourceFragment() {
		return this.sourceFragment;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCommitName,@Override
	public String getCommitName() {
		return this.commit.getName();
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCommitNameShort,@Override
	public String getCommitNameShort() {
		return this.commit.getName().substring(0  6);
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getSourceFilePath,@Override
	public String getSourceFilePath() {
		return sourceFilePath;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getSourceFileContent,@Override
	public String getSourceFileContent() {
		return sourceFileContent;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
toString,@Override
	public String toString() {
		return getClass().getSimpleName() + ":" + getId();
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getCommit,@Override
	public Commit getCommit() {
		return commit;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionPath,@Override
	public String getFunctionPath() {
		return this.functionPath;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParentName,@Override
	public String getParentName() {
		return this.parentName;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getName,@Override
	public String getName() {
		return this.name;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getName,@Override
	public String getName() {
		return this.name;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getName,@Override
	public String getName() {
		return this.name;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getName,@Override
	public String getName() {
		return this.name;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getName,@Override
	public String getName() {
		return this.name;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getName,@Override
	public String getName() {
		return this.name;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getName,@Override
	public String getName() {
		return this.name;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getName,@Override
	public String getName() {
		return this.name;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getName,@Override
	public String getName() {
		return this.name;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getName,@Override
	public String getName() {
		return this.name;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getName,@Override
	public String getName() {
		return this.name;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getName,@Override
	public String getName() {
		return this.name;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getName,@Override
	public String getName() {
		return this.name;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getName,@Override
	public String getName() {
		return this.name;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getName,@Override
	public String getName() {
		return this.name;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getName,@Override
	public String getName() {
		return this.name;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getReturnStmt,@Override
	public Yreturn getReturnStmt() {
		return this.returnStmt;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getModifiers,@Override
	public Ymodifiers getModifiers() {
		return this.modifiers;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getExceptions,@Override
	public Yexceptions getExceptions() {
		return this.exceptions;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getBody,@Override
	public String getBody() {
		return this.body;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getParameters,@Override
	public List<Yparameter> getParameters() {
		return this.parameters;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getNameLineNumber,@Override
	public int getNameLineNumber() {
		return this.beginLine;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,Annotation Change | Signature Change | Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getEndLineNumber,@Override
	public int getEndLineNumber() {
		return this.endLine;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,Annotation Change | Signature Change | Body Change,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,Minor Modification,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getAnnotation,@Override
	public String getAnnotation() {
		return this.annotation;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,Annotation Change | Signature Change | Body Change,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionDoc,@Override
	public String getFunctionDoc() {
		return this.functionDoc;
	},16,,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,c68b0d741224ad0973a77d178ac04f2ed0338de4,Felix Grund,More readme and documentation 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,c0491a1192bd4704243e1ac96bae14e94f14d634,fgrund,Fix issue with nested class methods resulting in identical IDs with outer methods 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,f14be5c97a99fdbc4937e35653bad8baa6c99d53,fgrund,Make function ID not include parent name but only start with '$' if it's a nested method 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,c4fb687ea873762c4b2d71ce78e4f21a48384b10,braxtonhall,Add decorators for Python 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,0a200c86a673270474a2285bf78df36449b3cb8a,Braxton Hall,Typescript (#54)  * Python impl (#20)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Started parsing python  * Add first python test  * Regenerated Python Antlr files  * naive impl of PythonParser/Function  * Add asciinema tests  * Added public python tensorflow tests  * complete models and django tests  * Update Z_asciinema-term-read_blocking.json  * PythonParser::parseMethods thows  * Simplified test edge cases  * Remove whitespace/comment changes from tests  * Switch to general Python parser  * Made tests optional  added python returntype test  * Type hints and return types impl  * Disregard annotation changes  * Add parametermetachange to python  * Fix bad flask test  * Also visit nested function definitions  * Lambda function tests  OK I'm not really sure about lambdas  are you can have more than one on the same line  * make accepted file extensions regexes  * Return correct endline  * C impl (#21)  * Naive implementation of C parser  * Get rid of generated code  * Support parameters with no name  * support *args and **kwargs  * replace all external code with mvn commands  * Update .gitignore  * Update pom.xml  * Added Python tests  * Update PythonFunction comments  * Add tests  * Flask * Rebound * Keras * Pandas  * Get parent name properly  * Update Z_scikit-learn-_search-__getitem__.json  * Start TypeScript Function impl  * Use node typescript parser  * Use name of TypeScript file when parsing  * Implement TypeScript function transformers  * Remove some memory leaks  * Update typescript change types  * Add modifier change to python  * Use Yexceptions.NONE for TypeScript  * Momve node_modules to resources  * Add parentName to Typescript  * Add functionPath for TypeScript  * update TODO  * Remove duplicate code in pom from merge  * Ensure resource loading works in jar  * Attempt to suppress runtime errors in linux  * Move NodeJS creation  To fix a thread issue  * Attempt to fix threading issue with typescript import  * NodeJS shouldn't be released while in use  * Use class loader  * Add some logging for debugging  * Use getClassLoader again  * Try to make TypeScript visitor thread safe  * Each TypeScript visitor gets its own V8 runtime  * Remove dead code  * Use built in getText instead of bad substrings  * Add in missing PythonFunction method  * Remove unused C tests  * Refactor TypeScript and Visitor  * Restore accidentally deleted functionality  * Restore TypeScriptFunction performance  * Delete useless code  * Restore missing file  * Add TypeScript oracles  * Move J2V8 artifact ID into configurable properties  * Make function annotations consistent for all languages
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,162cea28e50bdb8045b3cc44648fe15236f5f01d,Braxton Hall,Function Annotation in Diffs (#62)  * Add annotations to source fragments  * Accept Python functions at EOF
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getUnformattedBody,@Override
	public String getUnformattedBody() {
		return this.unformattedBody;
	},16,Annotation Change | Signature Change | Body Change,2e2762e0aa4681ed9c6a21b71bb3aa2f1ca12a71,Syed Ishtiaque Ahmad,Feature #75 Track formatting changes - Get the unformatted body by preserving the original layout of the source code - Compare between current and previous unformatted method's body to track these   kind of formatting changes - Use Javaparser "LexicalPreservingPrinter" to get the unformatted source code 
JsonResult,public JsonResult(String origin  AnalysisTask startTask  List<String> changeHistory 
					  Map<String  Ychange> changeHistoryDetails  Map<String  String> changeHistoryShort) {

		StartEnvironment startEnv = startTask.getStartEnv();

		this.origin = origin;
		this.repositoryName = startEnv.getRepositoryName();
		this.repositoryPath = startEnv.getRepositoryPath();

		this.startCommitName = startTask.getStartCommitName();
		this.sourceFileName = startTask.getFileName();
		this.sourceFilePath = startTask.getFilePath();
		this.functionName = startTask.getFunctionName();
		this.functionStartLine = startTask.getFunctionStartLine();
		this.functionAnnotation = startTask.getFunctionAnnotation();
		this.functionDoc = startTask.getFunctionDoc();
		this.functionEndLine = startTask.getFunctionEndLine();
		this.functionId = startTask.getStartFunction().getId();

		this.changeHistory = changeHistory;
		this.changeHistoryDetails = changeHistoryDetails;
		this.changeHistoryShort = changeHistoryShort;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
JsonResult,public JsonResult(String origin  AnalysisTask startTask  List<String> changeHistory 
					  Map<String  Ychange> changeHistoryDetails  Map<String  String> changeHistoryShort) {

		StartEnvironment startEnv = startTask.getStartEnv();

		this.origin = origin;
		this.repositoryName = startEnv.getRepositoryName();
		this.repositoryPath = startEnv.getRepositoryPath();

		this.startCommitName = startTask.getStartCommitName();
		this.sourceFileName = startTask.getFileName();
		this.sourceFilePath = startTask.getFilePath();
		this.functionName = startTask.getFunctionName();
		this.functionStartLine = startTask.getFunctionStartLine();
		this.functionAnnotation = startTask.getFunctionAnnotation();
		this.functionDoc = startTask.getFunctionDoc();
		this.functionEndLine = startTask.getFunctionEndLine();
		this.functionId = startTask.getStartFunction().getId();

		this.changeHistory = changeHistory;
		this.changeHistoryDetails = changeHistoryDetails;
		this.changeHistoryShort = changeHistoryShort;
	},6,Body Change,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
JsonResult,public JsonResult(String origin  AnalysisTask startTask  List<String> changeHistory 
					  Map<String  Ychange> changeHistoryDetails  Map<String  String> changeHistoryShort) {

		StartEnvironment startEnv = startTask.getStartEnv();

		this.origin = origin;
		this.repositoryName = startEnv.getRepositoryName();
		this.repositoryPath = startEnv.getRepositoryPath();

		this.startCommitName = startTask.getStartCommitName();
		this.sourceFileName = startTask.getFileName();
		this.sourceFilePath = startTask.getFilePath();
		this.functionName = startTask.getFunctionName();
		this.functionStartLine = startTask.getFunctionStartLine();
		this.functionAnnotation = startTask.getFunctionAnnotation();
		this.functionDoc = startTask.getFunctionDoc();
		this.functionEndLine = startTask.getFunctionEndLine();
		this.functionId = startTask.getStartFunction().getId();

		this.changeHistory = changeHistory;
		this.changeHistoryDetails = changeHistoryDetails;
		this.changeHistoryShort = changeHistoryShort;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
JsonResult,public JsonResult(String origin  AnalysisTask startTask  List<String> changeHistory 
					  Map<String  Ychange> changeHistoryDetails  Map<String  String> changeHistoryShort) {

		StartEnvironment startEnv = startTask.getStartEnv();

		this.origin = origin;
		this.repositoryName = startEnv.getRepositoryName();
		this.repositoryPath = startEnv.getRepositoryPath();

		this.startCommitName = startTask.getStartCommitName();
		this.sourceFileName = startTask.getFileName();
		this.sourceFilePath = startTask.getFilePath();
		this.functionName = startTask.getFunctionName();
		this.functionStartLine = startTask.getFunctionStartLine();
		this.functionAnnotation = startTask.getFunctionAnnotation();
		this.functionDoc = startTask.getFunctionDoc();
		this.functionEndLine = startTask.getFunctionEndLine();
		this.functionId = startTask.getStartFunction().getId();

		this.changeHistory = changeHistory;
		this.changeHistoryDetails = changeHistoryDetails;
		this.changeHistoryShort = changeHistoryShort;
	},6,Body Change,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
JsonResult,public JsonResult(String origin  AnalysisTask startTask  List<String> changeHistory 
					  Map<String  Ychange> changeHistoryDetails  Map<String  String> changeHistoryShort) {

		StartEnvironment startEnv = startTask.getStartEnv();

		this.origin = origin;
		this.repositoryName = startEnv.getRepositoryName();
		this.repositoryPath = startEnv.getRepositoryPath();

		this.startCommitName = startTask.getStartCommitName();
		this.sourceFileName = startTask.getFileName();
		this.sourceFilePath = startTask.getFilePath();
		this.functionName = startTask.getFunctionName();
		this.functionStartLine = startTask.getFunctionStartLine();
		this.functionAnnotation = startTask.getFunctionAnnotation();
		this.functionDoc = startTask.getFunctionDoc();
		this.functionEndLine = startTask.getFunctionEndLine();
		this.functionId = startTask.getStartFunction().getId();

		this.changeHistory = changeHistory;
		this.changeHistoryDetails = changeHistoryDetails;
		this.changeHistoryShort = changeHistoryShort;
	},6,Minor Modification,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
JsonResult,public JsonResult(String origin  AnalysisTask startTask  List<String> changeHistory 
					  Map<String  Ychange> changeHistoryDetails  Map<String  String> changeHistoryShort) {

		StartEnvironment startEnv = startTask.getStartEnv();

		this.origin = origin;
		this.repositoryName = startEnv.getRepositoryName();
		this.repositoryPath = startEnv.getRepositoryPath();

		this.startCommitName = startTask.getStartCommitName();
		this.sourceFileName = startTask.getFileName();
		this.sourceFilePath = startTask.getFilePath();
		this.functionName = startTask.getFunctionName();
		this.functionStartLine = startTask.getFunctionStartLine();
		this.functionAnnotation = startTask.getFunctionAnnotation();
		this.functionDoc = startTask.getFunctionDoc();
		this.functionEndLine = startTask.getFunctionEndLine();
		this.functionId = startTask.getStartFunction().getId();

		this.changeHistory = changeHistory;
		this.changeHistoryDetails = changeHistoryDetails;
		this.changeHistoryShort = changeHistoryShort;
	},6,Minor Modification,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getStartCommitName,public String getStartCommitName() {
		return startCommitName;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getSourceFileName,public String getSourceFileName() {
		return sourceFileName;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getSourceFileName,public String getSourceFileName() {
		return sourceFileName;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getSourceFileName,public String getSourceFileName() {
		return sourceFileName;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getSourceFileName,public String getSourceFileName() {
		return sourceFileName;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getSourceFileName,public String getSourceFileName() {
		return sourceFileName;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getSourceFileName,public String getSourceFileName() {
		return sourceFileName;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionName,public String getFunctionName() {
		return functionName;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getFunctionName,public String getFunctionName() {
		return functionName;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getFunctionName,public String getFunctionName() {
		return functionName;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionName,public String getFunctionName() {
		return functionName;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionName,public String getFunctionName() {
		return functionName;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionName,public String getFunctionName() {
		return functionName;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionStartLine,public int getFunctionStartLine() {
		return functionStartLine;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionEndLine,public int getFunctionEndLine() {
		return functionEndLine;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getChangeHistory,public List<String> getChangeHistory() {
		return changeHistory;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getChangeHistory,public List<String> getChangeHistory() {
		return changeHistory;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getChangeHistory,public List<String> getChangeHistory() {
		return changeHistory;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getChangeHistory,public List<String> getChangeHistory() {
		return changeHistory;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getChangeHistory,public List<String> getChangeHistory() {
		return changeHistory;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getChangeHistory,public List<String> getChangeHistory() {
		return changeHistory;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
toJson,public String toJson() {
		return GSON.toJson(this);
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
toJson,public String toJson() {
		return GSON.toJson(this);
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
toJson,public String toJson() {
		return GSON.toJson(this);
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
toJson,public String toJson() {
		return GSON.toJson(this);
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
toJson,public String toJson() {
		return GSON.toJson(this);
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
toJson,public String toJson() {
		return GSON.toJson(this);
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getRepositoryName,public String getRepositoryName() {
		return repositoryName;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getOrigin,public String getOrigin() {
		return origin;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getOrigin,public String getOrigin() {
		return origin;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getOrigin,public String getOrigin() {
		return origin;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getOrigin,public String getOrigin() {
		return origin;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getOrigin,public String getOrigin() {
		return origin;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getOrigin,public String getOrigin() {
		return origin;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getSourceFilePath,public String getSourceFilePath() {
		return sourceFilePath;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getSourceFilePath,public String getSourceFilePath() {
		return sourceFilePath;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getSourceFilePath,public String getSourceFilePath() {
		return sourceFilePath;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getSourceFilePath,public String getSourceFilePath() {
		return sourceFilePath;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getSourceFilePath,public String getSourceFilePath() {
		return sourceFilePath;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getSourceFilePath,public String getSourceFilePath() {
		return sourceFilePath;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getFunctionId,public String getFunctionId() {
		return functionId;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getFunctionId,public String getFunctionId() {
		return functionId;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getFunctionId,public String getFunctionId() {
		return functionId;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getFunctionId,public String getFunctionId() {
		return functionId;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getFunctionId,public String getFunctionId() {
		return functionId;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getFunctionId,public String getFunctionId() {
		return functionId;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getRepositoryPath,public String getRepositoryPath() {
		return repositoryPath;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getChangeHistoryDetails,public Map<String  Ychange> getChangeHistoryDetails() {
		return changeHistoryDetails;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getChangeHistoryDetails,public Map<String  Ychange> getChangeHistoryDetails() {
		return changeHistoryDetails;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getChangeHistoryDetails,public Map<String  Ychange> getChangeHistoryDetails() {
		return changeHistoryDetails;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getChangeHistoryDetails,public Map<String  Ychange> getChangeHistoryDetails() {
		return changeHistoryDetails;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getChangeHistoryDetails,public Map<String  Ychange> getChangeHistoryDetails() {
		return changeHistoryDetails;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getChangeHistoryDetails,public Map<String  Ychange> getChangeHistoryDetails() {
		return changeHistoryDetails;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getChangeHistoryShort,public Map<String  String> getChangeHistoryShort() {
		return changeHistoryShort;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getChangeHistoryShort,public Map<String  String> getChangeHistoryShort() {
		return changeHistoryShort;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getChangeHistoryShort,public Map<String  String> getChangeHistoryShort() {
		return changeHistoryShort;
	},6,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getChangeHistoryShort,public Map<String  String> getChangeHistoryShort() {
		return changeHistoryShort;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getChangeHistoryShort,public Map<String  String> getChangeHistoryShort() {
		return changeHistoryShort;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getChangeHistoryShort,public Map<String  String> getChangeHistoryShort() {
		return changeHistoryShort;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getNumCommitsSeen,public int getNumCommitsSeen() {
		return numCommitsSeen;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getNumCommitsSeen,public int getNumCommitsSeen() {
		return numCommitsSeen;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getNumCommitsSeen,public int getNumCommitsSeen() {
		return numCommitsSeen;
	},6,Signature Change | Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getNumCommitsSeen,public int getNumCommitsSeen() {
		return numCommitsSeen;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getNumCommitsSeen,public int getNumCommitsSeen() {
		return numCommitsSeen;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getNumCommitsSeen,public int getNumCommitsSeen() {
		return numCommitsSeen;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
getTimeTaken,public long getTimeTaken() {
		return timeTaken;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
getTimeTaken,public long getTimeTaken() {
		return timeTaken;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
getTimeTaken,public long getTimeTaken() {
		return timeTaken;
	},6,Signature Change | Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
getTimeTaken,public long getTimeTaken() {
		return timeTaken;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
getTimeTaken,public long getTimeTaken() {
		return timeTaken;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
getTimeTaken,public long getTimeTaken() {
		return timeTaken;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setNumCommitsSeen,public void setNumCommitsSeen(int numCommitsSeen) {
		this.numCommitsSeen = numCommitsSeen;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
setNumCommitsSeen,public void setNumCommitsSeen(int numCommitsSeen) {
		this.numCommitsSeen = numCommitsSeen;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
setNumCommitsSeen,public void setNumCommitsSeen(int numCommitsSeen) {
		this.numCommitsSeen = numCommitsSeen;
	},6,Signature Change | Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setNumCommitsSeen,public void setNumCommitsSeen(int numCommitsSeen) {
		this.numCommitsSeen = numCommitsSeen;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setNumCommitsSeen,public void setNumCommitsSeen(int numCommitsSeen) {
		this.numCommitsSeen = numCommitsSeen;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setNumCommitsSeen,public void setNumCommitsSeen(int numCommitsSeen) {
		this.numCommitsSeen = numCommitsSeen;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
setTimeTaken,public void setTimeTaken(long timeTaken) {
		this.timeTaken = timeTaken;
	},6,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
setTimeTaken,public void setTimeTaken(long timeTaken) {
		this.timeTaken = timeTaken;
	},6,,bc3ffea281854d6e299bba3004db52a9e544a2db,Felix Grund,Fixed bug with wrong paths for files written during mining exec 
setTimeTaken,public void setTimeTaken(long timeTaken) {
		this.timeTaken = timeTaken;
	},6,Signature Change | Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
setTimeTaken,public void setTimeTaken(long timeTaken) {
		this.timeTaken = timeTaken;
	},6,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
setTimeTaken,public void setTimeTaken(long timeTaken) {
		this.timeTaken = timeTaken;
	},6,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
setTimeTaken,public void setTimeTaken(long timeTaken) {
		this.timeTaken = timeTaken;
	},6,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
JsonChangeHistoryDiff,public JsonChangeHistoryDiff(
			List<String> codeshovelHistory 
			List<String> baselineHistory 
			List<String> onlyInCodeshovel 
			List<String> onlyInBaseline) {

		this.codeshovelHistory = codeshovelHistory;
		this.baselineHistory = baselineHistory;
		this.onlyInCodeshovel = onlyInCodeshovel;
		this.onlyInBaseline = onlyInBaseline;
	},3,Parameter Change | Signature Change | Body Change,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
JsonChangeHistoryDiff,public JsonChangeHistoryDiff(
			List<String> codeshovelHistory 
			List<String> baselineHistory 
			List<String> onlyInCodeshovel 
			List<String> onlyInBaseline) {

		this.codeshovelHistory = codeshovelHistory;
		this.baselineHistory = baselineHistory;
		this.onlyInCodeshovel = onlyInCodeshovel;
		this.onlyInBaseline = onlyInBaseline;
	},3,Parameter Change,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
JsonChangeHistoryDiff,public JsonChangeHistoryDiff(
			List<String> codeshovelHistory 
			List<String> baselineHistory 
			List<String> onlyInCodeshovel 
			List<String> onlyInBaseline) {

		this.codeshovelHistory = codeshovelHistory;
		this.baselineHistory = baselineHistory;
		this.onlyInCodeshovel = onlyInCodeshovel;
		this.onlyInBaseline = onlyInBaseline;
	},3,Minor Modification,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
toJson,public String toJson() {
		return GSON.toJson(this);
	},3,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
toJson,public String toJson() {
		return GSON.toJson(this);
	},3,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
toJson,public String toJson() {
		return GSON.toJson(this);
	},3,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
JsonSimilarity,public JsonSimilarity(FunctionEntry function  FunctionEntry mostSimilarFunction  FunctionSimilarity similarity) {
		this.function = function;
		this.mostSimilarFunction = mostSimilarFunction;
		this.similarity = similarity;
	},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getSimilarity,public FunctionSimilarity getSimilarity() {
		return similarity;
	},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getFunction,public FunctionEntry getFunction() {
		return function;
	},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getMostSimilarFunction,public FunctionEntry getMostSimilarFunction() {
		return mostSimilarFunction;
	},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
toJson,public String toJson() {
		return GSON.toJson(this);
	},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getCommitName,public String getCommitName() {
		return this.function.getCommitName();
	},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
FunctionEntry,public FunctionEntry(String commitName  String name  String path  String source) {
			this.commitName = commitName;
			this.name = name;
			this.path = path;
			this.source = source;
		},1,Parameter Change,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getCommitName,public String getCommitName() {
			return commitName;
		},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getName,public String getName() {
			return name;
		},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getPath,public String getPath() {
			return path;
		},1,,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
getSource,public String getSource() {
			return source;
		},1,Signature Change | Body Change,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
toString,@Override
		public String toString() {
			String template = "COMMIT: %s\nNAME: %s\nPATH: %s\nSOURCE:\n%s\n";
			return String.format(template  this.commitName  this.name  this.path  this.source);
		},1,Minor Modification,02083c2597e3c752d8e3b47c428e41900bad179d,Felix Grund,now differentiating for body similarity depending on body length 
serialize,@Override
	public JsonElement serialize(Ychange change 
			 Type typeOfSrc  JsonSerializationContext context) {

		return change.toJsonObject();
	},4,Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
serialize,@Override
	public JsonElement serialize(Ychange change 
			 Type typeOfSrc  JsonSerializationContext context) {

		return change.toJsonObject();
	},4,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
serialize,@Override
	public JsonElement serialize(Ychange change 
			 Type typeOfSrc  JsonSerializationContext context) {

		return change.toJsonObject();
	},4,Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
serialize,@Override
	public JsonElement serialize(Ychange change 
			 Type typeOfSrc  JsonSerializationContext context) {

		return change.toJsonObject();
	},4,Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,Body Change,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,Body Change,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,Minor Modification,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,Minor Modification,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
runMining,public static Yresult runMining(StartEnvironment startEnv  String acceptedFileExtension) throws Exception {
		// We stopped gathering results for mining executions in heap space (which was crazy anyways).
		// So this result will remain empty. The result files are written within the executions.
		Yresult yresult = new Yresult();
		printMiningStart(startEnv);
		List<String> filePaths = startEnv.getRepositoryService().findFilesByExtension(startEnv.getStartCommit()  acceptedFileExtension);
		List<String> filePathsToConsider = new ArrayList<>();
		for (String filePath : filePaths) {
			if (startEnv.getFilePath() == null || filePath.contains(startEnv.getFilePath())) {
				filePathsToConsider.add(filePath);
			}
		}

		int numFilePaths = filePathsToConsider.size();
		System.out.println("Found " +numFilePaths+ " files to analyze");
		int index = 1;
		for (String filePath : filePathsToConsider) {
			printProgress(index  numFilePaths);
			try {
				runSingle(startEnv  filePath  false);
			} catch (Exception e) {
				log.error("Could run Shovel execution for Env {{}} with path {{}}. Skipping."  startEnv.getEnvName()  filePath  e);
			}

			index++;
		}

		printMiningEnd(startEnv);

		return yresult;
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Parameter Change | Signature Change | Body Change,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Minor Modification,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Minor Modification,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Minor Modification,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Minor Modification,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Body Change,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Minor Modification,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Minor Modification,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Minor Modification,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,Body Change,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
runSingle,public static Yresult runSingle(StartEnvironment startEnv  String filePath  boolean accumulateResults) throws Exception {
		long now = new Date().getTime();
		Yresult yresult = new Yresult();
		printFileStart(filePath);
		String startFileContent = startEnv.getRepositoryService().findFileContent(startEnv.getStartCommit()  filePath);
		Yparser parser = ParserFactory.getParser(startEnv  filePath  startFileContent  startEnv.getStartCommit());
		for (Yfunction method : parser.getAllMethods()) {
			try {
				if (startEnv.getFunctionName() == null || startEnv.getFunctionName().equals(method.getName())) {
					if (startEnv.getFunctionStartLine() <= 0 || startEnv.getFunctionStartLine() == method.getNameLineNumber()) {
						if (accumulateResults) {
							yresult.putAll(runForMethod(startEnv  filePath  method));
						} else {
							runForMethod(startEnv  filePath  method);
						}
					}
				}
			} catch (Exception e) {
				log.error("SHOVEL_ERR: Error occurred running mining for method {} in file {}. Skipping."  method.getName()  filePath  e);
				e.printStackTrace();
			}

		}
		printFileEnd(filePath);
		duration += (new Date().getTime() - now);
		System.out.println("Total duration: " + duration);
		return yresult;
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Minor Modification,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Minor Modification,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Minor Modification,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Minor Modification,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Minor Modification,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Minor Modification,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Minor Modification,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Body Change,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
runForMethod,private static Yresult runForMethod(StartEnvironment startEnv  String filePath  Yfunction method) throws Exception {
		printMethodStart(method);

		String name = method.getName();
		int lineNumber = method.getNameLineNumber();
		AnalysisTask task = new AnalysisTask(startEnv);
		task.setFilePath(filePath);
		task.setFunctionName(name);
		task.setFunctionStartLine(lineNumber);
		task.setFunctionAnnotation(method.getAnnotation());
		task.setFunctionDoc(method.getFunctionDoc());

		RecursiveAnalysisTask recursiveAnalysisTask = new RecursiveAnalysisTask(startEnv  task);
		recursiveAnalysisTask.run();

		Yresult yresult = recursiveAnalysisTask.getResult();
		List<String> codeshovelHistory = new ArrayList<>();
		Map<String  Ychange> changeHistoryDetails = new LinkedHashMap<>();
		Map<String  String> changeHistoryShort = new LinkedHashMap<>();

		log.trace("Creating method history and writing git diffs for result history...");
		for (String commitName : yresult.keySet()) {
			codeshovelHistory.add(commitName);
			Ychange change = yresult.get(commitName);
			changeHistoryDetails.put(commitName  change);
			changeHistoryShort.put(commitName  change.getTypeAsString());
		}

		printAsJson(changeHistoryShort);

		JsonResult jsonResultCodeshovel = new JsonResult("codeshovel"  task  codeshovelHistory  changeHistoryDetails  changeHistoryShort);
		jsonResultCodeshovel.setNumCommitsSeen(recursiveAnalysisTask.getNumAnalyzedCommits());
		jsonResultCodeshovel.setTimeTaken(recursiveAnalysisTask.getTimeTaken());

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS) {
			if (StringUtils.isNotBlank(startEnv.getOutputFilePath())) {
				Utl.writeShovelResultFile(jsonResultCodeshovel  startEnv.getOutputFilePath());
			} else if (GlobalEnv.WRITE_RESULTS) {
				Utl.writeShovelResultFile(jsonResultCodeshovel);
			}

			if (GlobalEnv.WRITE_ORACLES) {
				Utl.writeJsonOracleToFile(jsonResultCodeshovel);
			}

		}

		if (!GlobalEnv.DISABLE_ALL_OUTPUTS && (GlobalEnv.WRITE_GITLOG || GlobalEnv.WRITE_SEMANTIC_DIFFS)) {
			GitRangeLogTask gitRangeLogTask = new GitRangeLogTask(task  startEnv);
			gitRangeLogTask.run();
			List<String> gitLogHistory = gitRangeLogTask.getResult();

			JsonResult jsonResultLogCommand = new JsonResult("logcommand"  task  gitLogHistory  null  null);
			Utl.printMethodHistory(gitLogHistory);
			Utl.writeGitLogFile(jsonResultLogCommand);

			createAndWriteSemanticDiff("gitlog"  jsonResultCodeshovel  codeshovelHistory  gitLogHistory);

			List<String> customBaselineHistory = startEnv.getBaseline();
			if (customBaselineHistory != null) {
				createAndWriteSemanticDiff("custom"  jsonResultCodeshovel  codeshovelHistory  customBaselineHistory);
			}
		}

		printMethodEnd(method  startEnv.getOutputFilePath());

		return yresult;
	},33,Minor Modification,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,Signature Change | Body Change,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,Body Change,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,Body Change,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,Body Change,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
createAndWriteSemanticDiff,private static void createAndWriteSemanticDiff(String baselineName  JsonResult result 
									   List<String> codeshovelHistory  List<String> baselineHistory) {
		List<String> onlyInCodeshovel = new ArrayList<>(codeshovelHistory);
		onlyInCodeshovel.removeAll(baselineHistory);

		List<String> onlyInBaseline = new ArrayList<>(baselineHistory);
		onlyInBaseline.removeAll(codeshovelHistory);

		log.trace("Found difference in change history. Writing files.");
		JsonChangeHistoryDiff diff = new JsonChangeHistoryDiff(codeshovelHistory  baselineHistory 
				onlyInCodeshovel  onlyInBaseline);
		Utl.writeSemanticDiff(baselineName  result  diff);
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,Signature Change | Body Change,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,Body Change,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,Body Change,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
printAsJson,private static void printAsJson(Map<String  String> changeHistoryShort) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%% RESULT %%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		for (String commitName : changeHistoryShort.keySet()) {
			System.out.println("\""+ commitName +"\": " + "\""+ changeHistoryShort.get(commitName) +"\" ");
		}
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
printFileStart,private static void printFileStart(String filePath) {
		System.out.println("#########################################################################");
		System.out.println("STARTING ANALYSIS FOR FILE " + filePath);
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
printFileEnd,private static void printFileEnd(String filePath) {
		System.out.println("FINISHED ANALYSIS FOR FILE " + filePath);
		System.out.println("#########################################################################");
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
printMethodStart,private static void printMethodStart(Yfunction method) {
		System.out.println("-------------------------------------------------------------------------");
		System.out.println("STARTING ANALYSIS FOR METHOD " + method.getName());
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,Parameter Change | Signature Change | Body Change,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
printMethodEnd,private static void printMethodEnd(Yfunction method  String outputFilePath) {
		System.out.println("FINISHED ANALYSIS FOR METHOD " + method.getName());
		if (StringUtils.isNotBlank(outputFilePath)) {
			System.out.println("RESULT FILE WRITTEN TO " + outputFilePath);
		}
		System.out.println("-------------------------------------------------------------------------");
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,Minor Modification,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
printMiningEnd,private static void printMiningEnd(StartEnvironment startEnv) {
		System.out.println("FINISHED MINING ANALYSIS");
		System.out.println(new Date());
		System.out.println("#########################################################################");
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,Minor Modification,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
printMiningStart,private static void printMiningStart(StartEnvironment startEnv) {
		System.out.println("#########################################################################");
		System.out.println("STARTING MINING ANALYSIS FOR REPO AND PATH: " + startEnv.getRepositoryName() + " - " + startEnv.getFilePath());
		System.out.println(new Date());
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,56f99c131fff3656b8d14f81d10da08c8488be24,Felix Grund,Moved tasks to own package and fixed git diff issue 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,46dcba42687092d6806a4df3b6f12bde1313849a,Felix Grund,implemented baseline switch feature 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,c2d54670c9da7364b6fbdf10f612a47ee2a38245,Felix Grund,Now creating semantic diff files for both git log and custom baselines 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,03fdd162e069a13321bef3f40244227a1874df08,Felix Grund,finished other checkstyle examples 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,640af9b185af89ea568d3201f9f7a932c457f694,Felix Grund,Fixed heap space issue in mining executions 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,Signature Change | Body Change,b7e3f858c6866154fb3b947dd3ecf7424179d1d6,Felix Grund,Logging more information and nicer 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,Body Change,712fa1e7d6be56279d1951a29574601512debe62,Nick Bradley,Output the date in the log at start  end and on progress updates for simple profiling 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,d8bae4c8a940696b4bc5740b7a1905991fcaa195,Felix Grund,always write semantic diff files  even if baseline and shovel don't differ 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,46ec72105cd8cb1803c14b3bb71576c8e5b5ca35,Felix Grund,Further bugfixing during empirical analysis. Checkstyle and Flink stubs work now. 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,c5db40141eeb08ee0ca05c5bfd9f06d3839e7f89,Felix Grund,Added exception handling to ShovelExecution 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,29c7cd5e5726b0c937ca6e07e4a298b9f48de8a6,Felix Grund,Implemented automatic creation of stub files 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,0444c8a61614b88232efcab4f3fc5e2298deb509,Felix Grund,Implemented GlobalEnv so we have all System.getenv calls in one place Also cleaned up some stuff 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,8fbac0bdd46accd745efe6e6d2b0a871b14a1f87,Felix Grund,added only baseline implementation 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,6762dc056533f29b954abe2e9c4fc79bfc732753,Felix Grund,hardcoded only baseline temporarily 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,2a067cb942deffceeb9d43dd91f83ce65d098b1a,Felix Grund,reverted only baseline code 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,fe05abbffc2546b01286bc54a4f5061eae821e52,Felix Grund,Replaced log.info with log.trace 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,ce03ac53975f674f2e44b3204494da9fa5fd2884,Felix Grund,Next round of improvements and new stubs 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,8cc3323935a9e499a2097f0d6a20bb45559ad114,Felix Grund,Finally all tests are passing 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,Body Change,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,6bed7d970e50d4375c6bb48bfa88fbfe587f0642,Felix Grund,Heavy general refactoring with abstract vs non-abstract + first version of Ruby impl 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,2f53497b1425b37a0b62bd10b1e2d2b60f6c0457,Felix Grund,Now counting commits seen and time taken in output files 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,5ce44987cfd47e007cecca2928f5dcee5abb232a,reid holmes,see #47 refactor from 'stubs' to 'oracles'. update docs and code references consistently through the repo. 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,aac93a742efed017a2f6ebb4b8336e48ca89cbf9,Syed Ishtiaque Ahmad,Extend CodeShovel to capture method annotations (#51)  * Feature ataraxie/codeshovel#1: Add method annotation to JSON result - Capture all kinds of annotations such as @Test  @Override  @SuppressWarnings etc. See more: ataraxie/codeshovel#1  * Remove code written to test annotation feature ataraxie/codeshovel#1  * Add a stub function 'getMethodAnnotation' in PythonFunction.java
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,3ce998ee71bc6d03693144ff445ba3140e92faf3,Syed Ishtiaque Ahmad,Feature ataraxie/codeshovel#64: Extend CodeShovel to capture JavaDoc - Add a json key `functionJavaDoc` which contains the java doc string TODO: implement "getInitialJavaDoc" for python and typescript - For python implement here: PythonFunction.java - For typescript implement here: TypeScriptFunction.java Discussion link: ataraxie/codeshovel#64 
printProgress,private static void printProgress(int index  int numFilePaths) {
		System.out.println("");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% FILE " + index + " / " + numFilePaths + " %%%%%%%%%%%%%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%% " + new Date() + " %%%%%%%%%%");
		System.out.println("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
		System.out.println("");
	},33,,0d642ebe845f03457617461541d0cf32f18184b4,Syed Ishtiaque Ahmad,feature ataraxie/codeshovel#64: Track doc changes (Ydocchange) - Add a new change type Ydocchange which extends Ysignaturechange - Rename everywhere reference of *javaDoc* -> Doc to keep things consistent with python   and typescript implementation TODO list: - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/PythonFunction.java` - Implement `getInitialDoc` in `com/felixgrund/codeshovel/parser/impl/TypeScriptFunction.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/TypeScriptParser.java` - Handle `Ydocchange` in `src/main/java/com/felixgrund/codeshovel/parser/impl/PythonParser.java` - Get the diff for doc changes 
main,public static void main(String[] args) {
		CommandLineParser parser = new DefaultParser();
		Options options = new Options();
		options.addOption(newOption("reponame"  true  "name of the repository. Default: last part from repopath (before /.git)"  false));
		options.addOption(newOption("repopath"  true  "(required) path to the repository (on the local file system)"  true));
		options.addOption(newOption("filepath"  true  "(required) path to the file containing the method"  true));
		options.addOption(newOption("methodname"  true  "(required) name of the method"  true));
		options.addOption(newOption("startline"  true  "(required) start line of the method"  true));
		options.addOption(newOption("startcommit"  true  "hash of the commit to begin with backwards history traversal. Default: HEAD"  false));
		options.addOption(newOption("outfile"  true  "path to the output file. Default: current working directory"  false));

		try {
			CommandLine line = parser.parse(options  args);
			String repositoryPath = line.getOptionValue("repopath");
			// Unix vs. Windows. Probably there is a better way to do this.
			String pathDelimiter = repositoryPath.contains("\\\\") ? "\\\\" : "/";
			// Repo paths need to reference the .git directory. We add it to the path if it's not provided.
			String gitPathEnding = pathDelimiter + ".git";
			if (!repositoryPath.endsWith(gitPathEnding)) {
				repositoryPath += gitPathEnding;
			}
			// If no repo name parameter was provided we extract if from the repo path.
			String repositoryName = line.getOptionValue("reponame");
			if (repositoryName == null) {
				String[] split = repositoryPath.replace(gitPathEnding  "").split(pathDelimiter);
				repositoryName = split[split.length - 1];
			}
			String filePath = line.getOptionValue("filepath");
			String functionName = line.getOptionValue("methodname");
			int functionStartLine = Integer.parseInt(line.getOptionValue("startline"));
			// If no start commit hash was provided we use HEAD.
			String startCommitName = line.getOptionValue("startcommit");
			if (startCommitName == null) {
				startCommitName = "HEAD";
			}
			// If no output file path was provided the output file will be saved in the current directory.
			String outputFilePath = line.getOptionValue("outfile");
			if (outputFilePath == null) {
				outputFilePath = System.getProperty("user.dir") + "/" + repositoryName + "-" + functionName + "-" + functionStartLine + ".json";
			}

			// Below is the start of a CodeShovel execution as we know it.
			Repository repository = Utl.createRepository(repositoryPath);
			Git git = new Git(repository);
			RepositoryService repositoryService = new CachingRepositoryService(git  repository  repositoryName  repositoryPath);
			Commit startCommit = repositoryService.findCommitByName(startCommitName);

			StartEnvironment startEnv = new StartEnvironment(repositoryService);
			startEnv.setRepositoryPath(repositoryPath);
			startEnv.setFilePath(filePath);
			startEnv.setFunctionName(functionName);
			startEnv.setFunctionStartLine(functionStartLine);
			startEnv.setStartCommitName(startCommitName);
			startEnv.setStartCommit(startCommit);
			startEnv.setFileName(Utl.getFileName(startEnv.getFilePath()));
			startEnv.setOutputFilePath(outputFilePath);

			ShovelExecution.runSingle(startEnv  startEnv.getFilePath()  true);
		} catch (ParseException e) {
			HelpFormatter formatter = new HelpFormatter();
			formatter.printHelp("java -jar <codeshovel-jar-file>"  options);
		} catch (Exception e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		}

	},1,Body Change,affc36f170798edc90904c3d4d1a7bac14106a24,Felix Grund,README and some file renaming/moving 
newOption,private static Option newOption(String name  boolean hasArg  String desc  boolean required) {
		Option option = new Option(name  hasArg  desc);
		option.setRequired(required);
		return option;
	},1,,affc36f170798edc90904c3d4d1a7bac14106a24,Felix Grund,README and some file renaming/moving 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,Body Change,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
CachingRepositoryService,public CachingRepositoryService(Git git  Repository repository  String repositoryName  String repositoryPath) {
		this.git = git;
		this.repository = repository;
		this.repositoryName = repositoryName;
		this.repositoryPath = repositoryPath;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getGit,@Override
	public Git getGit() {
		return git;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getRepository,@Override
	public Repository getRepository() {
		return repository;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getRepositoryName,@Override
	public String getRepositoryName() {
		return repositoryName;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getRepositoryPath,@Override
	public String getRepositoryPath() {
		return repositoryPath;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,Minor Modification,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,Body Change,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,Parameter Change | Signature Change | Body Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getCommitsBetween,@Override
	public List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath) {

		Yhistory yhistory = getHistory(newCommit  filePath);
		List<Commit> commits = new ArrayList<>();
		for (Commit commit : yhistory.getCommits().values()) {
			if (commit.getName().equals(oldCommit.getName())) {
				break;
			} else if (commit.getCommitDate().before(oldCommit.getCommitDate())) {
				break;
			}
			commits.add(commit);
		}

		return commits;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,Parameter Change | Signature Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,Parameter Change,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getCacheKey,private String getCacheKey(Commit startCommit  String filePath) {
		String cacheKeyInput = startCommit.getName();
		if (filePath != null) {
			cacheKeyInput += filePath;
		}
		return DigestUtils.md5Hex(cacheKeyInput);
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,Signature Change | Body Change | Return Type Change,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,Parameter Change | Signature Change | Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,Parameter Change,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getHistory,@Override
	public Yhistory getHistory(Commit startCommit  String filePath) {

		LinkedHashMap<String  Commit> commits = new LinkedHashMap<>();
		LinkedHashMap<String  RevCommit> revCommits = new LinkedHashMap<>();

		try {
			LogCommand logCommand = git.log().add(startCommit.getId());
			if (filePath != null) {
				logCommand.addPath(filePath);
			}

			logCommand.setRevFilter(RevFilter.NO_MERGES);

			Iterable<RevCommit> fileRevisions = logCommand.call();
			for (RevCommit revCommit : fileRevisions) {
				revCommits.put(revCommit.getName()  revCommit);
				commits.put(revCommit.getName()  new Commit(revCommit));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return new Yhistory(commits  revCommits);
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,Parameter Change | Signature Change | Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,Body Change,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,Minor Modification,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,Minor Modification,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
findFileContent,@Override
	public String findFileContent(Commit commit  String filePath) throws IOException {
		String fileContent = null;
		if (!Ydiff.NULL_PATH.equals(filePath)) {
			String cacheKey = getCacheKey(commit  filePath);
			fileContent = this.cacheCommitFileContent.get(cacheKey);
			if (fileContent == null) {
				RevCommit revCommit = findRevCommitById(commit.getId());
				RevTree tree = revCommit.getTree();
				TreeWalk treeWalk = new TreeWalk(this.repository);
				treeWalk.addTree(tree);
				treeWalk.setRecursive(true);
				treeWalk.setFilter(PathFilter.create(filePath));
				if (treeWalk.next()) {
					ObjectId objectId = treeWalk.getObjectId(0);
					fileContent = this.getFileContentByObjectId(objectId);
					handleCacheAdd(this.cacheCommitFileContent  this.cacheCommitFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
				}
			} else {
				handleCacheHits();
			}
		}

		return fileContent;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,Signature Change | Body Change,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
handleCacheHits,private void handleCacheHits() {
		this.cacheHits += 1;
//		long cacheSize = (RamUsageEstimator.sizeOf(this.cacheCommitFileContent) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdCommit) +
//				RamUsageEstimator.sizeOf(this.cacheObjectIdFileContent)) / 1024;
//		if (this.cacheHits % 100 == 0) {
//			System.out.println("CACHE HITS: " + this.cacheHits);
//			System.out.println("TOTAL CACHE SIZE (KB): " + cacheSize);
//		}
	},12,Body Change,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,Signature Change | Body Change,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
handleCacheAdd,private void handleCacheAdd(Map cache  LinkedList<String> cacheKeys  String cacheKey  Object value  int maxSize) {
//		if (cache.size() > CACHE_SIZE_FILE_CONTENT) {
//			String lastCacheKey = cacheKeys.getLast();
//			cache.remove(lastCacheKey);
//			cacheKeys.remove(lastCacheKey);
//		}
		cacheKeys.add(0  cacheKey);
		cache.put(cacheKey  value);
	},12,Body Change,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,Parameter Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
findFilesByExtension,@Override
	public List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception {
		List<String> ret = new ArrayList<>();
		RevTree tree = findRevCommitById(commit.getId()).getTree();
		TreeWalk treeWalk = new TreeWalk(this.repository);
		treeWalk.addTree(tree);
		treeWalk.setRecursive(true);
		while (treeWalk.next()) {
			String pathString = treeWalk.getPathString();
			if (treeWalk.getPathString().endsWith(fileExtension)) {
				ret.add(pathString);
			}
		}
		return ret;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,Body Change,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,Minor Modification,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,Minor Modification,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getFileContentByObjectId,@Override
	public String getFileContentByObjectId(ObjectId objectId) throws IOException {
		String cacheKey = objectId.getName();
		String fileContent = this.cacheObjectIdFileContent.get(cacheKey);
		if (fileContent == null) {
			ObjectLoader loader = this.repository.open(objectId);
			OutputStream output = new OutputStream()
			{
				private StringBuilder string = new StringBuilder();
				@Override
				public void write(int b) {
					this.string.append((char) b);
				}
				public String toString(){
					return this.string.toString();
				}
			};
			loader.copyTo(output);
			fileContent = output.toString();
			handleCacheAdd(this.cacheObjectIdFileContent  this.cacheObjectIdFileContentKeys  cacheKey  fileContent  CACHE_SIZE_FILE_CONTENT);
		} else {
			handleCacheHits();
		}

		return fileContent;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,Minor Modification,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
write,@Override
				public void write(int b) {
					this.string.append((char) b);
				},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
toString,public String toString(){
					return this.string.toString();
				},12,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toString,public String toString(){
					return this.string.toString();
				},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
toString,public String toString(){
					return this.string.toString();
				},12,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toString,public String toString(){
					return this.string.toString();
				},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
toString,public String toString(){
					return this.string.toString();
				},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
toString,public String toString(){
					return this.string.toString();
				},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
toString,public String toString(){
					return this.string.toString();
				},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
toString,public String toString(){
					return this.string.toString();
				},12,Minor Modification,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
toString,public String toString(){
					return this.string.toString();
				},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
toString,public String toString(){
					return this.string.toString();
				},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
toString,public String toString(){
					return this.string.toString();
				},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
toString,public String toString(){
					return this.string.toString();
				},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,Parameter Change | Signature Change | Body Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
getPrevCommitNeglectingFile,@Override
	public Commit getPrevCommitNeglectingFile(Commit commit) throws IOException {
		Commit ret = null;
		RevCommit revCommit = findRevCommitById(commit.getId());
		if (revCommit.getParentCount() > 0) {
			ObjectId prevCommitId = revCommit.getParent(0).getId();
			ret = new Commit(this.findRevCommitById(prevCommitId));
		}

		return ret;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
gitLogRange,@Override
	public List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception {

		Commit startCommit = this.findCommitByName(startCommitName);

		LogCommand logCommandFile = git.log().add(startCommit.getId()).addPath(filePath).setRevFilter(RevFilter.NO_MERGES);
		Iterable<RevCommit> fileRevisions = logCommandFile.call();
		Map<String  Commit> fileHistory = new LinkedHashMap<>();
		for (RevCommit commit : fileRevisions) {
			fileHistory.put(commit.getName()  new Commit(commit));
		}

		List<String> commitNames = new ArrayList<>();
		File repositoryDir = repository.getDirectory().getParentFile();

		BufferedReader reader = CmdUtil.gitLog(startCommitName  repositoryDir  rangeStart  rangeEnd  filePath);

		String line = reader.readLine();
		while (line != null) {
			Matcher matcher = COMMIT_NAME_PATTERN.matcher(line);
			if (matcher.matches() && matcher.groupCount() > 0) {
				String commitName = matcher.group(1);
				Commit commit = fileHistory.get(commitName);
				if (commit != null && commit.getCommitTime() <= startCommit.getCommitTime()) {
					commitNames.add(commitName);
				}
			}
			line = reader.readLine();
		}

		reader.close();

		return commitNames;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,Body Change,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
findCommitByName,@Override
	public Commit findCommitByName(String commitName) throws IOException {
		ObjectId objectId;
		if (Constants.HEAD.equals(commitName)) {
			objectId = this.repository.resolve(Constants.HEAD);
		} else {
			objectId = ObjectId.fromString(commitName);
		}

		return new Commit(findRevCommitById(objectId));
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,Annotation Change | Signature Change | Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,,6d192c80c64f917fc498fd700f74ffafabea28c7,Nick Bradley,Use jetbrains Nullable annotation since maven wouldn't compile with com.sun.istack.internal. See https://stackoverflow.com/a/50427240. 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,,046db2a64df8909751d3676c3595ba2ca62b67aa,Felix Grund,Removed unused imports; Test configs 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,,a4544092ea97ab392b4d1e74be65e6d2f982ed99,Nick Bradley,Remove @Nullable annotation 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,Body Change,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,Minor Modification,d789bdda56975d7af5d2f0c56db274f3d4834253,Felix Grund,Better time taken logging 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,Minor Modification,d8e6e03014f9117917ecc10c8bf6ffd50ce9049b,Felix Grund,Better cache logging 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,,d87344c9bc233398909967e3e2ed5a91ecaa05c4,Felix Grund,Major progress implementing CLI 
findRevCommitById,@Override
	public RevCommit findRevCommitById(ObjectId id) throws IOException {
		String cacheKey = id.getName();
		RevCommit revCommit = this.cacheObjectIdCommit.get(cacheKey);
		if (revCommit == null){
			RevWalk revWalk = new RevWalk(this.repository);
			revCommit = revWalk.parseCommit(revWalk.lookupCommit(id));
			handleCacheAdd(this.cacheObjectIdCommit  this.cacheObjectIdCommitKeys  cacheKey  revCommit  CACHE_SIZE_COMMITS);
		} else {
			handleCacheHits();
		}

		return revCommit;
	},12,,84d533e032bf4c17e114f06e950f674b724c9cde,Reid Holmes,see #47 make it so envnames and skipnames behave the same (aka can take a list of includes/skips). rename ENV_NAME to ENV_NAMES. Simplify the include/exclude logic in maindynamic test.  More controversially: removed the caching size checks from the CachingRepositoryService. Right now this doesn't seem to matter (runs the whole test suite fine). Might have to revisit if it's a problem in the deployed docker container. Mainly motivated to do this due to the JVM warnings about carrotsearch.sizeof.RamUsageEstimator on every execution. 
getRepository,Repository getRepository();,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepository,Repository getRepository();,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getRepository,Repository getRepository();,4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepository,Repository getRepository();,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getRepositoryName,String getRepositoryName();,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepositoryName,String getRepositoryName();,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getRepositoryName,String getRepositoryName();,4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepositoryName,String getRepositoryName();,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getRepositoryPath,String getRepositoryPath();,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getRepositoryPath,String getRepositoryPath();,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getRepositoryPath,String getRepositoryPath();,4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getRepositoryPath,String getRepositoryPath();,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getGit,Git getGit();,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getGit,Git getGit();,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getGit,Git getGit();,4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getGit,Git getGit();,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getCommitsBetween,List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath);,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommitsBetween,List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath);,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getCommitsBetween,List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath);,4,Parameter Change | Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommitsBetween,List<Commit> getCommitsBetween(Commit oldCommit  Commit newCommit  String filePath);,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getHistory,Yhistory getHistory(Commit startCommit  String filePath);,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getHistory,Yhistory getHistory(Commit startCommit  String filePath);,4,Signature Change | Return Type Change,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getHistory,Yhistory getHistory(Commit startCommit  String filePath);,4,Parameter Change | Signature Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getHistory,Yhistory getHistory(Commit startCommit  String filePath);,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findFileContent,String findFileContent(Commit commit  String filePath) throws IOException;,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findFileContent,String findFileContent(Commit commit  String filePath) throws IOException;,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
findFileContent,String findFileContent(Commit commit  String filePath) throws IOException;,4,Parameter Change | Signature Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findFileContent,String findFileContent(Commit commit  String filePath) throws IOException;,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findFilesByExtension,List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception;,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findFilesByExtension,List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception;,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
findFilesByExtension,List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception;,4,Parameter Change | Signature Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findFilesByExtension,List<String> findFilesByExtension(Commit commit  String fileExtension) throws Exception;,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getFileContentByObjectId,String getFileContentByObjectId(ObjectId objectId) throws IOException;,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFileContentByObjectId,String getFileContentByObjectId(ObjectId objectId) throws IOException;,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getFileContentByObjectId,String getFileContentByObjectId(ObjectId objectId) throws IOException;,4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFileContentByObjectId,String getFileContentByObjectId(ObjectId objectId) throws IOException;,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findCommitByName,Commit findCommitByName(String commitName) throws IOException;,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findCommitByName,Commit findCommitByName(String commitName) throws IOException;,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
findCommitByName,Commit findCommitByName(String commitName) throws IOException;,4,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findCommitByName,Commit findCommitByName(String commitName) throws IOException;,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getPrevCommitNeglectingFile,Commit getPrevCommitNeglectingFile(Commit commit) throws IOException;,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getPrevCommitNeglectingFile,Commit getPrevCommitNeglectingFile(Commit commit) throws IOException;,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
getPrevCommitNeglectingFile,Commit getPrevCommitNeglectingFile(Commit commit) throws IOException;,4,Parameter Change | Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getPrevCommitNeglectingFile,Commit getPrevCommitNeglectingFile(Commit commit) throws IOException;,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
gitLogRange,List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception;,4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
gitLogRange,List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception;,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
gitLogRange,List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception;,4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
gitLogRange,List<String> gitLogRange(String startCommitName  int rangeStart  int rangeEnd  String filePath) throws Exception;,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
findRevCommitById,RevCommit findRevCommitById(ObjectId id) throws IOException;,4,Signature Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
findRevCommitById,RevCommit findRevCommitById(ObjectId id) throws IOException;,4,,c82ee19317d96fc0605491aa313ab67204d2dfe3,Felix Grund,at least partly working now 
findRevCommitById,RevCommit findRevCommitById(ObjectId id) throws IOException;,4,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
findRevCommitById,RevCommit findRevCommitById(ObjectId id) throws IOException;,4,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
Ymodifiers,public Ymodifiers(List<String> modifiers) {
		this.modifiers = modifiers;
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
equals,@Override
	public boolean equals(Object obj) {
		return obj instanceof Ymodifiers && this.modifiers.equals(((Ymodifiers) obj).getModifiers());
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getModifiers,public List<String> getModifiers() {
		return modifiers;
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
toString,@Override
	public String toString() {
		return this.modifiers.toString();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Yparameter,public Yparameter(String name  String type) {
		this.name = name;
		this.type = type;
		this.metadata = METADATA_NONE;
		this.metadataString = "";
	},5,Body Change,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
Yparameter,public Yparameter(String name  String type) {
		this.name = name;
		this.type = type;
		this.metadata = METADATA_NONE;
		this.metadataString = "";
	},5,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
Yparameter,public Yparameter(String name  String type) {
		this.name = name;
		this.type = type;
		this.metadata = METADATA_NONE;
		this.metadataString = "";
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
Yparameter,public Yparameter(String name  String type) {
		this.name = name;
		this.type = type;
		this.metadata = METADATA_NONE;
		this.metadataString = "";
	},5,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Yparameter,public Yparameter(String name  String type) {
		this.name = name;
		this.type = type;
		this.metadata = METADATA_NONE;
		this.metadataString = "";
	},5,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getName,public String getName() {
		return name;
	},5,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getName,public String getName() {
		return name;
	},5,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getName,public String getName() {
		return name;
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getName,public String getName() {
		return name;
	},5,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getName,public String getName() {
		return name;
	},5,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getType,public String getType() {
		return type;
	},5,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getType,public String getType() {
		return type;
	},5,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getType,public String getType() {
		return type;
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getType,public String getType() {
		return type;
	},5,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getType,public String getType() {
		return type;
	},5,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
setMetadata,public void setMetadata(Map<String  String> metadata) {
		this.metadata = metadata;
		this.metadataString = "";
		if (!metadata.isEmpty()) {
			List<String> pairs = new ArrayList<>();
			for (String metadataKey : metadata.keySet()) {
				pairs.add(metadataKey + "-" + metadata.get(metadataKey));
			}
			this.metadataString = StringUtils.join(pairs  "__");
		}
	},5,Signature Change | Body Change,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
setMetadata,public void setMetadata(Map<String  String> metadata) {
		this.metadata = metadata;
		this.metadataString = "";
		if (!metadata.isEmpty()) {
			List<String> pairs = new ArrayList<>();
			for (String metadataKey : metadata.keySet()) {
				pairs.add(metadataKey + "-" + metadata.get(metadataKey));
			}
			this.metadataString = StringUtils.join(pairs  "__");
		}
	},5,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
setMetadata,public void setMetadata(Map<String  String> metadata) {
		this.metadata = metadata;
		this.metadataString = "";
		if (!metadata.isEmpty()) {
			List<String> pairs = new ArrayList<>();
			for (String metadataKey : metadata.keySet()) {
				pairs.add(metadataKey + "-" + metadata.get(metadataKey));
			}
			this.metadataString = StringUtils.join(pairs  "__");
		}
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
setMetadata,public void setMetadata(Map<String  String> metadata) {
		this.metadata = metadata;
		this.metadataString = "";
		if (!metadata.isEmpty()) {
			List<String> pairs = new ArrayList<>();
			for (String metadataKey : metadata.keySet()) {
				pairs.add(metadataKey + "-" + metadata.get(metadataKey));
			}
			this.metadataString = StringUtils.join(pairs  "__");
		}
	},5,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
setMetadata,public void setMetadata(Map<String  String> metadata) {
		this.metadata = metadata;
		this.metadataString = "";
		if (!metadata.isEmpty()) {
			List<String> pairs = new ArrayList<>();
			for (String metadataKey : metadata.keySet()) {
				pairs.add(metadataKey + "-" + metadata.get(metadataKey));
			}
			this.metadataString = StringUtils.join(pairs  "__");
		}
	},5,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getMetadataString,public String getMetadataString() {
		return metadataString;
	},5,Signature Change | Body Change,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getMetadataString,public String getMetadataString() {
		return metadataString;
	},5,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getMetadataString,public String getMetadataString() {
		return metadataString;
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getMetadataString,public String getMetadataString() {
		return metadataString;
	},5,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getMetadataString,public String getMetadataString() {
		return metadataString;
	},5,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
equals,@Override
	public boolean equals(Object obj) {
		boolean ret = false;
		if (obj instanceof Yparameter) {
			Yparameter otherParameter = (Yparameter) obj;
			ret = this.name.equals(otherParameter.getName())
					&& this.type.equals(otherParameter.getType());
		}
		return ret;
	},5,Body Change,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
equals,@Override
	public boolean equals(Object obj) {
		boolean ret = false;
		if (obj instanceof Yparameter) {
			Yparameter otherParameter = (Yparameter) obj;
			ret = this.name.equals(otherParameter.getName())
					&& this.type.equals(otherParameter.getType());
		}
		return ret;
	},5,Body Change,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
equals,@Override
	public boolean equals(Object obj) {
		boolean ret = false;
		if (obj instanceof Yparameter) {
			Yparameter otherParameter = (Yparameter) obj;
			ret = this.name.equals(otherParameter.getName())
					&& this.type.equals(otherParameter.getType());
		}
		return ret;
	},5,Body Change,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
equals,@Override
	public boolean equals(Object obj) {
		boolean ret = false;
		if (obj instanceof Yparameter) {
			Yparameter otherParameter = (Yparameter) obj;
			ret = this.name.equals(otherParameter.getName())
					&& this.type.equals(otherParameter.getType());
		}
		return ret;
	},5,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
equals,@Override
	public boolean equals(Object obj) {
		boolean ret = false;
		if (obj instanceof Yparameter) {
			Yparameter otherParameter = (Yparameter) obj;
			ret = this.name.equals(otherParameter.getName())
					&& this.type.equals(otherParameter.getType());
		}
		return ret;
	},5,,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
getNameTypeString,public String getNameTypeString() {
		String string = this.name;
		if (StringUtils.isNotBlank(this.type)) {
			string += "-" + this.type;
		}
		return string;
	},5,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
getNameTypeString,public String getNameTypeString() {
		String string = this.name;
		if (StringUtils.isNotBlank(this.type)) {
			string += "-" + this.type;
		}
		return string;
	},5,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
getNameTypeString,public String getNameTypeString() {
		String string = this.name;
		if (StringUtils.isNotBlank(this.type)) {
			string += "-" + this.type;
		}
		return string;
	},5,,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
getNameTypeString,public String getNameTypeString() {
		String string = this.name;
		if (StringUtils.isNotBlank(this.type)) {
			string += "-" + this.type;
		}
		return string;
	},5,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getNameTypeString,public String getNameTypeString() {
		String string = this.name;
		if (StringUtils.isNotBlank(this.type)) {
			string += "-" + this.type;
		}
		return string;
	},5,Signature Change | Body Change,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
toString,@Override
	public String toString() {
		String string = getNameTypeString();
		if (StringUtils.isNotEmpty(this.metadataString)) {
			string += "("+this.metadataString+")";
		}
		return string;
	},5,,193d7b395b23e9ff465ceb072c7233516fa72192,Felix Grund,Parameters now include metadata (e.g. annotations  modifiers) 
toString,@Override
	public String toString() {
		String string = getNameTypeString();
		if (StringUtils.isNotEmpty(this.metadataString)) {
			string += "("+this.metadataString+")";
		}
		return string;
	},5,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
toString,@Override
	public String toString() {
		String string = getNameTypeString();
		if (StringUtils.isNotEmpty(this.metadataString)) {
			string += "("+this.metadataString+")";
		}
		return string;
	},5,Annotation Change | Signature Change | Body Change,96e612d8461035097f815f902f98260fb68e693d,Felix Grund,finally got meta changes to work fully as it seems 
toString,@Override
	public String toString() {
		String string = getNameTypeString();
		if (StringUtils.isNotEmpty(this.metadataString)) {
			string += "("+this.metadataString+")";
		}
		return string;
	},5,Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
toString,@Override
	public String toString() {
		String string = getNameTypeString();
		if (StringUtils.isNotEmpty(this.metadataString)) {
			string += "("+this.metadataString+")";
		}
		return string;
	},5,Body Change,2cb9eabfdc6ed9e740d4999550d71a0792a2bc77,Felix Grund,Better JSON printing in output 
Ydiff,public Ydiff(RepositoryService repositoryService  Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		this.repositoryService = repositoryService;
		init(commit  prevCommit  detectRenames);
	},8,Parameter Change | Signature Change | Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
Ydiff,public Ydiff(RepositoryService repositoryService  Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		this.repositoryService = repositoryService;
		init(commit  prevCommit  detectRenames);
	},8,Parameter Change | Signature Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
Ydiff,public Ydiff(RepositoryService repositoryService  Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		this.repositoryService = repositoryService;
		init(commit  prevCommit  detectRenames);
	},8,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
Ydiff,public Ydiff(RepositoryService repositoryService  Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		this.repositoryService = repositoryService;
		init(commit  prevCommit  detectRenames);
	},8,,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
Ydiff,public Ydiff(RepositoryService repositoryService  Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		this.repositoryService = repositoryService;
		init(commit  prevCommit  detectRenames);
	},8,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
Ydiff,public Ydiff(RepositoryService repositoryService  Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		this.repositoryService = repositoryService;
		init(commit  prevCommit  detectRenames);
	},8,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
Ydiff,public Ydiff(RepositoryService repositoryService  Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		this.repositoryService = repositoryService;
		init(commit  prevCommit  detectRenames);
	},8,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
Ydiff,public Ydiff(RepositoryService repositoryService  Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		this.repositoryService = repositoryService;
		init(commit  prevCommit  detectRenames);
	},8,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
init,private void init(Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		Repository repository = repositoryService.getRepository();
		ObjectReader objectReader = repository.newObjectReader();
		CanonicalTreeParser treeParserNew = new CanonicalTreeParser();
		OutputStream outputStream = System.out;
		this.diffFormatter = new DiffFormatter(outputStream);
		this.diffFormatter.setRepository(repositoryService.getRepository());
		this.diffFormatter.setDiffComparator(RawTextComparator.DEFAULT);
		RevCommit revCommit = repositoryService.findRevCommitById(commit.getId());
		RevCommit prevRevCommit = repositoryService.findRevCommitById(prevCommit.getId());
		treeParserNew.reset(objectReader  revCommit.getTree());
		CanonicalTreeParser treeParserOld = new CanonicalTreeParser();
		treeParserOld.reset(objectReader  prevRevCommit.getTree());
		this.diffEntries = this.diffFormatter.scan(treeParserOld  treeParserNew);
		if (detectRenames) {
			RenameDetector rd = new RenameDetector(repositoryService.getRepository());
			rd.addAll(diffEntries);
			rd.setRenameScore(RENAME_SCORE);
			diffEntries = rd.compute();
		}

		this.diff = new HashMap<>();
		for (DiffEntry diffEntry : diffEntries) {
			this.diff.put(diffEntry.getNewPath()  diffEntry);
		}
	},8,Parameter Change | Signature Change | Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
init,private void init(Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		Repository repository = repositoryService.getRepository();
		ObjectReader objectReader = repository.newObjectReader();
		CanonicalTreeParser treeParserNew = new CanonicalTreeParser();
		OutputStream outputStream = System.out;
		this.diffFormatter = new DiffFormatter(outputStream);
		this.diffFormatter.setRepository(repositoryService.getRepository());
		this.diffFormatter.setDiffComparator(RawTextComparator.DEFAULT);
		RevCommit revCommit = repositoryService.findRevCommitById(commit.getId());
		RevCommit prevRevCommit = repositoryService.findRevCommitById(prevCommit.getId());
		treeParserNew.reset(objectReader  revCommit.getTree());
		CanonicalTreeParser treeParserOld = new CanonicalTreeParser();
		treeParserOld.reset(objectReader  prevRevCommit.getTree());
		this.diffEntries = this.diffFormatter.scan(treeParserOld  treeParserNew);
		if (detectRenames) {
			RenameDetector rd = new RenameDetector(repositoryService.getRepository());
			rd.addAll(diffEntries);
			rd.setRenameScore(RENAME_SCORE);
			diffEntries = rd.compute();
		}

		this.diff = new HashMap<>();
		for (DiffEntry diffEntry : diffEntries) {
			this.diff.put(diffEntry.getNewPath()  diffEntry);
		}
	},8,Parameter Change | Signature Change | Body Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
init,private void init(Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		Repository repository = repositoryService.getRepository();
		ObjectReader objectReader = repository.newObjectReader();
		CanonicalTreeParser treeParserNew = new CanonicalTreeParser();
		OutputStream outputStream = System.out;
		this.diffFormatter = new DiffFormatter(outputStream);
		this.diffFormatter.setRepository(repositoryService.getRepository());
		this.diffFormatter.setDiffComparator(RawTextComparator.DEFAULT);
		RevCommit revCommit = repositoryService.findRevCommitById(commit.getId());
		RevCommit prevRevCommit = repositoryService.findRevCommitById(prevCommit.getId());
		treeParserNew.reset(objectReader  revCommit.getTree());
		CanonicalTreeParser treeParserOld = new CanonicalTreeParser();
		treeParserOld.reset(objectReader  prevRevCommit.getTree());
		this.diffEntries = this.diffFormatter.scan(treeParserOld  treeParserNew);
		if (detectRenames) {
			RenameDetector rd = new RenameDetector(repositoryService.getRepository());
			rd.addAll(diffEntries);
			rd.setRenameScore(RENAME_SCORE);
			diffEntries = rd.compute();
		}

		this.diff = new HashMap<>();
		for (DiffEntry diffEntry : diffEntries) {
			this.diff.put(diffEntry.getNewPath()  diffEntry);
		}
	},8,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
init,private void init(Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		Repository repository = repositoryService.getRepository();
		ObjectReader objectReader = repository.newObjectReader();
		CanonicalTreeParser treeParserNew = new CanonicalTreeParser();
		OutputStream outputStream = System.out;
		this.diffFormatter = new DiffFormatter(outputStream);
		this.diffFormatter.setRepository(repositoryService.getRepository());
		this.diffFormatter.setDiffComparator(RawTextComparator.DEFAULT);
		RevCommit revCommit = repositoryService.findRevCommitById(commit.getId());
		RevCommit prevRevCommit = repositoryService.findRevCommitById(prevCommit.getId());
		treeParserNew.reset(objectReader  revCommit.getTree());
		CanonicalTreeParser treeParserOld = new CanonicalTreeParser();
		treeParserOld.reset(objectReader  prevRevCommit.getTree());
		this.diffEntries = this.diffFormatter.scan(treeParserOld  treeParserNew);
		if (detectRenames) {
			RenameDetector rd = new RenameDetector(repositoryService.getRepository());
			rd.addAll(diffEntries);
			rd.setRenameScore(RENAME_SCORE);
			diffEntries = rd.compute();
		}

		this.diff = new HashMap<>();
		for (DiffEntry diffEntry : diffEntries) {
			this.diff.put(diffEntry.getNewPath()  diffEntry);
		}
	},8,,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
init,private void init(Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		Repository repository = repositoryService.getRepository();
		ObjectReader objectReader = repository.newObjectReader();
		CanonicalTreeParser treeParserNew = new CanonicalTreeParser();
		OutputStream outputStream = System.out;
		this.diffFormatter = new DiffFormatter(outputStream);
		this.diffFormatter.setRepository(repositoryService.getRepository());
		this.diffFormatter.setDiffComparator(RawTextComparator.DEFAULT);
		RevCommit revCommit = repositoryService.findRevCommitById(commit.getId());
		RevCommit prevRevCommit = repositoryService.findRevCommitById(prevCommit.getId());
		treeParserNew.reset(objectReader  revCommit.getTree());
		CanonicalTreeParser treeParserOld = new CanonicalTreeParser();
		treeParserOld.reset(objectReader  prevRevCommit.getTree());
		this.diffEntries = this.diffFormatter.scan(treeParserOld  treeParserNew);
		if (detectRenames) {
			RenameDetector rd = new RenameDetector(repositoryService.getRepository());
			rd.addAll(diffEntries);
			rd.setRenameScore(RENAME_SCORE);
			diffEntries = rd.compute();
		}

		this.diff = new HashMap<>();
		for (DiffEntry diffEntry : diffEntries) {
			this.diff.put(diffEntry.getNewPath()  diffEntry);
		}
	},8,Body Change,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
init,private void init(Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		Repository repository = repositoryService.getRepository();
		ObjectReader objectReader = repository.newObjectReader();
		CanonicalTreeParser treeParserNew = new CanonicalTreeParser();
		OutputStream outputStream = System.out;
		this.diffFormatter = new DiffFormatter(outputStream);
		this.diffFormatter.setRepository(repositoryService.getRepository());
		this.diffFormatter.setDiffComparator(RawTextComparator.DEFAULT);
		RevCommit revCommit = repositoryService.findRevCommitById(commit.getId());
		RevCommit prevRevCommit = repositoryService.findRevCommitById(prevCommit.getId());
		treeParserNew.reset(objectReader  revCommit.getTree());
		CanonicalTreeParser treeParserOld = new CanonicalTreeParser();
		treeParserOld.reset(objectReader  prevRevCommit.getTree());
		this.diffEntries = this.diffFormatter.scan(treeParserOld  treeParserNew);
		if (detectRenames) {
			RenameDetector rd = new RenameDetector(repositoryService.getRepository());
			rd.addAll(diffEntries);
			rd.setRenameScore(RENAME_SCORE);
			diffEntries = rd.compute();
		}

		this.diff = new HashMap<>();
		for (DiffEntry diffEntry : diffEntries) {
			this.diff.put(diffEntry.getNewPath()  diffEntry);
		}
	},8,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
init,private void init(Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		Repository repository = repositoryService.getRepository();
		ObjectReader objectReader = repository.newObjectReader();
		CanonicalTreeParser treeParserNew = new CanonicalTreeParser();
		OutputStream outputStream = System.out;
		this.diffFormatter = new DiffFormatter(outputStream);
		this.diffFormatter.setRepository(repositoryService.getRepository());
		this.diffFormatter.setDiffComparator(RawTextComparator.DEFAULT);
		RevCommit revCommit = repositoryService.findRevCommitById(commit.getId());
		RevCommit prevRevCommit = repositoryService.findRevCommitById(prevCommit.getId());
		treeParserNew.reset(objectReader  revCommit.getTree());
		CanonicalTreeParser treeParserOld = new CanonicalTreeParser();
		treeParserOld.reset(objectReader  prevRevCommit.getTree());
		this.diffEntries = this.diffFormatter.scan(treeParserOld  treeParserNew);
		if (detectRenames) {
			RenameDetector rd = new RenameDetector(repositoryService.getRepository());
			rd.addAll(diffEntries);
			rd.setRenameScore(RENAME_SCORE);
			diffEntries = rd.compute();
		}

		this.diff = new HashMap<>();
		for (DiffEntry diffEntry : diffEntries) {
			this.diff.put(diffEntry.getNewPath()  diffEntry);
		}
	},8,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
init,private void init(Commit commit  Commit prevCommit  boolean detectRenames) throws IOException {
		Repository repository = repositoryService.getRepository();
		ObjectReader objectReader = repository.newObjectReader();
		CanonicalTreeParser treeParserNew = new CanonicalTreeParser();
		OutputStream outputStream = System.out;
		this.diffFormatter = new DiffFormatter(outputStream);
		this.diffFormatter.setRepository(repositoryService.getRepository());
		this.diffFormatter.setDiffComparator(RawTextComparator.DEFAULT);
		RevCommit revCommit = repositoryService.findRevCommitById(commit.getId());
		RevCommit prevRevCommit = repositoryService.findRevCommitById(prevCommit.getId());
		treeParserNew.reset(objectReader  revCommit.getTree());
		CanonicalTreeParser treeParserOld = new CanonicalTreeParser();
		treeParserOld.reset(objectReader  prevRevCommit.getTree());
		this.diffEntries = this.diffFormatter.scan(treeParserOld  treeParserNew);
		if (detectRenames) {
			RenameDetector rd = new RenameDetector(repositoryService.getRepository());
			rd.addAll(diffEntries);
			rd.setRenameScore(RENAME_SCORE);
			diffEntries = rd.compute();
		}

		this.diff = new HashMap<>();
		for (DiffEntry diffEntry : diffEntries) {
			this.diff.put(diffEntry.getNewPath()  diffEntry);
		}
	},8,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getSingleEditList,public EditList getSingleEditList(String filePathEndsWith) {
		EditList editList = null;
		for (DiffEntry entry : this.diffEntries) {
			FileHeader fileHeader = null;
			try {
				fileHeader = this.diffFormatter.toFileHeader(entry);
				if (entry.getOldPath().endsWith(filePathEndsWith)) {
					editList = fileHeader.toEditList();
					break;
				}
			} catch (IOException e) {
				log.warn("Exception thrown while generating EditList: " + e.getMessage());
			}

		}
		return editList;
	},8,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getSingleEditList,public EditList getSingleEditList(String filePathEndsWith) {
		EditList editList = null;
		for (DiffEntry entry : this.diffEntries) {
			FileHeader fileHeader = null;
			try {
				fileHeader = this.diffFormatter.toFileHeader(entry);
				if (entry.getOldPath().endsWith(filePathEndsWith)) {
					editList = fileHeader.toEditList();
					break;
				}
			} catch (IOException e) {
				log.warn("Exception thrown while generating EditList: " + e.getMessage());
			}

		}
		return editList;
	},8,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getSingleEditList,public EditList getSingleEditList(String filePathEndsWith) {
		EditList editList = null;
		for (DiffEntry entry : this.diffEntries) {
			FileHeader fileHeader = null;
			try {
				fileHeader = this.diffFormatter.toFileHeader(entry);
				if (entry.getOldPath().endsWith(filePathEndsWith)) {
					editList = fileHeader.toEditList();
					break;
				}
			} catch (IOException e) {
				log.warn("Exception thrown while generating EditList: " + e.getMessage());
			}

		}
		return editList;
	},8,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getSingleEditList,public EditList getSingleEditList(String filePathEndsWith) {
		EditList editList = null;
		for (DiffEntry entry : this.diffEntries) {
			FileHeader fileHeader = null;
			try {
				fileHeader = this.diffFormatter.toFileHeader(entry);
				if (entry.getOldPath().endsWith(filePathEndsWith)) {
					editList = fileHeader.toEditList();
					break;
				}
			} catch (IOException e) {
				log.warn("Exception thrown while generating EditList: " + e.getMessage());
			}

		}
		return editList;
	},8,,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
getSingleEditList,public EditList getSingleEditList(String filePathEndsWith) {
		EditList editList = null;
		for (DiffEntry entry : this.diffEntries) {
			FileHeader fileHeader = null;
			try {
				fileHeader = this.diffFormatter.toFileHeader(entry);
				if (entry.getOldPath().endsWith(filePathEndsWith)) {
					editList = fileHeader.toEditList();
					break;
				}
			} catch (IOException e) {
				log.warn("Exception thrown while generating EditList: " + e.getMessage());
			}

		}
		return editList;
	},8,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getSingleEditList,public EditList getSingleEditList(String filePathEndsWith) {
		EditList editList = null;
		for (DiffEntry entry : this.diffEntries) {
			FileHeader fileHeader = null;
			try {
				fileHeader = this.diffFormatter.toFileHeader(entry);
				if (entry.getOldPath().endsWith(filePathEndsWith)) {
					editList = fileHeader.toEditList();
					break;
				}
			} catch (IOException e) {
				log.warn("Exception thrown while generating EditList: " + e.getMessage());
			}

		}
		return editList;
	},8,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getSingleEditList,public EditList getSingleEditList(String filePathEndsWith) {
		EditList editList = null;
		for (DiffEntry entry : this.diffEntries) {
			FileHeader fileHeader = null;
			try {
				fileHeader = this.diffFormatter.toFileHeader(entry);
				if (entry.getOldPath().endsWith(filePathEndsWith)) {
					editList = fileHeader.toEditList();
					break;
				}
			} catch (IOException e) {
				log.warn("Exception thrown while generating EditList: " + e.getMessage());
			}

		}
		return editList;
	},8,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getSingleEditList,public EditList getSingleEditList(String filePathEndsWith) {
		EditList editList = null;
		for (DiffEntry entry : this.diffEntries) {
			FileHeader fileHeader = null;
			try {
				fileHeader = this.diffFormatter.toFileHeader(entry);
				if (entry.getOldPath().endsWith(filePathEndsWith)) {
					editList = fileHeader.toEditList();
					break;
				}
			} catch (IOException e) {
				log.warn("Exception thrown while generating EditList: " + e.getMessage());
			}

		}
		return editList;
	},8,Minor Modification,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getDiff,public Map<String  DiffEntry> getDiff() {
		return diff;
	},8,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getDiff,public Map<String  DiffEntry> getDiff() {
		return diff;
	},8,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getDiff,public Map<String  DiffEntry> getDiff() {
		return diff;
	},8,,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getDiff,public Map<String  DiffEntry> getDiff() {
		return diff;
	},8,,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
getDiff,public Map<String  DiffEntry> getDiff() {
		return diff;
	},8,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getDiff,public Map<String  DiffEntry> getDiff() {
		return diff;
	},8,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getDiff,public Map<String  DiffEntry> getDiff() {
		return diff;
	},8,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getDiff,public Map<String  DiffEntry> getDiff() {
		return diff;
	},8,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
getPathMapping,public Map<String  String> getPathMapping() {
		if (this.pathMapping == null) {
			this.pathMapping = new HashMap<>();
			for (DiffEntry diffEntry : this.diffEntries) {
				String oldPath = diffEntry.getOldPath();
				String newPath = diffEntry.getNewPath();
				if (!NULL_PATH.equals(oldPath)) {
					this.pathMapping.put(oldPath  newPath);
				}
			}
		}
		return this.pathMapping;
	},8,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getPathMapping,public Map<String  String> getPathMapping() {
		if (this.pathMapping == null) {
			this.pathMapping = new HashMap<>();
			for (DiffEntry diffEntry : this.diffEntries) {
				String oldPath = diffEntry.getOldPath();
				String newPath = diffEntry.getNewPath();
				if (!NULL_PATH.equals(oldPath)) {
					this.pathMapping.put(oldPath  newPath);
				}
			}
		}
		return this.pathMapping;
	},8,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getPathMapping,public Map<String  String> getPathMapping() {
		if (this.pathMapping == null) {
			this.pathMapping = new HashMap<>();
			for (DiffEntry diffEntry : this.diffEntries) {
				String oldPath = diffEntry.getOldPath();
				String newPath = diffEntry.getNewPath();
				if (!NULL_PATH.equals(oldPath)) {
					this.pathMapping.put(oldPath  newPath);
				}
			}
		}
		return this.pathMapping;
	},8,Signature Change | Body Change,476b403d1c73c8e4d37d82e21b72d2a3d2383f65,Felix Grund,Different bugfixes and improvements during empirical analysis 
getPathMapping,public Map<String  String> getPathMapping() {
		if (this.pathMapping == null) {
			this.pathMapping = new HashMap<>();
			for (DiffEntry diffEntry : this.diffEntries) {
				String oldPath = diffEntry.getOldPath();
				String newPath = diffEntry.getNewPath();
				if (!NULL_PATH.equals(oldPath)) {
					this.pathMapping.put(oldPath  newPath);
				}
			}
		}
		return this.pathMapping;
	},8,,2f1c3ca428a57c215e17fa5387382f392f236b08,Felix Grund,fixed issues for junit5 
getPathMapping,public Map<String  String> getPathMapping() {
		if (this.pathMapping == null) {
			this.pathMapping = new HashMap<>();
			for (DiffEntry diffEntry : this.diffEntries) {
				String oldPath = diffEntry.getOldPath();
				String newPath = diffEntry.getNewPath();
				if (!NULL_PATH.equals(oldPath)) {
					this.pathMapping.put(oldPath  newPath);
				}
			}
		}
		return this.pathMapping;
	},8,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getPathMapping,public Map<String  String> getPathMapping() {
		if (this.pathMapping == null) {
			this.pathMapping = new HashMap<>();
			for (DiffEntry diffEntry : this.diffEntries) {
				String oldPath = diffEntry.getOldPath();
				String newPath = diffEntry.getNewPath();
				if (!NULL_PATH.equals(oldPath)) {
					this.pathMapping.put(oldPath  newPath);
				}
			}
		}
		return this.pathMapping;
	},8,,c1d26d3f6b54f162a4c4beac8043e4205812e8f6,Felix Grund,Fixed issue with parent scope check 
getPathMapping,public Map<String  String> getPathMapping() {
		if (this.pathMapping == null) {
			this.pathMapping = new HashMap<>();
			for (DiffEntry diffEntry : this.diffEntries) {
				String oldPath = diffEntry.getOldPath();
				String newPath = diffEntry.getNewPath();
				if (!NULL_PATH.equals(oldPath)) {
					this.pathMapping.put(oldPath  newPath);
				}
			}
		}
		return this.pathMapping;
	},8,,3817554bb0129ae267a3315bf9235f500306daab,Felix Grund,Caching for expensive methods 
getPathMapping,public Map<String  String> getPathMapping() {
		if (this.pathMapping == null) {
			this.pathMapping = new HashMap<>();
			for (DiffEntry diffEntry : this.diffEntries) {
				String oldPath = diffEntry.getOldPath();
				String newPath = diffEntry.getNewPath();
				if (!NULL_PATH.equals(oldPath)) {
					this.pathMapping.put(oldPath  newPath);
				}
			}
		}
		return this.pathMapping;
	},8,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
Yexceptions,public Yexceptions(List<String> exceptions) {
		this.exceptions = exceptions;
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
equals,@Override
	public boolean equals(Object obj) {
		return obj instanceof Yexceptions && this.exceptions.equals(((Yexceptions) obj).getExceptions());
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getExceptions,public List<String> getExceptions() {
		return exceptions;
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
toString,@Override
	public String toString() {
		return this.exceptions.toString();
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
put,@Override
	public Ychange put(String commitName  Ychange change) {
		builder.append("\n").append(commitName).append(":").append(change.toString());
		return super.put(commitName  change);
	},4,Annotation Change | Signature Change | Body Change,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
put,@Override
	public Ychange put(String commitName  Ychange change) {
		builder.append("\n").append(commitName).append(":").append(change.toString());
		return super.put(commitName  change);
	},4,Body Change,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
put,@Override
	public Ychange put(String commitName  Ychange change) {
		builder.append("\n").append(commitName).append(":").append(change.toString());
		return super.put(commitName  change);
	},4,Parameter Change | Signature Change | Body Change,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
put,@Override
	public Ychange put(String commitName  Ychange change) {
		builder.append("\n").append(commitName).append(":").append(change.toString());
		return super.put(commitName  change);
	},4,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
toString,@Override
	public String toString() {
		return builder.toString();
	},4,Annotation Change | Signature Change | Body Change,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
toString,@Override
	public String toString() {
		return builder.toString();
	},4,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
toString,@Override
	public String toString() {
		return builder.toString();
	},4,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
toString,@Override
	public String toString() {
		return builder.toString();
	},4,,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
toJson,public String toJson() {
		JsonObject jsonObj = new JsonObject();
		for (String commitName : this.keySet()) {
			jsonObj.add(commitName  this.get(commitName).toJsonObject());
		}
		return jsonObj.toString();
	},4,,d58bb9f19ffe870b6a3a9c30a359f565b1a71ff4,Felix Grund,Performance improvements (static ast cache)  env variable renames  result logging  etc. 
toJson,public String toJson() {
		JsonObject jsonObj = new JsonObject();
		for (String commitName : this.keySet()) {
			jsonObj.add(commitName  this.get(commitName).toJsonObject());
		}
		return jsonObj.toString();
	},4,,fdbec3db356a3f057bd11c59850388cd7342ff75,Felix Grund,make junit tests work 
toJson,public String toJson() {
		JsonObject jsonObj = new JsonObject();
		for (String commitName : this.keySet()) {
			jsonObj.add(commitName  this.get(commitName).toJsonObject());
		}
		return jsonObj.toString();
	},4,,8962f1dc10374d30e2bec50d3223c74233f4976a,Felix Grund,Yresult now has strings as keys 
toJson,public String toJson() {
		JsonObject jsonObj = new JsonObject();
		for (String commitName : this.keySet()) {
			jsonObj.add(commitName  this.get(commitName).toJsonObject());
		}
		return jsonObj.toString();
	},4,Signature Change | Body Change,e988c879995c57a972b57d51f61045ee2c6a2dd8,Braxton Hall,Webservice support (#18)  * Add Yresult::toJson()  * Update JavaParser.java  * Update JsParser.java  * Added diff to Yintroduced  * Delete .DS_Store  * Replace stacktrace printing with proper log warnings 
Yreturn,public Yreturn(String type) {
		this.type = type;
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
equals,@Override
	public boolean equals(Object obj) {
		boolean ret = false;
		if (obj instanceof Yreturn) {
			Yreturn otherReturn = (Yreturn) obj;
			ret = this.type.equals(otherReturn.getType());
		}
		return ret;
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
getType,public String getType() {
		return type;
	},1,,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
toString,@Override
	public String toString() {
		return this.type;
	},1,Annotation Change | Signature Change | Body Change,c4f895269ef2fe2db7261ac414f6239909c0b2c4,Felix Grund,Added json returns for different change types 
Ycommit,public Ycommit() {},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
Ycommit,public Ycommit() {},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
Ycommit,public Ycommit() {},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
Ycommit,public Ycommit() {},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
Ycommit,public Ycommit(Commit commit) {
		this.commit = commit;
		this.hash = commit.getName();
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
Ycommit,public Ycommit(Commit commit) {
		this.commit = commit;
		this.hash = commit.getName();
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
Ycommit,public Ycommit(Commit commit) {
		this.commit = commit;
		this.hash = commit.getName();
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
Ycommit,public Ycommit(Commit commit) {
		this.commit = commit;
		this.hash = commit.getName();
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getCommit,public Commit getCommit() {
		return commit;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getCommit,public Commit getCommit() {
		return commit;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getCommit,public Commit getCommit() {
		return commit;
	},4,Signature Change | Return Type Change,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getCommit,public Commit getCommit() {
		return commit;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getMatchedFunction,public Yfunction getMatchedFunction() {
		return matchedFunction;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getMatchedFunction,public Yfunction getMatchedFunction() {
		return matchedFunction;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getMatchedFunction,public Yfunction getMatchedFunction() {
		return matchedFunction;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getMatchedFunction,public Yfunction getMatchedFunction() {
		return matchedFunction;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setMatchedFunction,public void setMatchedFunction(Yfunction matchedFunction) {
		this.matchedFunction = matchedFunction;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
setMatchedFunction,public void setMatchedFunction(Yfunction matchedFunction) {
		this.matchedFunction = matchedFunction;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setMatchedFunction,public void setMatchedFunction(Yfunction matchedFunction) {
		this.matchedFunction = matchedFunction;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setMatchedFunction,public void setMatchedFunction(Yfunction matchedFunction) {
		this.matchedFunction = matchedFunction;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFileContent,public String getFileContent() {
		return fileContent;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFileContent,public String getFileContent() {
		return fileContent;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFileContent,public String getFileContent() {
		return fileContent;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFileContent,public String getFileContent() {
		return fileContent;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFileContent,public void setFileContent(String fileContent) {
		this.fileContent = fileContent;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
setFileContent,public void setFileContent(String fileContent) {
		this.fileContent = fileContent;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFileContent,public void setFileContent(String fileContent) {
		this.fileContent = fileContent;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFileContent,public void setFileContent(String fileContent) {
		this.fileContent = fileContent;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFileName,public void setFileName(String fileName) {
		this.fileName = fileName;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFileName,public String getFileName() {
		return fileName;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFileName,public String getFileName() {
		return fileName;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFileName,public String getFileName() {
		return fileName;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFileName,public String getFileName() {
		return fileName;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getPrev,public Ycommit getPrev() {
		return prev;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getPrev,public Ycommit getPrev() {
		return prev;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getPrev,public Ycommit getPrev() {
		return prev;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getPrev,public Ycommit getPrev() {
		return prev;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setPrev,public void setPrev(Ycommit prev) {
		this.prev = prev;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
setPrev,public void setPrev(Ycommit prev) {
		this.prev = prev;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setPrev,public void setPrev(Ycommit prev) {
		this.prev = prev;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setPrev,public void setPrev(Ycommit prev) {
		this.prev = prev;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getFilePath,public String getFilePath() {
		return filePath;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getFilePath,public String getFilePath() {
		return filePath;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getFilePath,public String getFilePath() {
		return filePath;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getFilePath,public String getFilePath() {
		return filePath;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setFilePath,public void setFilePath(String filePath) {
		this.filePath = filePath;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getParser,public Yparser getParser() {
		return parser;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getParser,public Yparser getParser() {
		return parser;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getParser,public Yparser getParser() {
		return parser;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getParser,public Yparser getParser() {
		return parser;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
setParser,public void setParser(Yparser parser) {
		this.parser = parser;
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
setParser,public void setParser(Yparser parser) {
		this.parser = parser;
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
setParser,public void setParser(Yparser parser) {
		this.parser = parser;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
setParser,public void setParser(Yparser parser) {
		this.parser = parser;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
toString,public String toString() {
		return this.getCommit().getCommitDate() + " " + hash;
	},4,Body Change,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
toString,public String toString() {
		return this.getCommit().getCommitDate() + " " + hash;
	},4,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
toString,public String toString() {
		return this.getCommit().getCommitDate() + " " + hash;
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
toString,public String toString() {
		return this.getCommit().getCommitDate() + " " + hash;
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getName,public String getName() {
		return this.commit.getName();
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getName,public String getName() {
		return this.commit.getName();
	},4,,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getName,public String getName() {
		return this.commit.getName();
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getName,public String getName() {
		return this.commit.getName();
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
getShortName,public String getShortName() {
		return commit.getCommitNameShort();
	},4,,102dbe06ed30e49facf5de1d4731c7bb2127944c,Felix Grund,Started frontend implementation 
getShortName,public String getShortName() {
		return commit.getCommitNameShort();
	},4,Body Change,5646fc7e193ae6438ea8f2c7738ade99fac06a94,Felix Grund,work in progress trying to fix heap space 
getShortName,public String getShortName() {
		return commit.getCommitNameShort();
	},4,,728fa55d27626f9b3d63406626eba14cfac0dd0c,Felix Grund,major refactoring to not keep RevCommits in heap space 
getShortName,public String getShortName() {
		return commit.getCommitNameShort();
	},4,,368deaf1cf33e520fe957c5141f0aad4a602b9e5,Felix Grund,Performance improvements and memory leak fixing (still not perfect though) 
